<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart HR Management System</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" xintegrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoVBL5gI9kLmbG0C+wFjr8bCqwY2SA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Quill Rich Text Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    
    <!-- Custom Styles & Fonts -->
    <style>
        @import url('https://rsms.me/inter/inter.css');
        html, body { 
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; /* Prevents horizontal scrolling */
        }
        /* Base input styles for a consistent look */
        .input, .select {
            margin-top: 0.25rem; display: block; width: 100%; padding: 0.5rem 0.75rem;
            border-width: 1px; border-color: #475569; border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); line-height: 1.5;
            background-color: #334155; color: #f1f5f9;
        }
        .input:focus, .select:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            --tw-ring-color: #2563eb; border-color: #2563eb;
        }
        .input[disabled], .select[disabled] {
            background-color: #475569;
            cursor: not-allowed;
            opacity: 0.7;
        }
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Styles for rendered policy content */
        .policy-content p { margin-bottom: 1rem; line-height: 1.6; }
        .policy-content h1, .policy-content h2, .policy-content h3 { font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; color: #f1f5f9; border-bottom: 1px solid #475569; padding-bottom: 0.25rem; }
        .policy-content h1 { font-size: 1.5em; }
        .policy-content h2 { font-size: 1.25em; }
        .policy-content h3 { font-size: 1.1em; }
        .policy-content ul, .policy-content ol { margin-left: 1.5rem; margin-bottom: 1rem; }
        .policy-content ul { list-style-type: disc; }
        .policy-content ol { list-style-type: decimal; }
        .policy-content a { color: #60a5fa; text-decoration: underline; }
        .policy-content strong { font-weight: bold; }
        .policy-content em { font-style: italic; }
        .policy-content u { text-decoration: underline; }
        .policy-content pre { background-color: #1e293b; padding: 1rem; border-radius: 0.5rem; white-space: pre-wrap; }
        .policy-content blockquote { border-left: 4px solid #475569; padding-left: 1rem; margin-left: 0; color: #94a3b8; }
        /* NEW: Animation for success message */
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in-out {
            animation: fadeInOut 5s ease-in-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">
    <div id="root"></div>

    <!-- Firebase SDK Module -->
    <script type="module">
        // Firebase SDK imports
        import { initializeApp, deleteApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, doc, addDoc, updateDoc, deleteDoc, query, where, serverTimestamp, getDocs, writeBatch, enableIndexedDbPersistence, setDoc, orderBy, limit, startAfter, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Make Firebase SDK available globally for the Babel script
        window.firebaseSDK = {
            initializeApp, deleteApp, getAuth, getFirestore, collection, onSnapshot,
            doc, addDoc, updateDoc, deleteDoc, query, where, serverTimestamp,
            signInWithEmailAndPassword, onAuthStateChanged, signOut, getDocs, writeBatch,
            enableIndexedDbPersistence, setDoc,
            orderBy, limit, startAfter, createUserWithEmailAndPassword, runTransaction // Added for new user creation
        };
    </script>
    
    <!-- React Application Script -->
    <script type="text/babel">
        // --- START REACT & FIREBASE SETUP ---
        const { useState, useEffect, useMemo, useCallback, createContext, useContext, memo, useRef } = React;

        // ===================================================================================
        // === FIREBASE CONFIGURATION ===
        // To deploy this application for a new company, replace the values in the
        // `firebaseConfig` object below with the new project's configuration details
        // from the Firebase console. This is the ONLY place you need to change it.
        // ===================================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyB7_pnmwHj6aOeZRTykPvNusNFYReaTY6Q",
            authDomain: "hrsm-j.firebaseapp.com",
            projectId: "hrsm-j",
            storageBucket: "hrsm-j.appspot.com",
            messagingSenderId: "45063715478",
            appId: "1:45063715478:web:cc2dd21b83dd195771e0b7",
            measurementId: "G-8HQDG2LTKP"
        };

        // NEW: Dynamic Configuration Loader
        // Checks localStorage for an admin-saved configuration.
        // Falls back to the hardcoded config if nothing is found.
        let activeFirebaseConfig = firebaseConfig;
        try {
            const customConfigStr = localStorage.getItem('customFirebaseConfig');
            if (customConfigStr) {
                const customConfig = JSON.parse(customConfigStr);
                // Basic validation to ensure it's a valid config object
                if (customConfig.apiKey && customConfig.projectId) {
                    activeFirebaseConfig = customConfig;
                    console.log("Using custom Firebase configuration from localStorage.");
                }
            }
        } catch (error) {
            console.error("Failed to parse custom Firebase config, using default.", error);
        }

        // NEW: Connectivity Context for online/offline status
        const ConnectivityContext = createContext(null);
        const useConnectivity = () => useContext(ConnectivityContext);
        const ConnectivityProvider = ({ children }) => {
            const [isOnline, setIsOnline] = useState(navigator.onLine);

            useEffect(() => {
                const updateOnlineStatus = () => {
                    setIsOnline(navigator.onLine);
                };

                window.addEventListener('online', updateOnlineStatus);
                window.addEventListener('offline', updateOnlineStatus);

                // Set up a polling interval as a fallback for iframe environments where
                // the 'online'/'offline' events may not fire reliably. This checks the
                // navigator.onLine property directly every 3 seconds.
                const interval = setInterval(updateOnlineStatus, 3000);

                return () => {
                    window.removeEventListener('online', updateOnlineStatus);
                    window.removeEventListener('offline', updateOnlineStatus);
                    clearInterval(interval); // Cleanup on component unmount
                };
            }, []);

            return (
                <ConnectivityContext.Provider value={{ isOnline }}>
                    {children}
                </ConnectivityContext.Provider>
            );
        };

        // Firebase Configuration - MOVED TO TOP OF SCRIPT

        // Firebase Context for providing db and auth instances throughout the app
        const FirebaseContext = createContext(null);
        const useFirebase = () => useContext(FirebaseContext);

        const FirebaseProvider = ({ children }) => {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [currentUser, setCurrentUser] = useState(null);
            const [userProfile, setUserProfile] = useState(null);
            const [loading, setLoading] = useState(true);

            // Initialize Firebase and Auth state listener
            useEffect(() => {
                try {
                    const { initializeApp, getFirestore, getAuth, onAuthStateChanged, enableIndexedDbPersistence } = window.firebaseSDK;
                    const app = initializeApp(activeFirebaseConfig);
                    const dbInstance = getFirestore(app);
                    
                    // Enable offline persistence
                    enableIndexedDbPersistence(dbInstance).catch((err) => {
                        if (err.code === 'failed-precondition') console.warn("Firestore persistence failed: Multiple tabs open.");
                        else if (err.code === 'unimplemented') console.warn("Firestore persistence failed: Browser does not support it.");
                    });

                    const authInstance = getAuth(app);
                    setAuth(authInstance);
                    setDb(dbInstance);

                    const unsubscribe = onAuthStateChanged(authInstance, (user) => {
                        setCurrentUser(user);
                        if (!user) {
                            setUserProfile(null);
                            setLoading(false);
                        }
                    });
                    return () => unsubscribe();
                } catch (error) { 
                    console.error("Firebase initialization error:", error); 
                    setLoading(false);
                } 
            }, []);

            // Fetch user profile from Firestore when auth state changes
            useEffect(() => {
                if (!db || !currentUser) {
                    if (!currentUser) setLoading(false);
                    setUserProfile(null);
                    return;
                }

                setLoading(true);
                const { collection, query, where, onSnapshot } = window.firebaseSDK;
                const q = query(collection(db, "employees"), where("uid", "==", currentUser.uid));
                
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    if (!snapshot.empty) {
                        const userDoc = snapshot.docs[0];
                        setUserProfile({ id: userDoc.id, ...userDoc.data() });
                    } else {
                        console.warn("Authenticated user has no employee profile in Firestore.");
                        setUserProfile(null);
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching user profile:", error);
                    setLoading(false);
                });

                return () => unsubscribe();
            }, [db, currentUser]);

            const value = { db, auth, currentUser, userProfile, loading };
            return <FirebaseContext.Provider value={value}>{children}</FirebaseContext.Provider>;
        };
        
        // Custom hook for real-time Firestore collection data
        const useCollection = (collectionName, queryConstraints = []) => {
            const { db, currentUser } = useFirebase(); // Get currentUser
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!db || !currentUser) { // Add guard for currentUser
                    // If there's no user yet, we are in a loading state. Don't set loading to false.
                    setLoading(true);
                    return;
                }

                setLoading(true);
                const { collection, onSnapshot, query } = window.firebaseSDK;
                const q = query(collection(db, collectionName), ...queryConstraints);
                const unsubscribe = onSnapshot(q, (querySnapshot) => {
                    const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setData(items);
                    setLoading(false);
                }, (error) => {
                    console.error(`Error fetching collection ${collectionName}:`, error);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [db, currentUser, collectionName, JSON.stringify(queryConstraints)]); // Add currentUser to dependency array
            return { data, loading };
        };

        // Custom hook for one-time Firestore collection data fetch
        const useStaticCollection = (collectionName) => {
            // FIX: Get currentUser from useFirebase to check authentication status.
            const { db, currentUser } = useFirebase();
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                // FIX: Add a guard clause. Do not attempt to fetch data until both the
                // database connection is ready AND a user is authenticated.
                if (!db || !currentUser) {
                    // If there's no DB, something is wrong. If there's no user yet, we just wait.
                    if (!db) setLoading(false);
                    return;
                }
                
                const fetchData = async () => {
                    setLoading(true);
                    try {
                        const { collection, getDocs } = window.firebaseSDK;
                        const querySnapshot = await getDocs(collection(db, collectionName));
                        const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setData(items);
                    } catch (error) {
                        console.error(`Error performing one-time fetch for ${collectionName}:`, error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchData();
            // FIX: Add currentUser to the dependency array. This ensures the hook re-runs
            // once the user has been authenticated.
            }, [db, currentUser, collectionName]);

            return { data, loading };
        };
        
        // NEW: Standalone payroll calculation logic
        const calculatePayrollForEmployee = (employee, selectedMonth, allData, manualLoanDeduction) => {
            if (!employee || !selectedMonth) return { inputs: {}, calculations: {} };

            const { attendance, leaveRequests, otRequests, staffLoans, employeeStates, salaryRevisions, shops, shifts } = allData;

            // --- 1. Filter data for the selected employee and month ---
            const monthAttendance = (attendance || []).filter(r => r.employeeId === employee.id && r.timestamp?.toDate().toISOString().startsWith(selectedMonth));
            const monthLeave = (leaveRequests || []).filter(r => r.staffId === employee.id && r.status === 'Approved' && r.leaveDate.startsWith(selectedMonth));
            const monthOT = (otRequests || []).filter(r => r.staffId === employee.id && r.status === 'Approved' && r.reqDate.startsWith(selectedMonth));
            const monthStates = (employeeStates || []).filter(r => r.staffId === employee.id && r.date.startsWith(selectedMonth));
            const activeLoan = (staffLoans || []).find(l => l.staffId === employee.id && l.status === 'Active' && (!l.effectiveDate || l.effectiveDate.slice(0, 7) <= selectedMonth));

            // --- MOVED UP: Calculate Base Salary & Salary Per Day first, as it's needed for penalty calculation ---
            const [year, month] = selectedMonth.split('-').map(Number);
            const daysInMonth = new Date(year, month, 0).getDate();
            const applicableRevisions = (salaryRevisions || [])
                .filter(rev => rev.staffId === employee.id && rev.effectiveDate && rev.effectiveDate <= `${selectedMonth}-31` && rev.status === 'Approved')
                .sort((a, b) => b.effectiveDate.localeCompare(a.effectiveDate));
            
            const baseSalary = applicableRevisions.length > 0
                ? (parseFloat(String(applicableRevisions[0].updatedSalary).replace(/[^0-9.-]/g, '')) || 0)
                : (parseFloat(String(employee.salary).replace(/[^0-9.-]/g, '')) || 0);
            
            const salaryPerDay = baseSalary > 0 && daysInMonth > 0 ? baseSalary / daysInMonth : 0;


            // --- 2. Calculate inputs automatically ---
            const leaveDays = monthLeave.reduce((sum, r) => sum + (parseFloat(r.numberOfDays) || 0), 0);
            const otDays = monthOT.reduce((sum, r) => sum + (parseFloat(r.numberOfOTDays) || 0), 0);
            const loanDeduction = manualLoanDeduction !== undefined ? parseFloat(manualLoanDeduction) : (activeLoan ? parseFloat(activeLoan.agreedMonthlyDeduction) || 0 : 0);
            const totalLateDays = monthStates.filter(es => es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @')).length;

            // NEW: Get the employee's primary shop and their assigned timezone. This is crucial for all date calculations.
            const employeeShopName = Array.isArray(employee.shop) ? employee.shop[0] : employee.shop;
            const employeeShop = (shops || []).find(s => s.name === employeeShopName);
            const employeeShopTimezone = employeeShop?.timezone; // e.g., 'Asia/Phnom_Penh'

            const dailyRecords = {};
            monthAttendance.forEach(rec => {
                // FIX: Use the timezone-aware utility to get the date key based on the shop's local timezone.
                const { localDate: dayKey } = Utils.formatDateInTimezone(rec.timestamp, employeeShopTimezone);
                
                if (!dailyRecords[dayKey]) dailyRecords[dayKey] = [];
                // Push the original Javascript Date object for time difference calculations.
                dailyRecords[dayKey].push({ date: rec.timestamp.toDate(), type: rec.type });
            });
            
            let workDays = 0;
            let noCheckOutCount = 0;
            // FIX: Get today's date string formatted in the shop's local timezone to correctly identify past vs. present days.
            const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => new Date() }, employeeShopTimezone);


            Object.entries(dailyRecords).forEach(([dayKey, dayRecs]) => {
                const ins = dayRecs.filter(r => r.type === 'in').sort((a,b) => a.date - b.date);
                const outs = dayRecs.filter(r => r.type === 'out').sort((a,b) => b.date - a.date);
                if (ins.length > 0 && outs.length > 0) {
                    const diffHours = (outs[0].date.getTime() - ins[0].date.getTime()) / 3600000;
                    if (diffHours >= 7) workDays += 1;
                    else if (diffHours >= 4) workDays += 0.5;
                } else if (ins.length > 0 && dayKey < todayStr) {
                    noCheckOutCount += 1;
                }
            });

            // NEW: Calculate Absent days & Penalty for absence on a rejected leave day.
            const attendedDays = new Set(Object.keys(dailyRecords));
            let absentDays = 0;
            let rejectedLeavePenaltyAmount = 0; // Initialize penalty amount

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDay = new Date(year, month - 1, day);
                const loop_year = currentDay.getFullYear();
                const loop_month = String(currentDay.getMonth() + 1).padStart(2, '0');
                const loop_day = String(currentDay.getDate()).padStart(2, '0');
                const dayKey = `${loop_year}-${loop_month}-${loop_day}`;

                // FIX: Compare against the timezone-aware 'today' string instead of a local Date object.
                if (dayKey >= todayStr) break; // Don't count today or future days as absent.

                // An absence is a past day with no attendance record.
                if (!attendedDays.has(dayKey)) {
                    // FIX: Check if the employee was on approved leave for this day before marking as absent.
                    const isOnApprovedLeave = monthLeave.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                    
                    if (!isOnApprovedLeave) {
                        absentDays++; // Only count as absent if not on approved leave.

                        // Check if there was a REJECTED leave request for this absent day.
                        const hadRejectedLeave = (leaveRequests || []).some(
                            lr => lr.staffId === employee.id &&
                                  lr.status === 'Rejected' &&
                                  // Check if the absent day falls within the rejected leave period.
                                  dayKey >= lr.leaveDate && dayKey < lr.returnDate 
                        );
                        
                        if (hadRejectedLeave) {
                            // Apply penalty: Salary per day x 2
                            rejectedLeavePenaltyAmount += (salaryPerDay * 2);
                        }
                    }
                }
            }
            
            const noAttendance = absentDays + noCheckOutCount;

            // NEW: Calculate "Given Off Days" based on the total number of work days.
            const givenOffDays = Math.floor(workDays / 6.5);

            // FIX: Create the autoInputs object to be returned, now including noAttendance.
            const autoInputs = { workDays, givenOffDays, otDays, leaveDays, totalLateDays, noCheckOutCount, loanDeduction, noAttendance };

            // --- 3. Perform Final Salary Calculations ---
            const engagements = monthStates.filter(es => es.statusState === 'Engagement' && es.status === 'Approved').reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);
            
            const lateDeductionsAmount = monthStates.filter(es => {
                if (!(es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @'))) return false;
                const hasLeave = (leaveRequests || []).some(lr => lr.staffId === es.staffId && lr.status === 'Approved' && es.date >= lr.leaveDate && es.date < lr.returnDate);
                return !hasLeave;
            }).reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);
            
            const otherDeductions = monthStates.filter(es => es.statusState === 'Deduction' && !es.note?.includes('CheckIn Late @')).reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);

            // "No-CheckOut" is informational. Any associated monetary deduction is handled via the "Other Deductions" from Employee States.
            const daysToPayFor = (workDays || 0) + (givenOffDays || 0);
            const baseSalaryEarned = salaryPerDay * (daysToPayFor > 0 ? daysToPayFor : 0);
            const otSalary = salaryPerDay * (otDays || 0);
            const grossSalary = baseSalaryEarned + otSalary + engagements;

            // --- NEW: Step 3 - Calculate Voluntary Savings Deduction ---
            let savingsDeduction = 0;
            // MODIFIED: Added a check to ensure the payroll month is on or after the employee's effective saving month.
            if (
                employee.savingsProgramStatus === 'Active' &&
                parseFloat(employee.savingsPercentage) > 0 &&
                employee.savingsEffectiveMonth && 
                selectedMonth >= employee.savingsEffectiveMonth
            ) {
                const percentage = parseFloat(employee.savingsPercentage) / 100;
                savingsDeduction = grossSalary * percentage;
            }
            // --- END: Step 3 ---
            
            // CORRECTED & UPDATED: Added the new penalty AND savings deduction to total deductions.
            const totalDeductions = loanDeduction + lateDeductionsAmount + otherDeductions + rejectedLeavePenaltyAmount + savingsDeduction;
            const netSalary = grossSalary - totalDeductions;

            // CORRECTED & UPDATED: Added new penalty and savings amounts to the returned calculations object.
            const calculations = { baseSalary, salaryPerDay, daysInMonth, baseSalaryEarned, otSalary, engagements, grossSalary, otherDeductions, totalDeductions, netSalary, lateDeductionsAmount, rejectedLeavePenaltyAmount, savingsDeduction };

            return { inputs: autoInputs, calculations };
        };
        
        // NEW: Centralized Payroll Calculator Hook
        const usePayrollCalculator = (employee, selectedMonth, allData, manualLoanDeduction) => {
            return useMemo(() => {
                // The complex logic is now in a separate function.
                return calculatePayrollForEmployee(employee, selectedMonth, allData, manualLoanDeduction);
            }, [employee, selectedMonth, allData, manualLoanDeduction]);
        };

        // NEW: Phase 3 - App Data Context for centralizing common data
        const AppDataContext = createContext(null);
        const useAppData = () => useContext(AppDataContext);

        const AppDataProvider = ({ children }) => {
            const { userProfile } = useFirebase();
            const { where } = window.firebaseSDK;
            
            // Create role-based query constraints to prevent permission errors.
            const employeeQueryConstraints = useMemo(() => {
                if (!userProfile) {
                    // While loading or logged out, fetch no employees.
                    return [where("uid", "==", "null")];
                }
                const { role, uid } = userProfile;
                if (role === 'Admin' || role === 'CEO' || role === 'Shop Manager') {
                    // Admins, CEOs, and Managers need the full list for dropdowns and management tasks.
                    // This assumes security rules permit them to read the whole collection.
                    return [];
                }
                // Staff role should only fetch their own document to avoid permission errors.
                return [where("uid", "==", uid)];
            }, [userProfile]);

            // Use one-time static fetches for data that doesn't change often.
            // This is more efficient than real-time listeners for this type of data.
            const { data: employees, loading: employeesLoading } = useCollection('employees', employeeQueryConstraints);
            const { data: shops, loading: shopsLoading } = useStaticCollection('shops');
            const { data: shifts, loading: shiftsLoading } = useStaticCollection('shifts');
            const { data: positions, loading: positionsLoading } = useStaticCollection('positions');

            // Combine all loading states into a single flag.
            const isLoading = employeesLoading || shopsLoading || shiftsLoading || positionsLoading;

            // Memoize the context value to prevent unnecessary re-renders of consumers.
            const value = useMemo(() => ({
                employees,
                shops,
                shifts,
                positions,
                isLoading
            }), [employees, shops, shifts, positions, isLoading]);

            return (
                <AppDataContext.Provider value={value}>
                    {children}
                </AppDataContext.Provider>
            );
        };
        // --- END REACT & FIREBASE SETUP ---

        // --- START UTILITY FUNCTIONS ---
        const Utils = {
            formatCurrency: (value, currency = 'KHR') => {
                if (value === null || value === undefined) return '';
                const num = parseFloat(String(value).replace(/[^0-9.-]/g, ''));
                if (isNaN(num)) return '';
                const options = { style: 'currency', currency: currency, minimumFractionDigits: currency === 'KHR' ? 0 : 2, maximumFractionDigits: currency === 'KHR' ? 0 : 2 };
                const locale = currency === 'KHR' ? 'km-KH' : 'en-US';
                let formatted = new Intl.NumberFormat(locale, options).format(num);
                if (currency === 'KHR') { formatted = formatted.replace('KHR', '៛').trim(); }
                return formatted;
            },
            formatRequestDate: (timestamp) => {
                if (!timestamp || !timestamp.toDate) return 'N/A';
                const date = timestamp.toDate();
                return `${date.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' })} | ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}`;
            },
            formatISOToDisplay: (isoDate) => {
                if (!isoDate || typeof isoDate !== 'string' || !isoDate.includes('-')) return isoDate || '';
                const [year, month, day] = isoDate.split('-');
                return `${day}-${month}-${year}`;
            },
            calculateWorkedDuration: (joinedDate, endDate) => { // Add endDate parameter
                if (!joinedDate) return 'N/A';
                const start = new Date(joinedDate);
                if (isNaN(start.getTime())) return 'N/A';
                const end = endDate ? new Date(endDate) : new Date(); // Use endDate if provided, else use now
                if (isNaN(end.getTime())) return 'N/A'; // Add a check for a valid end date

                let years = end.getFullYear() - start.getFullYear();
                let months = end.getMonth() - start.getMonth();
                let days = end.getDate() - start.getDate();
                if (days < 0) { months--; days += new Date(end.getFullYear(), end.getMonth(), 0).getDate(); }
                if (months < 0) { years--; months += 12; }
                return `${years}Y ${months}M ${days}D`;
            },
            // NEW: Timezone-aware date formatting utility
            formatDateInTimezone: (timestamp, timezone) => {
                // Return defaults if the timestamp is invalid
                if (!timestamp || !timestamp.toDate) {
                    return { localDate: 'N/A', displayDate: 'N/A', localTime: 'N/A' };
                }

                const date = timestamp.toDate();
                // Use the provided timezone, but fall back to the user's browser timezone if it's missing.
                const tz = timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;

                try {
                    // 'sv-SE' (Swedish) locale reliably gives the YYYY-MM-DD format.
                    const localDate = date.toLocaleDateString('sv-SE', { timeZone: tz });
                    
                    // 'en-GB' gives the DD/MM/YYYY format for display purposes.
                    const displayDate = date.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', timeZone: tz });

                    const localTime = date.toLocaleTimeString('en-US', {
                        hour: '2-digit', minute: '2-digit', hour12: true, timeZone: tz
                    });

                    return { localDate, displayDate, localTime };
                } catch (error) {
                    console.error("Invalid timezone provided to formatter:", timezone, error);
                    // If the provided timezone is invalid, fall back to basic UTC conversion to prevent crashes.
                    const localDate = date.toISOString().split('T')[0];
                    return { localDate, displayDate: localDate, localTime: date.toUTCString() };
                }
            },
            // Haversine formula to calculate distance between two lat/lon points
            getDistance: (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; // Earth's radius in metres
                const φ1 = lat1 * Math.PI/180; const φ2 = lat2 * Math.PI/180;
                const Δφ = (lat2-lat1) * Math.PI/180; const Δλ = (lon2-lon1) * Math.PI/180;
                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c; // Distance in metres
            },

            // --- NEW FUNCTION FOR SALARY SAVING PROGRAM (STEP 1) ---
            // This function transactionally processes a savings contribution to ensure data integrity.
            // It updates the employee's total balance and creates an audit log entry simultaneously.
            manageSavingsContribution: async (db, employeeId, employeeName, amount, payrollId) => {
                const { doc, collection, serverTimestamp, runTransaction } = window.firebaseSDK;
                /* * Data Model for `employeeSavings` collection:
                 * A single document per employee, identified by their employeeId.
                 * { 
                 * employeeId: string, 
                 * employeeName: string, 
                 * currentBalance: number, 
                 * lastUpdated: timestamp 
                 * }
                 */
                const savingsRef = doc(db, 'employeeSavings', employeeId);

                /*
                 * Data Model for `savingsTransactions` collection:
                 * A new document is created for every single savings event.
                 * { 
                 * employeeId: string, 
                 * date: timestamp, 
                 * amountDeducted: number, 
                 * type: 'contribution' | 'withdrawal', // 'withdrawal' for future use
                 * payrollId: string // Links back to the specific payroll run
                 * }
                 */
                const transactionRef = doc(collection(db, 'savingsTransactions'));

                try {
                    // Use a transaction to ensure both writes succeed or neither does.
                    await runTransaction(db, async (transaction) => {
                        const savingsDoc = await transaction.get(savingsRef);
                        let newBalance = amount;

                        // If the employee already has a savings document, add to their balance.
                        if (savingsDoc.exists()) {
                            newBalance = savingsDoc.data().currentBalance + amount;
                        }

                        // Operation 1: Update (or Set) the employee's total savings balance.
                        transaction.set(savingsRef, { 
                            currentBalance: newBalance, 
                            employeeId: employeeId,
                            employeeName: employeeName,
                            lastUpdated: serverTimestamp() 
                        }, { merge: true });

                        // Operation 2: Create a new transaction log for this specific contribution.
                        transaction.set(transactionRef, {
                            employeeId: employeeId,
                            date: serverTimestamp(),
                            amountDeducted: amount,
                            type: 'contribution',
                            payrollId: payrollId
                        });
                    });
                    console.log(`Savings contribution of ${amount} for ${employeeName} processed successfully.`);
                    return { success: true };
                } catch (error) {
                    console.error("Error within manageSavingsContribution transaction: ", error);
                    return { success: false, error: error };
                }
            },
            // --- NEW FUNCTION FOR SALARY SAVING PROGRAM (STEP 2: Payback) ---
            // This function transactionally processes a savings withdrawal.
            manageSavingsWithdrawal: async (db, employeeId, amount, note) => {
                const { doc, collection, serverTimestamp, runTransaction } = window.firebaseSDK;
                const savingsRef = doc(db, 'employeeSavings', employeeId);
                const transactionRef = doc(collection(db, 'savingsTransactions'));
        
                try {
                    await runTransaction(db, async (transaction) => {
                        const savingsDoc = await transaction.get(savingsRef);
        
                        if (!savingsDoc.exists()) {
                            throw new Error("Employee has no savings record to withdraw from.");
                        }
        
                        const currentBalance = savingsDoc.data().currentBalance || 0;
                        if (amount > currentBalance) {
                            throw new Error("Withdrawal amount cannot exceed the current balance.");
                        }
        
                        const newBalance = currentBalance - amount;
        
                        // Operation 1: Update the employee's total savings balance.
                        transaction.update(savingsRef, { 
                            currentBalance: newBalance, 
                            lastUpdated: serverTimestamp() 
                        });
        
                        // Operation 2: Create a new transaction log for this withdrawal.
                        transaction.set(transactionRef, {
                            employeeId: employeeId,
                            date: serverTimestamp(),
                            amountWithdrawn: amount,
                            type: 'withdrawal',
                            note: note || 'Manual payback'
                        });
                    });
                    console.log(`Savings withdrawal of ${amount} for ${employeeId} processed successfully.`);
                    return { success: true };
                } catch (error) {
                    console.error("Error within manageSavingsWithdrawal transaction: ", error);
                    return { success: false, error: error };
                }
            },
        };
        // --- END UTILITY FUNCTIONS ---

        // --- START REUSABLE UI COMPONENTS ---
        const Card = memo(({ children, className = '' }) => (<div className={`bg-slate-800/50 p-4 sm:p-6 rounded-lg shadow-lg border border-slate-700 ${className}`}>{children}</div>));
        const CardTitle = memo(({ children }) => (<h2 className="text-2xl font-semibold text-slate-100 mb-4 pb-4 border-b border-slate-700">{children}</h2>));
        const UnderConstructionPage = memo(({ title }) => (<Card><div className="text-center p-4 sm:p-8"><i className="fas fa-tools text-5xl text-yellow-400 mb-6"></i><h3 className="text-2xl sm:text-3xl font-bold text-slate-100">{title}</h3><p className="text-slate-400 mt-2">This page is under construction.</p></div></Card>));
        const Modal = ({ isOpen, onClose, children, maxWidth = "max-w-4xl" }) => { if (!isOpen) return null; return (<div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4 overflow-y-auto"><div className={`bg-slate-800 rounded-lg shadow-2xl w-full ${maxWidth} flex flex-col border border-slate-600`}>{children}</div></div>); };
        const ModalHeader = memo(({ title, onClose }) => (<div className="p-5 border-b border-slate-700 flex justify-between items-center flex-shrink-0"><h3 className="text-xl font-semibold text-slate-100">{title}</h3><Button variant="icon-close" onClick={onClose} className="text-2xl p-1">&times;</Button></div>));
        const ModalBody = memo(({ children }) => (<div className="p-6 flex-grow overflow-y-auto max-h-[calc(90vh-140px)]">{children}</div>));
        const ModalFooter = memo(({ children }) => (<div className="p-4 bg-slate-900/50 border-t border-slate-700 flex justify-end gap-4 rounded-b-lg flex-shrink-0">{children}</div>));
        
        // NEW: Reusable Button Component
        const Button = memo(({ children, onClick, variant = 'primary', icon, disabled = false, type = 'button', className = '', title = '' }) => {
            const baseClasses = 'font-medium rounded-lg shadow-sm transition-colors flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800';
            
            const variantStyles = {
                primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 px-4 py-2',
                secondary: 'bg-slate-600 text-slate-200 hover:bg-slate-500 focus:ring-slate-400 px-4 py-2',
                danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 px-4 py-2',
                success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500 px-4 py-2',
                'icon-edit': 'text-blue-400 hover:text-blue-300',
                'icon-delete': 'text-red-500 hover:text-red-400',
                'icon-approve': 'text-green-400 hover:text-green-300',
                'icon-reject': 'text-orange-400 hover:text-orange-300',
                'icon-view': 'text-blue-400 hover:text-blue-300',
                'icon-edit-alt': 'text-indigo-400 hover:text-indigo-300',
                'icon-close': 'text-slate-400 hover:text-white',
                'icon-add-time': 'text-teal-400 hover:text-teal-300', // New variant for the manual check-out icon
            };

            const finalClasses = `${baseClasses} ${variantStyles[variant] || variantStyles.primary} ${className}`;

            return (
                <button type={type} onClick={onClick} disabled={disabled} className={finalClasses} title={title}>
                    {icon && <i className={`fas ${icon}`}></i>}
                    {children}
                </button>
            );
        });

        const ConfirmationModal = ({ isOpen, onClose, onConfirm, title, message }) => { if (!isOpen) return null; return (<div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4"><div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-sm border border-slate-600"><div className="p-6"><h3 className="text-lg font-bold text-slate-100">{title}</h3><p className="mt-2 text-sm text-slate-400">{message}</p></div><div className="p-4 bg-slate-900/50 border-t border-slate-700 flex justify-end gap-4 rounded-b-lg"><Button variant="secondary" onClick={onClose}>Cancel</Button><Button variant="danger" onClick={onConfirm}>Confirm</Button></div></div></div>); };
        const TabbedPage = memo(({ tabs, activeTab, setActiveTab, children }) => {
            const renderContent = () => React.Children.toArray(children).find(child => child.props.id === activeTab) || <UnderConstructionPage title={tabs[activeTab]} />;
            return (<div><div className="mb-6 overflow-x-auto"><nav className="flex space-x-2 sm:space-x-4" aria-label="Tabs">{Object.entries(tabs).map(([key, title]) => (<a href="#" key={key} onClick={(e) => { e.preventDefault(); setActiveTab(key); }} className={`whitespace-nowrap rounded-md px-3 py-2 text-sm font-medium transition-colors ${activeTab === key ? 'bg-blue-600 text-white shadow' : 'text-slate-400 hover:bg-slate-700/50 hover:text-slate-200'}`}>{title}</a>))}</nav></div>{renderContent()}</div>);
        });
        const NotificationBell = ({ pendingLeaves = [], pendingOTs = [], onNotificationClick }) => {
            const [isOpen, setIsOpen] = useState(false);
            const totalCount = pendingLeaves.length + pendingOTs.length;

            const handleLeaveClick = () => {
                onNotificationClick('leaveRequest');
                setIsOpen(false);
            };

            const handleOTClick = () => {
                onNotificationClick('otRequest');
                setIsOpen(false);
            };

            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="relative text-slate-400 hover:text-white focus:outline-none">
                        <i className="fas fa-bell text-xl"></i>
                        {totalCount > 0 && (
                            <span className="absolute -top-2 -right-2 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-bold text-white">
                                {totalCount}
                            </span>
                        )}
                    </button>
                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-80 origin-top-right rounded-md bg-slate-800 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-slate-700">
                            <div className="py-1">
                                <div className="px-4 py-2 text-sm font-semibold text-slate-100 border-b border-slate-700">Notifications</div>
                                {totalCount === 0 ? (
                                    <div className="px-4 py-3 text-sm text-slate-400">No new notifications</div>
                                ) : (
                                    <>
                                        {pendingLeaves.map(req => (
                                            <a href="#" key={req.id} onClick={handleLeaveClick} className="block px-4 py-3 text-sm text-slate-300 hover:bg-slate-700">
                                                <p className="font-medium text-slate-200">New Leave Request</p>
                                                <p className="text-xs text-slate-400">{req.staffName} - {req.numberOfDays} day(s)</p>
                                            </a>
                                        ))}
                                        {pendingOTs.map(req => (
                                            <a href="#" key={req.id} onClick={handleOTClick} className="block px-4 py-3 text-sm text-slate-300 hover:bg-slate-700">
                                                <p className="font-medium text-slate-200">New OT Request</p>
                                                <p className="text-xs text-slate-400">{req.numberOfOTDays} day(s)</p>
                                            </a>
                                        ))}
                                    </>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        // --- END REUSABLE UI COMPONENTS ---

        // --- START AUTHENTICATION PAGE ---
        const LoginPage = () => {
            const { auth, db } = useFirebase();
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [showPassword, setShowPassword] = useState(false);

            const handleLogin = useCallback(async (e) => {
                e.preventDefault();
                if (!auth || !db) { setError("System not ready. Please try again."); return; }
                setLoading(true);
                setError('');
                try {
                    const { signInWithEmailAndPassword, signOut, collection, query, where, getDocs, doc, updateDoc } = window.firebaseSDK;
                    const userCredential = await signInWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    
                    // Verify user has an active employee profile by email
                    const q = query(collection(db, "employees"), where("email", "==", user.email));
                    const querySnapshot = await getDocs(q);

                    if (querySnapshot.empty) {
                        await signOut(auth);
                        setError("No employee record found for this user.");
                    } else {
                        const employeeDoc = querySnapshot.docs[0];
                        const employeeData = employeeDoc.data();

                        if (employeeData.status !== 'Active') {
                            await signOut(auth);
                            setError("Your account is inactive. Please contact HR.");
                        } else {
                            // Automatically link UID if it's missing or incorrect.
                            if (!employeeData.uid || employeeData.uid !== user.uid) {
                                const employeeDocRef = doc(db, 'employees', employeeDoc.id);
                                await updateDoc(employeeDocRef, { uid: user.uid });
                            }
                            // Login is successful; onAuthStateChanged will handle profile loading.
                        }
                    }
                } catch (err) {
                    setError('Failed to login. Please check your credentials.');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            }, [auth, db, email, password]);

            return (
                <div className="flex items-center justify-center min-h-screen bg-slate-900">
                    <div className="w-full max-w-md p-8 space-y-8 bg-slate-800 rounded-2xl shadow-lg border border-slate-700">
                        <div className="text-center"><i className="fas fa-building-user text-5xl text-blue-500"></i><h2 className="mt-6 text-3xl font-bold text-white">HR Management System</h2><p className="mt-2 text-sm text-slate-400">Sign in to your account</p></div>
                        <form className="mt-8 space-y-6" onSubmit={handleLogin}>
                            <div className="rounded-md shadow-sm -space-y-px">
                                <div><input id="email-address" name="email" type="email" autoComplete="email" required className="appearance-none rounded-none relative block w-full px-3 py-3 border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm" placeholder="Email address" value={email} onChange={(e) => setEmail(e.target.value)} /></div>
                                <div className="relative"><input id="password" name="password" type={showPassword ? "text" : "password"} autoComplete="current-password" required className="appearance-none rounded-none relative block w-full px-3 py-3 border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} /><button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute inset-y-0 right-0 pr-3 flex items-center text-sm leading-5"><i className={`fas ${showPassword ? 'fa-eye-slash' : 'fa-eye'} text-slate-400 hover:text-slate-200`}></i></button></div>
                            </div>
                            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                            <div>
                                <Button type="submit" variant="primary" disabled={loading} className="w-full py-3">
                                    {loading ? <i className="fas fa-spinner fa-spin"></i> : 'Sign in'}
                                </Button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };
        // --- END AUTHENTICATION PAGE ---

        // --- START EMPLOYEES PAGE COMPONENTS ---

        // NEW: Phase 2 Refactoring - Custom Hook for Employee Fetching Logic
        const useFilteredEmployees = (userProfile, selectedShop) => {
            const { db, auth } = useFirebase();
            const [employees, setEmployees] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!db || !userProfile || !auth?.currentUser) return () => {};
                
                const { collection, query, where, onSnapshot } = window.firebaseSDK;
                setLoading(true);
                let unsub1 = () => {};
                let unsub2 = () => {};

                const mergeResults = (res1, res2) => {
                    const combined = new Map();
                    res1.forEach(item => combined.set(item.id, item));
                    res2.forEach(item => combined.set(item.id, item));
                    setEmployees(Array.from(combined.values()));
                    setLoading(false);
                };

                const role = userProfile.role;
                
                if (role === 'Admin' || role === 'CEO') {
                    let results1 = [], results2 = [];
                    if (selectedShop) {
                        const q1 = query(collection(db, "employees"), where("shop", "==", selectedShop), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { results1 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Admin query 1 failed:", err));
                        const q2 = query(collection(db, "employees"), where("shop", "array-contains", selectedShop), where("status", "==", "Active"));
                        unsub2 = onSnapshot(q2, snap => { results2 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Admin query 2 failed:", err));
                    } else {
                        const q1 = query(collection(db, "employees"), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Admin all employees query failed:", err));
                    }
                } else if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (managedShops.length > 0) {
                        let results1 = [], results2 = [];
                        const q1 = query(collection(db, "employees"), where("shop", "in", managedShops), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { results1 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Manager query 1 failed:", err));
                        const q2 = query(collection(db, "employees"), where("shop", "array-contains-any", managedShops), where("status", "==", "Active"));
                        unsub2 = onSnapshot(q2, snap => { results2 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Manager query 2 failed:", err));
                    } else {
                        const q1 = query(collection(db, "employees"), where("uid", "==", userProfile.uid), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Manager self-query failed:", err));
                    }
                } else { // Staff role
                    const q1 = query(collection(db, "employees"), where("uid", "==", auth.currentUser.uid), where("status", "==", "Active"));
                    unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Staff query failed:", err));
                }

                return () => { unsub1(); unsub2(); };
            }, [db, userProfile, auth?.currentUser, selectedShop]);

            return { employees, loading };
        };

        // NEW: Phase 1 Refactoring - Employee Table Component
        // This component is now solely responsible for rendering the list of employees.
        // It receives the filtered list and action handlers as props.
        const EmployeeTable = memo(({ employees, userProfile, onView, onDelete }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Position</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Join Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Worked Dur.</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shift</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Tel</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Salary</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {employees.map(emp => (
                                <tr key={emp.id} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{emp.name}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.position}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.joinedDate}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.calculateWorkedDuration(emp.joinedDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.shift}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.tel}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 text-right whitespace-nowrap">{Utils.formatCurrency(emp.salary)}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            <Button variant="icon-view" icon="fa-eye" onClick={() => onView(emp)} />
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(emp)} />
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // Component: Employee Modal (Add/Edit Form)
        const EmployeeModal = ({ isOpen, onClose, onSave, employee, userProfile, isViewOnly = false, onSwitchToEdit }) => {
            const [formData, setFormData] = useState({});
            const [password, setPassword] = useState(''); // NEW: State for new user password
            const [showPassword, setShowPassword] = useState(false); // NEW: State for password visibility
            const [authError, setAuthError] = useState(''); // NEW: State for login creation errors
            
            // REFACTORED: Get global data from the AppDataProvider context.
            // This replaces multiple useCollection/useStaticCollection calls and removes the need for props.
            const { employees: allEmployees, shops, positions, shifts } = useAppData();

            // NEW: Filter the available shops in the dropdown based on the current user's role.
            const availableShopsForModal = useMemo(() => {
                if (!userProfile || !shops) {
                    return [];
                }
                // Admins and CEOs can assign new employees to any shop.
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return shops;
                }
                // Shop Managers can only assign new employees to the shops they manage.
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                // Other roles do not have permission to add employees, so return an empty list.
                return [];
            }, [userProfile, shops]);
            
            const supervisors = useMemo(() => (allEmployees || []).filter(e => e.role === 'Shop Manager' && e.status === 'Active'), [allEmployees]);

            const availablePages = useMemo(() => [
                { key: 'employees', label: 'Employees' },
                { key: 'checkinme', label: 'CheckInMe' },
                { key: 'savingProgram', label: 'Saving Program' },
                { key: 'attendanceReport', label: 'Attendance Report' },
                { key: 'loanManager', label: 'Loan Manager' },
                { key: 'payroll', label: 'Payroll' },
                { key: 'salaryReport', label: 'Salary Revise Report' },
                { key: 'expenseReport', label: 'Expense Report' },
                { key: 'userActivity', label: 'User Activity' },
                { key: 'policy', label: 'Policy Board' },
                { key: 'settings', label: 'Settings' },
            ], []);

            // Filter shifts based on the employee's assigned shop(s)
            const availableShifts = useMemo(() => {
                const employeeShops = Array.isArray(formData.shop) ? formData.shop : (formData.shop ? [formData.shop] : []);
                if (employeeShops.length === 0) return [];
                return (shifts || []).filter(s => s.shopName && employeeShops.includes(s.shopName));
            }, [shifts, formData.shop]);

            // Initialize form data when modal opens or employee data changes
            useEffect(() => {
                const initialData = employee 
                    ? { ...employee, permissions: employee.permissions || [] } 
                    : { name: '', sex: 'M', dob: '', nationId: '', tel: '', shop: '', joinedDate: '', salary: '', position: '', shift: 'AM', supervisor: '', status: 'Active', email: '', uid: '', role: 'Staff', address: '', permissions: [], statusChangeDate: '', reasonForLeaving: '', savingsProgramStatus: 'Inactive', savingsPercentage: 0 }; 

                // When editing, ensure shop is in the right format based on role
                if (employee) {
                    if (employee.role === 'Shop Manager' || employee.role === 'Admin') {
                        initialData.shop = Array.isArray(employee.shop) ? employee.shop : (employee.shop ? [employee.shop] : []);
                    } else {
                        initialData.shop = Array.isArray(employee.shop) ? employee.shop[0] || '' : employee.shop || '';
                    }
                } else {
                    // For new employee, default based on Staff role
                    initialData.shop = '';
                }

                setFormData(initialData);
                setPassword(''); // NEW: Reset password on open
                setAuthError(''); // NEW: Reset error on open
            }, [employee, isOpen]);
            
            // Automatically grant 'checkinme' permission to Staff and Shop Manager roles
            useEffect(() => {
                if ((formData.role === 'Staff' || formData.role === 'Shop Manager') && !formData.permissions?.includes('checkinme')) {
                    setFormData(prev => ({ ...prev, permissions: [...new Set([...(prev.permissions || []), 'checkinme'])] }));
                }
            }, [formData.role]);

            const handleChange = useCallback((e) => {
                const { name, value, type, checked } = e.target;
                
                if (name === 'role') {
                    // When role changes, convert shop data structure accordingly
                    setFormData(prev => {
                        const newRole = value;
                        let newShopValue = prev.shop;
                        let newPermissions = prev.permissions || []; // Get current permissions

                        if (newRole === 'Shop Manager' || newRole === 'Admin' || newRole === 'CEO') {
                            // convert to array if it's a string
                            newShopValue = Array.isArray(prev.shop) ? prev.shop : (prev.shop ? [prev.shop] : []);
                        } else {
                            // convert to string (first element) if it's an array
                            newShopValue = Array.isArray(prev.shop) ? prev.shop[0] || '' : prev.shop;
                        }

                        // If role is changed to something other than Admin, remove the sysConfig permission.
                        
                        return { ...prev, role: newRole, shop: newShopValue, permissions: newPermissions };
                    });
                } else if (type === 'checkbox') {
                    if (name === 'shop') { // Handling shop multi-select
                        setFormData(prev => {
                            const shopArray = Array.isArray(prev.shop) ? prev.shop : [];
                            const newShops = checked ? [...shopArray, value] : shopArray.filter(s => s !== value);
                            return { ...prev, shop: newShops };
                        });
                    } else { // Handling permissions
                        setFormData(prev => ({ ...prev, permissions: checked ? [...(prev.permissions || []), value] : (prev.permissions || []).filter(p => p !== value) }));
                    }
                } else {
                    setFormData(prev => ({ ...prev, [name]: value }));
                }
            }, []);

            // Handlers for salary input to allow typing numbers and format on blur
            const handleSalaryChange = useCallback((e) => { setFormData(prev => ({ ...prev, salary: e.target.value.replace(/[^0-9.]/g, '') })); }, []);
            const handleSalaryBlur = useCallback((e) => { setFormData(prev => ({ ...prev, salary: Utils.formatCurrency(e.target.value) })); }, []);
            const handleSubmit = useCallback(async (e) => { 
                e.preventDefault(); 
                setAuthError(''); // Reset error on each submission attempt
                const dataToSave = { ...formData };
                // Final check to ensure staff have a string for shop, not array
                if (dataToSave.role !== 'Shop Manager' && dataToSave.role !== 'Admin' && dataToSave.role !== 'CEO') {
                    dataToSave.shop = Array.isArray(dataToSave.shop) ? dataToSave.shop[0] || '' : dataToSave.shop;
                }

                // --- MODIFIED: Handle user credential creation without changing global auth state ---
                if (!dataToSave.id && dataToSave.email && password) { // This is a new employee with login details
                    if (password.length < 6) {
                        setAuthError('Password must be at least 6 characters long.');
                        return; // Stop the save process
                    }
                    let tempApp = null;
                    try {
                        const { initializeApp, getAuth, createUserWithEmailAndPassword, deleteApp } = window.firebaseSDK;
                        // Initialize a temporary, secondary Firebase app to create the user.
                        // This prevents the main app's auth state from changing.
                        const tempAppName = `temp-user-creation-${Date.now()}`;
                        tempApp = initializeApp(activeFirebaseConfig, tempAppName);
                        const tempAuth = getAuth(tempApp);

                        // Create the user on the temporary instance.
                        const userCredential = await createUserWithEmailAndPassword(tempAuth, dataToSave.email, password);
                        // Add the new UID to the employee data object that will be saved to Firestore
                        dataToSave.uid = userCredential.user.uid;
                        
                    } catch (error) {
                        console.error("Error creating auth user:", error);
                        if (error.code === 'auth/email-already-in-use') {
                            setAuthError('This email is already in use by another login.');
                        } else {
                            setAuthError('Failed to create user login. Please check the email format.');
                        }
                        return; // Stop the save process if auth creation fails
                    } finally {
                        // Clean up the temporary app instance.
                        if (tempApp) {
                            await window.firebaseSDK.deleteApp(tempApp);
                        }
                    }
                } else if (!dataToSave.id && dataToSave.email && !password) {
                    setAuthError('Password is required when creating a new user with an email address.');
                    return; // Stop the save process
                }
                // --- End modified logic ---

                onSave(dataToSave); 
            }, [onSave, formData, password]);
            const isFormerEmployee = formData.status === 'Terminated' || formData.status === 'Resigned';

            return (
                <Modal isOpen={isOpen} onClose={onClose}>
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={isViewOnly ? 'View Employee Details' : (employee ? 'Edit Employee' : 'Add New Employee')} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {/* Employee Personal & Job Details */}
                                <div><label className="text-sm font-medium text-slate-400">Name</label><input name="name" value={formData.name || ''} onChange={handleChange} className="input" required disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Sex</label><select name="sex" value={formData.sex || 'M'} onChange={handleChange} className="select" disabled={isViewOnly}><option value="M">Male</option><option value="F">Female</option></select></div>
                                <div><label className="text-sm font-medium text-slate-400">Date of Birth</label><input type="date" name="dob" value={formData.dob || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Nation ID</label><input name="nationId" value={formData.nationId || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Tel No</label><input name="tel" value={formData.tel || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                
                                {(formData.role === 'Shop Manager' || formData.role === 'Admin' || formData.role === 'CEO') ? (
                                    <div className="md:col-span-full">
                                        <label className="text-sm font-medium text-slate-400">Shops</label>
                                        <div className="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-4 p-4 border border-slate-600 rounded-lg bg-slate-700/50">
                                            {(availableShopsForModal || []).map(shop => (
                                                <div key={shop.id} className="flex items-center">
                                                    <input id={`shop-${shop.id}`} name="shop" type="checkbox" value={shop.name} checked={(Array.isArray(formData.shop) ? formData.shop : []).includes(shop.name)} onChange={handleChange} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600" disabled={isViewOnly} />
                                                    <label htmlFor={`shop-${shop.id}`} className="ml-3 text-sm text-slate-300">{shop.name}</label>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ) : (
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Shop</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={isViewOnly}>
                                            <option value="">Select Shop</option>
                                            {(availableShopsForModal || []).map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                        </select>
                                    </div>
                                )}

                                <div><label className="text-sm font-medium text-slate-400">Joined Date</label><input type="date" name="joinedDate" value={formData.joinedDate || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Salary</label><input name="salary" value={formData.salary || ''} onChange={handleSalaryChange} onBlur={handleSalaryBlur} className="input" disabled={isViewOnly || (userProfile?.role === 'Shop Manager' && employee)} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Position</label><select name="position" value={formData.position || ''} onChange={handleChange} className="select" disabled={isViewOnly}><option value="">Select Position</option>{(positions || []).map(p => <option key={p.id} value={p.position}>{p.position}</option>)}</select></div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Shift</label>
                                    <select name="shift" value={formData.shift || ''} onChange={handleChange} className="select" disabled={isViewOnly}>
                                        <option value="">Select Shift</option>
                                        {availableShifts.map(s => <option key={s.id} value={s.name}>{s.name} ({s.shopName})</option>)}
                                    </select>
                                </div>
                                <div><label className="text-sm font-medium text-slate-400">Supervisor</label><select name="supervisor" value={formData.supervisor || ''} onChange={handleChange} className="select" disabled={isViewOnly}><option value="">Select Supervisor</option>{supervisors.map(e => <option key={e.id} value={e.name}>{e.name}</option>)}</select></div>
                                <div><label className="text-sm font-medium text-slate-400">Staff Status</label><select name="status" value={formData.status || 'Active'} onChange={handleChange} className="select" disabled={isViewOnly}><option>Active</option><option>Terminated</option><option>Resigned</option></select></div>
                                {isFormerEmployee && (
                                    <>
                                        <div><label className="text-sm font-medium text-slate-400">Status Change Date</label><input type="date" name="statusChangeDate" value={formData.statusChangeDate || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                        <div className="md:col-span-2"><label className="text-sm font-medium text-slate-400">Reason for Leaving</label><textarea name="reasonForLeaving" value={formData.reasonForLeaving || ''} onChange={handleChange} className="input" rows="2" disabled={isViewOnly}></textarea></div>
                                    </>
                                )}
                                <div className="md:col-span-full"><hr className="border-slate-700 my-2"/></div>
                                {/* System & Permissions */}
                                <div><label className="text-sm font-medium text-slate-400">Email</label><input type="email" name="email" value={formData.email || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                
                                {/* NEW: Password field for new employee creation */}
                                {!employee && (
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Password (for new user login)</label>
                                        <div className="relative">
                                            <input
                                                type={showPassword ? "text" : "password"}
                                                value={password}
                                                onChange={(e) => setPassword(e.target.value)}
                                                className="input"
                                                placeholder="Min. 6 characters"
                                                disabled={isViewOnly}
                                            />
                                            <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute inset-y-0 right-0 pr-3 flex items-center text-sm leading-5">
                                                <i className={`fas ${showPassword ? 'fa-eye-slash' : 'fa-eye'} text-slate-400 hover:text-slate-200`}></i>
                                            </button>
                                        </div>
                                    </div>
                                )}
                                
                                <div><label className="text-sm font-medium text-slate-400">Role</label><select name="role" value={formData.role || 'Staff'} onChange={handleChange} className="select" disabled={isViewOnly || userProfile?.role === 'Shop Manager'}><option>Admin</option><option>CEO</option><option>Shop Manager</option><option>Staff</option></select></div>
                                <div className="md:col-span-2 lg:col-span-3"><label className="text-sm font-medium text-slate-400">Address</label><textarea name="address" value={formData.address || ''} onChange={handleChange} className="input" rows="3" disabled={isViewOnly}></textarea></div>

                                {/* --- REMOVED: Salary Saving Program Section from this modal --- */}

                                <div className="md:col-span-2 lg:col-span-3">
                                    <label className="text-sm font-medium text-slate-400">Page Permissions</label>
                                    <div className="mt-2 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 p-4 border border-slate-600 rounded-lg bg-slate-700/50">
                                        {availablePages.map(page => {
                                            // A Shop Manager cannot grant permissions for these specific pages.
                                            const isRestrictedForManager = userProfile?.role === 'Shop Manager' && ['expenseReport', 'userActivity', 'settings'].includes(page.key);
                                            
                                            // The checkbox is only disabled if the modal is view-only or if a Shop Manager is viewing a restricted permission.
                                            const isDisabled = isViewOnly || isRestrictedForManager;

                                            return (
                                                <div key={page.key} className="flex items-center">
                                                    <input id={`perm-${page.key}`} type="checkbox" value={page.key} checked={formData.permissions?.includes(page.key)} onChange={handleChange} disabled={isDisabled} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600" />
                                                    <label htmlFor={`perm-${page.key}`} className={`ml-3 text-sm ${isDisabled ? 'text-slate-500' : 'text-slate-300'}`}>{page.label}</label>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                {/* NEW: Display auth errors here */}
                                {authError && <p className="text-red-400 text-sm md:col-span-full">{authError}</p>}
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            {isViewOnly ? (
                                <>
                                    <Button type="button" variant="secondary" onClick={onClose}>Close</Button>
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                        <Button type="button" variant="primary" icon="fa-edit" onClick={(e) => { e.preventDefault(); onSwitchToEdit(); }}>Edit</Button>
                                    )}
                                </>
                            ) : (
                                <>
                                    <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                                    <Button type="submit" variant="primary" className="px-6">Save</Button>
                                </>
                            )}
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // NEW: ActiveEmployeesTab component to fix the reference error.
        const ActiveEmployeesTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isViewOnly, setIsViewOnly] = useState(false);
            const [editingEmployee, setEditingEmployee] = useState(null);
            const [employeeToDelete, setEmployeeToDelete] = useState(null);
            
            // REFACTORED: Get global shops data from the App Data context provider.
            const { shops } = useAppData();
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState(''); // NEW: State for the search term

            // Set the initial shop filter based on the user's role and assigned shop(s).
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    // Managers with multiple shops default to 'All My Shops' (empty string).
                    // Single-shop users default to their assigned shop.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Use the custom hook to fetch and filter employees based on the selected shop.
            const { employees, loading } = useFilteredEmployees(userProfile, selectedShop);

            // NEW: Further filter the employees based on the search term.
            const searchedEmployees = useMemo(() => {
                if (!searchTerm) {
                    return employees;
                }
                return employees.filter(emp => 
                    emp.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }, [employees, searchTerm]);
            
            // NEW: Function to handle exporting the current employee list to an Excel file.
            const handleExportExcel = useCallback(() => {
                // Format the data to have more readable headers and select specific fields.
                const dataToExport = searchedEmployees.map(emp => ({ 
                    'Name': emp.name,
                    'Email': emp.email,
                    'Position': emp.position,
                    'Shop': Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop,
                    'Join Date': emp.joinedDate,
                    'Worked Duration': Utils.calculateWorkedDuration(emp.joinedDate),
                    'Shift': emp.shift,
                    'Telephone': emp.tel,
                    'Salary (KHR)': parseFloat(String(emp.salary).replace(/[^0-9.-]/g, '')) || 0
                }));

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Active Employees");
                
                // Set column widths for better readability
                worksheet["!cols"] = [ 
                    { wch: 25 }, // Name
                    { wch: 30 }, // Email
                    { wch: 20 }, // Position
                    { wch: 20 }, // Shop
                    { wch: 15 }, // Join Date
                    { wch: 18 }, // Worked Duration
                    { wch: 10 }, // Shift
                    { wch: 15 }, // Telephone
                    { wch: 18 }  // Salary
                ];
                
                XLSX.writeFile(workbook, "Active_Employees_Report.xlsx");
            }, [searchedEmployees]); // Dependency on the filtered list ensures the correct data is exported.
            
            // Determine which shops are available for filtering in the dropdown.
            const availableShopsForFilter = useMemo(() => {
                if (!userProfile || !shops) {
                    return [];
                }
                // Admins and CEOs can filter by any shop.
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return shops;
                }
                // Shop Managers with multiple assigned shops can filter by those shops.
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    // Map the array of shop names to an array of shop objects for the dropdown.
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                // Other roles (or managers with a single shop) do not see the filter dropdown.
                return [];
            }, [userProfile, shops]);
            
            const handleOpenModal = (employee = null, viewOnly = false) => {
                setEditingEmployee(employee);
                setIsViewOnly(viewOnly);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setEditingEmployee(null);
                setIsModalOpen(false);
            };

            // Handler for saving a new or edited employee.
            const handleSaveEmployee = async (formData) => {
                const { addDoc, updateDoc, doc, collection } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                
                try {
                    if (id) {
                        await updateDoc(doc(db, 'employees', id), dataToSave);
                    } else {
                        await addDoc(collection(db, 'employees'), dataToSave);
                    }
                    handleCloseModal();
                } catch (error) {
                    console.error("Error saving employee:", error);
                }
            };
            
            const handleDeleteEmployee = (employee) => {
                setEmployeeToDelete(employee);
            };

            const confirmDelete = async () => {
                if (!employeeToDelete) return;
                const { doc, updateDoc } = window.firebaseSDK;
                try {
                    const employeeRef = doc(db, 'employees', employeeToDelete.id);
                    // Instead of deleting, we change the status to 'Terminated'.
                    await updateDoc(employeeRef, { status: 'Terminated', statusChangeDate: new Date().toISOString().substring(0, 10), reasonForLeaving: 'Deleted from active list' });
                } catch (error) {
                    console.error("Error 'deleting' (terminating) employee:", error);
                } finally {
                    setEmployeeToDelete(null);
                }
            };

            // Render logic for the Active Employees tab.
            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        {/* MODIFIED: The title now includes the total count of displayed employees. */}
                        <h3 className="text-xl font-semibold text-slate-100">
                            Active Employee List - {searchedEmployees.length}
                        </h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            {/* NEW: Search input field added */}
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            {/* NEW: Excel export button added. */}
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel} disabled={loading}>
                                Excel
                            </Button>
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Employee</Button>
                            )}
                        </div>
                    </div>

                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div>
                    ) : (
                        <EmployeeTable
                            employees={searchedEmployees}
                            userProfile={userProfile}
                            onView={(emp) => handleOpenModal(emp, true)}
                            onDelete={handleDeleteEmployee}
                        />
                    )}

                    <EmployeeModal
                        isOpen={isModalOpen}
                        onClose={handleCloseModal}
                        onSave={handleSaveEmployee}
                        employee={editingEmployee}
                        userProfile={userProfile}
                        isViewOnly={isViewOnly}
                        onSwitchToEdit={() => setIsViewOnly(false)}
                    />

                    <ConfirmationModal
                        isOpen={!!employeeToDelete}
                        onClose={() => setEmployeeToDelete(null)}
                        onConfirm={confirmDelete}
                        title="Confirm Deletion"
                        message={`Are you sure you want to remove ${employeeToDelete?.name}? Their status will be set to 'Terminated'.`}
                    />
                </Card>
            );
        };

        // NEW: Modal for adding/editing salary revisions
        const SalaryRevisionModal = ({ isOpen, onClose, onSave, revision, userProfile }) => {
            // Get global data from context
            const { shops, employees } = useAppData();
            const [formData, setFormData] = useState({});

            // Memoized lists for dropdowns
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!formData.shopName) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shopName) && emp.status === 'Active';
                });
            }, [formData.shopName, employees]);

            // Initialize form
            useEffect(() => {
                const initialData = revision 
                    ? { ...revision }
                    : {
                        reqDate: new Date().toISOString().substring(0, 10),
                        effectiveDate: new Date().toISOString().substring(0, 10),
                        shopName: '',
                        staffId: '',
                        reviseAmount: '',
                        baseSalary: 0,
                        updatedSalary: 0,
                        status: 'Pending'
                    };
                setFormData(initialData);
            }, [revision, isOpen]);
            
            // REMOVED: The two separate useEffect hooks for salary calculation have been removed.

            // REVISED: Consolidated all salary calculation logic into a single, more robust handleChange function.
            // This prevents race conditions and ensures data consistency when the form is updated.
            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                
                setFormData(prev => {
                    const newFormData = { ...prev, [name]: value };

                    // When the shop selection changes...
                    if (name === 'shopName') {
                        // ...reset all employee-specific fields.
                        newFormData.staffId = '';
                        newFormData.staffName = '';
                        newFormData.baseSalary = 0;
                        newFormData.reviseAmount = '';
                        newFormData.updatedSalary = 0;
                    }

                    // When the staff selection changes...
                    if (name === 'staffId') {
                        const selectedEmployee = employees.find(emp => emp.id === value);
                        if (selectedEmployee) {
                            // ...update the staff name and recalculate salaries from scratch.
                            newFormData.staffName = selectedEmployee.name;
                            const currentSalary = parseFloat(String(selectedEmployee.salary).replace(/[^0-9.-]/g, '')) || 0;
                            const revisedAmount = parseFloat(newFormData.reviseAmount) || 0;
                            newFormData.baseSalary = currentSalary;
                            newFormData.updatedSalary = currentSalary + revisedAmount;
                        } else {
                            // ...or reset if the staff is deselected.
                            newFormData.staffName = '';
                            newFormData.baseSalary = 0;
                            newFormData.updatedSalary = parseFloat(newFormData.reviseAmount) || 0;
                        }
                    }

                    // When only the revision amount changes...
                    if (name === 'reviseAmount') {
                        // ...recalculate just the final salary.
                        const base = parseFloat(newFormData.baseSalary) || 0;
                        const revise = parseFloat(value) || 0;
                        newFormData.updatedSalary = base + revise;
                    }

                    return newFormData;
                });
            }, [employees]); // Dependency on employees is needed to find staff details.
            
            const handleSubmit = (e) => {
                e.preventDefault();
                onSave(formData);
            };
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-3xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={revision ? "Edit Salary Revision" : "Add New Salary Revision"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div><label className="text-sm">Request Date</label><input type="date" name="reqDate" value={formData.reqDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Effective Date</label><input type="date" name="effectiveDate" value={formData.effectiveDate || ''} onChange={handleChange} className="input" required /></div>
                                
                                <div>
                                    <label className="text-sm">Shop Name</label>
                                    <select name="shopName" value={formData.shopName || ''} onChange={handleChange} className="select" required>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                    </select>
                                </div>
                                
                                <div>
                                    <label className="text-sm">Staff Name</label>
                                    <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shopName}>
                                        <option value="">Select Staff</option>
                                        {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                    </select>
                                </div>

                                <div><label className="text-sm">Base Salary</label><input value={Utils.formatCurrency(formData.baseSalary)} className="input" disabled /></div>
                                <div><label className="text-sm">Revise Amount</label><input type="number" name="reviseAmount" value={formData.reviseAmount || ''} onChange={handleChange} className="input" required /></div>

                                <div className="md:col-span-2">
                                   <label className="text-sm">Updated Salary</label>
                                   <input value={Utils.formatCurrency(formData.updatedSalary)} className="input" disabled />
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Submit Revision</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // Component: Salary Revise Report Tab
        const SalaryReviseReportTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { where } = window.firebaseSDK;
            const { shops } = useAppData();
            
            // State for modal and filters
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingRevision, setEditingRevision] = useState(null);
            const [revisionToDelete, setRevisionToDelete] = useState(null);
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));

            // Data fetching
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shopName", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return managedShops.length > 0 ? [where("shopName", "in", managedShops)] : [where("shopName", "==", "null")];
                }
                return [where("staffId", "==", userProfile.id || null)];
            }, [userProfile]);
            
            const { data: revisions, loading } = useCollection('salaryRevisions', queryConstraints);
            
            const filteredRevisions = useMemo(() => {
                return revisions
                    .filter(rev => 
                        (!selectedShop || rev.shopName === selectedShop) &&
                        (!selectedMonth || (rev.effectiveDate && rev.effectiveDate.startsWith(selectedMonth)))
                    )
                    .sort((a,b) => (b.reqDate || '').localeCompare(a.reqDate || ''));
            }, [revisions, selectedShop, selectedMonth]);

            // Handlers
            const handleOpenModal = (revision = null) => { setEditingRevision(revision); setIsModalOpen(true); };
            const handleCloseModal = () => { setEditingRevision(null); setIsModalOpen(false); };
            
            const handleSaveRevision = async (formData) => {
                const { addDoc, updateDoc, doc, collection, serverTimestamp } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                
                try {
                    if (id) {
                        await updateDoc(doc(db, 'salaryRevisions', id), dataToSave);
                    } else {
                        await addDoc(collection(db, 'salaryRevisions'), { ...dataToSave, status: 'Pending', createdAt: serverTimestamp() });
                    }
                    handleCloseModal();
                } catch (error) { console.error("Error saving salary revision:", error); }
            };
            
            const handleUpdateStatus = async (revision, newStatus) => {
                const { updateDoc, doc } = window.firebaseSDK;
                try {
                    const revisionRef = doc(db, 'salaryRevisions', revision.id);
                    await updateDoc(revisionRef, { status: newStatus });
                    
                    // CRITICAL STEP: If approved, update the employee's main salary record.
                    // REMOVED: This line is removed to ensure historical payroll accuracy.
                    // The payroll calculator will now refer to the revision history instead.
                    /*
                    if (newStatus === 'Approved') {
                        const employeeRef = doc(db, 'employees', revision.staffId);
                        await updateDoc(employeeRef, { salary: revision.updatedSalary });
                    }
                    */
                } catch (error) { console.error("Error updating revision status:", error); }
            };
            
            const handleDeleteConfirm = async () => {
                if (!revisionToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'salaryRevisions', revisionToDelete.id));
                } catch (error) { console.error("Error deleting revision:", error); }
                finally { setRevisionToDelete(null); }
            };

            const canManage = userProfile?.role === 'Admin' || userProfile?.role === 'CEO';
            
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Salary Revision Management</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Shops</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                            {canManage && <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Revision</Button>}
                        </div>
                    </div>
                    {loading ? <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div> : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Req Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Effective Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Base Salary</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Revise Amount</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Updated Salary</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold uppercase">Status</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {filteredRevisions.map(rev => (
                                    <tr key={rev.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm">{Utils.formatISOToDisplay(rev.reqDate)}</td>
                                        <td className="px-4 py-4 text-sm">{Utils.formatISOToDisplay(rev.effectiveDate)}</td>
                                        <td className="px-4 py-4 text-sm">{rev.shopName}</td>
                                        <td className="px-4 py-4 text-sm">{rev.staffName}</td>
                                        <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(rev.baseSalary)}</td>
                                        <td className={`px-4 py-4 text-sm text-right font-semibold ${rev.reviseAmount >= 0 ? 'text-green-400' : 'text-red-400'}`}>{Utils.formatCurrency(rev.reviseAmount)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(rev.updatedSalary)}</td>
                                        <td className="px-4 py-4 text-center text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${ rev.status === 'Approved' ? 'bg-green-100 text-green-800' : rev.status === 'Rejected' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800' }`}>
                                                {rev.status}
                                            </span>
                                        </td>
                                        <td className="px-4 py-4 text-center whitespace-nowrap">
                                            <div className="flex items-center justify-center gap-2">
                                                {canManage && rev.status === 'Pending' && (
                                                    <>
                                                        <Button variant="icon-approve" icon="fa-check-circle" onClick={() => handleUpdateStatus(rev, 'Approved')} title="Approve" />
                                                        <Button variant="icon-reject" icon="fa-times-circle" onClick={() => handleUpdateStatus(rev, 'Rejected')} title="Reject" />
                                                    </>
                                                )}
                                                {canManage && (
                                                    <>
                                                        <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(rev)} title="Edit" />
                                                        <Button variant="icon-delete" icon="fa-trash" onClick={() => setRevisionToDelete(rev)} title="Delete" />
                                                    </>
                                                )}
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    )}
                    <SalaryRevisionModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSaveRevision} revision={editingRevision} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!revisionToDelete} onClose={() => setRevisionToDelete(null)} onConfirm={handleDeleteConfirm} title="Delete Revision" message="Are you sure you want to delete this salary revision record?" />
                </Card>
            );
        };
        
        // NEW: Table component specifically for displaying former employees.
        const FormerEmployeeTable = memo(({ employees, userProfile, onEdit, onDelete }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Worked Dur.</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Status</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Reason</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {employees.map(emp => (
                                <tr key={emp.id} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatISOToDisplay(emp.statusChangeDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{emp.name}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.calculateWorkedDuration(emp.joinedDate, emp.statusChangeDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.status}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-pre-wrap max-w-xs truncate" title={emp.reasonForLeaving}>{emp.reasonForLeaving}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                                <Button variant="icon-edit" icon="fa-edit" onClick={() => onEdit(emp)} title="Edit Record"/>
                                            )}
                                            {/* Permanent delete is restricted to Admin/CEO for data integrity */}
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(emp)} title="Permanently Delete"/>
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // REPLACED: This component now provides the requested report table for former employees.
        const FormerEmployeesTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingEmployee, setEditingEmployee] = useState(null);
            const [employeeToDelete, setEmployeeToDelete] = useState(null);
            
            // Get global shops data from context for the filter dropdown.
            const { shops } = useAppData();
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState('');

            // Set initial shop filter based on user's role.
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Custom hook to fetch former employees based on user role and selected shop.
            const useFormerEmployees = (userProfile, selectedShop) => {
                const { db } = useFirebase();
                const [employees, setEmployees] = useState([]);
                const [loading, setLoading] = useState(true);

                useEffect(() => {
                    if (!db || !userProfile) return () => {};
                    
                    const { collection, query, where, onSnapshot } = window.firebaseSDK;
                    setLoading(true);
                    
                    const statusFilter = where("status", "in", ["Terminated", "Resigned"]);
                    let finalQuery;
                    
                    const baseQuery = query(collection(db, "employees"), statusFilter);
                    const role = userProfile.role;

                    if (role === 'Admin' || role === 'CEO') {
                        finalQuery = selectedShop ? query(baseQuery, where("shop", "==", selectedShop)) : baseQuery;
                    } else if (role === 'Shop Manager') {
                        const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                        if (managedShops.length > 0) {
                            const shopsToQuery = selectedShop ? [selectedShop] : managedShops;
                            finalQuery = query(baseQuery, where("shop", "in", shopsToQuery));
                        } else {
                            setEmployees([]); setLoading(false); return; // Manager with no shops sees nothing
                        }
                    } else {
                        setEmployees([]); setLoading(false); return; // Staff role sees nothing
                    }

                    const unsub = onSnapshot(finalQuery, (snapshot) => {
                        setEmployees(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                        setLoading(false);
                    }, (error) => {
                        console.error("Error fetching former employees:", error);
                        setLoading(false);
                    });

                    return () => unsub();
                }, [db, userProfile, selectedShop]);

                return { employees, loading };
            };

            const { employees, loading } = useFormerEmployees(userProfile, selectedShop);

            // Further filter employees based on search term on the client side.
            const searchedEmployees = useMemo(() => {
                if (!searchTerm) return employees;
                return employees.filter(emp => 
                    emp.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }, [employees, searchTerm]);
            
            // Determine which shops are available for the filter dropdown.
            const availableShopsForFilter = useMemo(() => {
                if (!userProfile || !shops) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                return [];
            }, [userProfile, shops]);
            
            // Handlers for modal operations.
            const handleOpenModal = (employee) => {
                setEditingEmployee(employee);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setEditingEmployee(null);
                setIsModalOpen(false);
            };

            const handleSaveEmployee = async (formData) => {
                const { updateDoc, doc } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                try {
                    await updateDoc(doc(db, 'employees', id), dataToSave);
                    handleCloseModal();
                } catch (error) {
                    console.error("Error updating former employee:", error);
                }
            };
            
            // Handlers for deletion.
            const handleDeleteEmployee = (employee) => {
                setEmployeeToDelete(employee);
            };

            const confirmDelete = async () => {
                if (!employeeToDelete) return;
                const { doc, deleteDoc } = window.firebaseSDK;
                try {
                    // This is a permanent, hard delete from the database.
                    await deleteDoc(doc(db, 'employees', employeeToDelete.id));
                } catch (error) {
                    console.error("Error permanently deleting employee record:", error);
                } finally {
                    setEmployeeToDelete(null);
                }
            };

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Resigned/Terminated Employee List</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                        </div>
                    </div>

                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div>
                    ) : (
                        <FormerEmployeeTable 
                            employees={searchedEmployees}
                            userProfile={userProfile}
                            onEdit={handleOpenModal}
                            onDelete={handleDeleteEmployee}
                        />
                    )}

                    <EmployeeModal
                        isOpen={isModalOpen}
                        onClose={handleCloseModal}
                        onSave={handleSaveEmployee}
                        employee={editingEmployee}
                        userProfile={userProfile}
                        isViewOnly={false} // Always open in edit mode for this tab
                        onSwitchToEdit={() => {}} // Not applicable here
                    />

                    <ConfirmationModal
                        isOpen={!!employeeToDelete}
                        onClose={() => setEmployeeToDelete(null)}
                        onConfirm={confirmDelete}
                        title="Confirm Permanent Deletion"
                        message={`Are you sure you want to PERMANENTLY delete the record for ${employeeToDelete?.name}? This action cannot be undone and will remove all their historical data.`}
                    />
                </Card>
            );
        };

        // Component: Main Employees Page (Tab Container)
        const EmployeesPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('active');
            return (
                <TabbedPage tabs={{ active: 'Active Employees', salaryReport: 'Salary Revise Report', former: 'Resigned/Terminated' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="active"><ActiveEmployeesTab userProfile={userProfile} /></div>
                    <div id="salaryReport"><SalaryReviseReportTab userProfile={userProfile} /></div>
                    <div id="former"><FormerEmployeesTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };
        // --- END EMPLOYEES PAGE COMPONENTS ---
        
        // --- START SAVINGS PROGRAM PAGE COMPONENTS (NEW) ---
        
        // NEW: Modal to Add/Edit Salary Saving Program Participants
        const AddSalarySavingModal = ({ isOpen, onClose, onSave, participant, userProfile, allEmployees }) => {
            const { shops } = useAppData();
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const [savingsPercentage, setSavingsPercentage] = useState(0);
            const [joinDate, setJoinDate] = useState('');
            const [effectiveMonth, setEffectiveMonth] = useState('');
        
            useEffect(() => {
                if (participant) {
                    // EDIT MODE
                    const participantShop = Array.isArray(participant.shop) ? participant.shop[0] : participant.shop;
                    setSelectedShop(participantShop || '');
                    setSelectedEmployeeId(participant.id);
                    setSavingsPercentage(participant.savingsPercentage || 0);
                    setJoinDate(participant.savingsJoinDate || '');
                    setEffectiveMonth(participant.savingsEffectiveMonth || '');
                } else {
                    // ADD MODE - Reset form
                    setSelectedShop('');
                    setSelectedEmployeeId('');
                    setSavingsPercentage(0);
                    const today = new Date().toISOString().slice(0, 10);
                    const currentMonth = new Date().toISOString().slice(0, 7);
                    setJoinDate(today);
                    setEffectiveMonth(currentMonth);
                }
            }, [participant, isOpen]);
        
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                return shops.filter(s => managedShops.includes(s.name));
            }, [shops, userProfile]);
            
            const availableEmployees = useMemo(() => {
                if (!selectedShop) return [];
                // In add mode, show active employees in the selected shop who are NOT already in the program.
                // In edit mode, it will just be the one employee being edited.
                return allEmployees.filter(emp => {
                    const isInShop = Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop;
                    const isNotEnrolled = emp.savingsProgramStatus !== 'Active';
                    return emp.status === 'Active' && isInShop && (isNotEnrolled || emp.id === participant?.id);
                });
            }, [selectedShop, allEmployees, participant]);
        
            const handleSubmit = (e) => {
                e.preventDefault();
                if (!selectedEmployeeId || isNaN(savingsPercentage) || savingsPercentage <= 0 || !joinDate || !effectiveMonth) {
                    alert("Please fill all required fields, including a savings percentage greater than 0.");
                    return;
                }
                onSave(selectedEmployeeId, savingsPercentage || 0, joinDate, effectiveMonth);
            };
        
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={participant ? "Edit Savings Percentage" : "Add to Savings Program"} onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Shop</label>
                                    <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select" disabled={!!participant}>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select" disabled={!selectedShop || !!participant}>
                                        <option value="">Select Employee</option>
                                        {availableEmployees.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Savings Percentage (%)</label>
                                    <input
                                        type="number"
                                        value={isNaN(savingsPercentage) ? '' : savingsPercentage}
                                        onChange={e => setSavingsPercentage(parseFloat(e.target.value))}
                                        className="input"
                                        min="0"
                                        max="100"
                                        placeholder="e.g., 10"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Join Program Date</label>
                                    <input
                                        type="date"
                                        value={joinDate}
                                        onChange={e => setJoinDate(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Effective Month</label>
                                    <input
                                        type="month"
                                        value={effectiveMonth}
                                        onChange={e => setEffectiveMonth(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Save</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // NEW: Modal for processing a savings payback
        const PaybackModal = ({ isOpen, onClose, onSave, participant }) => {
            const [amount, setAmount] = useState('');
            const [note, setNote] = useState('');
            const [error, setError] = useState('');

            useEffect(() => {
                if (isOpen) {
                    setAmount('');
                    setNote('');
                    setError('');
                }
            }, [isOpen]);

            const handleSubmit = (e) => {
                e.preventDefault();
                const paybackAmount = parseFloat(amount);
                if (isNaN(paybackAmount) || paybackAmount <= 0) {
                    setError('Please enter a valid positive amount.');
                    return;
                }
                if (paybackAmount > participant.savingsBalance) {
                    setError('Payback amount cannot exceed the total savings.');
                    return;
                }
                onSave(participant.id, paybackAmount, note);
            };

            if (!participant) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-md">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title="Process Savings Payback" onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <input value={participant.name} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Total Accumulated Savings</label>
                                    <input value={Utils.formatCurrency(participant.savingsBalance)} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Payback Amount (KHR)</label>
                                    <input
                                        type="number"
                                        value={amount}
                                        onChange={e => { setAmount(e.target.value); setError(''); }}
                                        className="input"
                                        placeholder="Enter amount to pay back"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Note (Optional)</label>
                                    <input
                                        type="text"
                                        value={note}
                                        onChange={e => setNote(e.target.value)}
                                        className="input"
                                        placeholder="e.g., Cash withdrawal"
                                    />
                                </div>
                                {error && <p className="text-sm text-red-400">{error}</p>}
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Confirm Payback</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // NEW: Modal to display savings transaction history
        const SavingsHistoryModal = ({ isOpen, onClose, employeeName, transactions }) => {
             const sortedTransactions = useMemo(() => {
                if (!transactions) return [];
                return [...transactions].sort((a, b) => (b.date?.toDate() || 0) - (a.date?.toDate() || 0));
            }, [transactions]);

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-2xl">
                    <ModalHeader title={`Savings History for ${employeeName}`} onClose={onClose} />
                    <ModalBody>
                        <div className="overflow-x-auto max-h-[60vh]">
                            <table className="min-w-full divide-y divide-slate-700">
                                <thead className="bg-slate-900/50 sticky top-0">
                                    <tr>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note / Payroll ID</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-700">
                                    {sortedTransactions.map(tx => (
                                        <tr key={tx.id} className="hover:bg-slate-700/50">
                                            <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatRequestDate(tx.date)}</td>
                                            <td className="px-4 py-4 text-sm font-semibold">
                                                {tx.type === 'contribution' ? (
                                                    <span className="text-green-400">Contribution</span>
                                                ) : (
                                                    <span className="text-red-400">Withdrawal</span>
                                                )}
                                            </td>
                                            <td className={`px-4 py-4 text-sm text-right font-semibold ${tx.type === 'contribution' ? 'text-green-400' : 'text-red-400'}`}>
                                                {Utils.formatCurrency(tx.amountDeducted || tx.amountWithdrawn)}
                                            </td>
                                            <td className="px-4 py-4 text-sm text-slate-400">{tx.payrollId || tx.note || '-'}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </ModalBody>
                    <ModalFooter>
                        <Button variant="secondary" onClick={onClose}>Close</Button>
                    </ModalFooter>
                </Modal>
            );
        };

        // MOVED & RENAMED: from SalarySavingTab to ParticipantsTab
        const ParticipantsTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { doc, updateDoc, where } = window.firebaseSDK;
            const { employees, shops } = useAppData();
            
            // Fetch all savings balances. We'll filter them on the client side.
            const { data: allSavings } = useCollection('employeeSavings');
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState('');
            const [isSavingModalOpen, setIsSavingModalOpen] = useState(false);
            const [editingParticipant, setEditingParticipant] = useState(null);
            const [participantToRemove, setParticipantToRemove] = useState(null);
            const [paybackParticipant, setPaybackParticipant] = useState(null);
            const [historyParticipant, setHistoryParticipant] = useState(null);
            const [participantForPaybackConfirmation, setParticipantForPaybackConfirmation] = useState(null);

            // Fetch transaction history for the selected employee
            const historyQueryConstraints = useMemo(() => {
                return historyParticipant ? [where("employeeId", "==", historyParticipant.id)] : [where("employeeId", "==", "null")];
            }, [historyParticipant]);
            const { data: transactionHistory } = useCollection('savingsTransactions', historyQueryConstraints);

            const handleOpenSavingModal = (participant = null) => {
                setEditingParticipant(participant);
                setIsSavingModalOpen(true);
            };

            const handleCloseSavingModal = () => {
                setEditingParticipant(null);
                setIsSavingModalOpen(false);
            };

            const handleSaveParticipant = async (employeeId, percentage, joinDate, effectiveMonth) => {
                if (!employeeId || !db) return;
                try {
                    const employeeRef = doc(db, 'employees', employeeId);
                    await updateDoc(employeeRef, {
                        savingsProgramStatus: 'Active',
                        savingsPercentage: percentage,
                        savingsJoinDate: joinDate,
                        savingsEffectiveMonth: effectiveMonth
                    });
                    handleCloseSavingModal();
                } catch (error) {
                    console.error("Error saving participant:", error);
                    alert("Failed to save participant.");
                }
            };
            
            const handleConfirmRemove = async () => {
                if (!participantToRemove || !db) return;
                try {
                    const employeeRef = doc(db, 'employees', participantToRemove.id);
                    await updateDoc(employeeRef, {
                        savingsProgramStatus: 'Inactive',
                        savingsPercentage: 0
                    });
                    setParticipantToRemove(null);
                } catch (error) {
                    console.error("Error removing participant:", error);
                    alert("Failed to remove participant.");
                }
            };
            
            const handleStartPaybackProcess = () => {
                if (!participantForPaybackConfirmation) return;
                setPaybackParticipant(participantForPaybackConfirmation);
                setParticipantForPaybackConfirmation(null);
            };
            
            const handleProcessPayback = async (employeeId, amount, note) => {
                const result = await Utils.manageSavingsWithdrawal(db, employeeId, amount, note);
                if (result.success) {
                    alert("Payback processed successfully!");
                    setPaybackParticipant(null);
                } else {
                    alert(`Payback failed: ${result.error?.message || 'An unknown error occurred.'}`);
                }
            };

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const enrolledEmployees = useMemo(() => {
                const savingsMap = new Map(allSavings.map(s => [s.employeeId, s.currentBalance]));
                const enrolled = employees.filter(emp => emp.savingsProgramStatus === 'Active');
                const filtered = enrolled.filter(emp => 
                    (!selectedShop || (Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop)) &&
                    (emp.name.toLowerCase().includes(searchTerm.toLowerCase()))
                );
                return filtered.map(emp => ({
                    ...emp,
                    savingsBalance: savingsMap.get(emp.id) || 0
                })).sort((a,b) => a.name.localeCompare(b.name));
            }, [employees, allSavings, selectedShop, searchTerm]);

            const totalSavings = useMemo(() => {
                return enrolledEmployees.reduce((sum, emp) => sum + emp.savingsBalance, 0);
            }, [enrolledEmployees]);

            const handleExportExcel = useCallback(() => {
                const dataToExport = enrolledEmployees.map(emp => ({ 
                    'Name': emp.name,
                    'Shop': Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop,
                    'Savings Percentage (%)': emp.savingsPercentage,
                    'Total Accumulated Savings (KHR)': emp.savingsBalance
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Salary Savings Report");
                worksheet["!cols"] = [ { wch: 25 }, { wch: 20 }, { wch: 25 }, { wch: 30 } ];
                XLSX.writeFile(workbook, "Salary_Savings_Report.xlsx");
            }, [enrolledEmployees]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Salary Saving Program Participants</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text" 
                                placeholder="Search by name..." 
                                value={searchTerm} 
                                onChange={e => setSearchTerm(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                             {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenSavingModal()}>Add Participant</Button>
                            )}
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Join Date</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Savings Percentage</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Effective Month</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Accumulated Savings</th>
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                        <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                    )}
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {enrolledEmployees.map(emp => (
                                    <tr key={emp.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm text-slate-200">{emp.name}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(emp.savingsJoinDate)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-center">{emp.savingsPercentage}%</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-center">{emp.savingsEffectiveMonth}</td>
                                        <td className="px-4 py-4 text-sm text-blue-300 font-semibold text-right">{Utils.formatCurrency(emp.savingsBalance)}</td>
                                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                            <td className="px-4 py-4 text-center">
                                                <div className="flex items-center justify-center gap-2">
                                                    <Button variant="icon-view" icon="fa-history" onClick={() => setHistoryParticipant(emp)} title="View History"/>
                                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                        <Button variant="success" icon="fa-hand-holding-usd" onClick={() => setParticipantForPaybackConfirmation(emp)} title="Process Payback" className="px-3 py-1 text-xs">Payback</Button>
                                                    )}
                                                    <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenSavingModal(emp)} title="Edit Percentage"/>
                                                    {/* MODIFIED: Only Admin and CEO can see the delete button */}
                                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                        <Button variant="icon-delete" icon="fa-user-minus" onClick={() => setParticipantToRemove(emp)} title="Remove from Program"/>
                                                    )}
                                                </div>
                                            </td>
                                        )}
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot className="bg-slate-900/50">
                                <tr>
                                    <td colSpan="5" className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Total Savings of Filtered Employees</td>
                                    <td className="px-4 py-3 text-right font-bold text-blue-300">{Utils.formatCurrency(totalSavings)}</td>
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && <td></td>}
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <AddSalarySavingModal
                        isOpen={isSavingModalOpen}
                        onClose={handleCloseSavingModal}
                        onSave={handleSaveParticipant}
                        participant={editingParticipant}
                        userProfile={userProfile}
                        allEmployees={employees}
                    />
                    <ConfirmationModal 
                        isOpen={!!participantToRemove}
                        onClose={() => setParticipantToRemove(null)}
                        onConfirm={handleConfirmRemove}
                        title="Remove from Program"
                        message={`Are you sure you want to remove ${participantToRemove?.name} from the Salary Saving Program? This action will set their status to Inactive.`}
                    />
                    <ConfirmationModal
                        isOpen={!!participantForPaybackConfirmation}
                        onClose={() => setParticipantForPaybackConfirmation(null)}
                        onConfirm={handleStartPaybackProcess}
                        title="Confirm Payback"
                        message={`Are you sure you want to start the payback process for ${participantForPaybackConfirmation?.name}?`}
                    />
                    <PaybackModal
                        isOpen={!!paybackParticipant}
                        onClose={() => setPaybackParticipant(null)}
                        onSave={handleProcessPayback}
                        participant={paybackParticipant}
                    />
                    <SavingsHistoryModal
                        isOpen={!!historyParticipant}
                        onClose={() => setHistoryParticipant(null)}
                        employeeName={historyParticipant?.name}
                        transactions={transactionHistory}
                    />
                </Card>
            );
        };

        // MOVED: Savings History Tab
        const SavingsHistoryTab = ({ userProfile }) => {
            const { employees, shops } = useAppData();
            const { data: transactions, loading } = useCollection('savingsTransactions');

            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [searchTerm, setSearchTerm] = useState('');

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const { processedTransactions, totals } = useMemo(() => {
                const employeeMap = new Map(employees.map(emp => [emp.id, { name: emp.name, shop: emp.shop }]));
                
                const filtered = transactions.filter(tx => {
                    const employee = employeeMap.get(tx.employeeId);
                    if (!employee) return false;

                    const txDate = tx.date?.toDate();
                    if (!txDate) return false;
                    
                    const monthMatch = !selectedMonth || txDate.toISOString().startsWith(selectedMonth);
                    const employeeShops = Array.isArray(employee.shop) ? employee.shop : [employee.shop];
                    const shopMatch = !selectedShop || employeeShops.includes(selectedShop);
                    const searchMatch = !searchTerm || employee.name.toLowerCase().includes(searchTerm.toLowerCase());

                    return monthMatch && shopMatch && searchMatch;
                });
                
                const processed = filtered.map(tx => {
                    const employee = employeeMap.get(tx.employeeId);
                    return {
                        ...tx,
                        staffName: employee?.name || 'Unknown',
                        shop: Array.isArray(employee?.shop) ? employee.shop.join(', ') : employee?.shop,
                    };
                }).sort((a,b) => (b.date?.toDate() || 0) - (a.date?.toDate() || 0));

                const totals = processed.reduce((acc, tx) => {
                    if (tx.type === 'contribution') {
                        acc.totalContributions += tx.amountDeducted || 0;
                    } else if (tx.type === 'withdrawal') {
                        acc.totalWithdrawals += tx.amountWithdrawn || 0;
                    }
                    return acc;
                }, { totalContributions: 0, totalWithdrawals: 0 });

                return { processedTransactions: processed, totals };
            }, [transactions, employees, selectedMonth, selectedShop, searchTerm]);

            const handleExportExcel = useCallback(() => {
                const dataToExport = processedTransactions.map(tx => ({ 
                    'Date': Utils.formatRequestDate(tx.date),
                    'Staff Name': tx.staffName,
                    'Shop': tx.shop,
                    'Type': tx.type,
                    'Amount (KHR)': tx.amountDeducted || tx.amountWithdrawn,
                    'Note / Payroll ID': tx.payrollId || tx.note || '-'
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Savings History");
                worksheet["!cols"] = [ { wch: 20 }, { wch: 25 }, { wch: 20 }, { wch: 15 }, { wch: 20 }, { wch: 30 } ];
                XLSX.writeFile(workbook, `Savings_History_${selectedMonth}.xlsx`);
            }, [processedTransactions, selectedMonth]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Savings Transaction History</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text" 
                                placeholder="Search by name..." 
                                value={searchTerm} 
                                onChange={e => setSearchTerm(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                             {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <input 
                                type="month" 
                                value={selectedMonth} 
                                onChange={e => setSelectedMonth(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                     {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note / Payroll ID</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {processedTransactions.map(tx => (
                                    <tr key={tx.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatRequestDate(tx.date)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-200">{tx.staffName}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{tx.shop}</td>
                                        <td className="px-4 py-4 text-sm font-semibold">
                                            {tx.type === 'contribution' ? (
                                                <span className="text-green-400">Contribution</span>
                                            ) : (
                                                <span className="text-red-400">Withdrawal</span>
                                            )}
                                        </td>
                                        <td className={`px-4 py-4 text-sm text-right font-semibold ${tx.type === 'contribution' ? 'text-green-400' : 'text-red-400'}`}>
                                            {Utils.formatCurrency(tx.amountDeducted || tx.amountWithdrawn)}
                                        </td>
                                        <td className="px-4 py-4 text-sm text-slate-400">{tx.payrollId || tx.note || '-'}</td>
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot className="bg-slate-900/50">
                                <tr>
                                    <td colSpan="4" className="px-4 py-3 text-right font-bold text-green-400 uppercase">Total Contributions</td>
                                    <td className="px-4 py-3 text-right font-bold text-green-400">{Utils.formatCurrency(totals.totalContributions)}</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td colSpan="4" className="px-4 py-3 text-right font-bold text-red-400 uppercase">Total Withdrawals</td>
                                    <td className="px-4 py-3 text-right font-bold text-red-400">{Utils.formatCurrency(totals.totalWithdrawals)}</td>
                                    <td></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    )}
                </Card>
            );
        };
        
        // NEW: Main Savings Program Page (Tab Container)
        const SavingsProgramPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('participants');
            return (
                <TabbedPage tabs={{ participants: 'Participants', history: 'Savings History' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="participants"><ParticipantsTab userProfile={userProfile} /></div>
                    <div id="history"><SavingsHistoryTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };
        // --- END SAVINGS PROGRAM PAGE COMPONENTS ---

        // --- START CHECKINME PAGE COMPONENTS ---

        // Component: Check In / Out Tab
        const CheckInOutTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [currentTime, setCurrentTime] = useState(new Date());
            const [location, setLocation] = useState(null);
            const [accuracy, setAccuracy] = useState(null); // NEW: State for location accuracy
            const [status, setStatus] = useState('សូមចុច "Refresh Location" ដើម្បីចាប់ផ្តើម!');
            const [loading, setLoading] = useState(false);
            const [distance, setDistance] = useState(null);
            const [selectedShopForCheckIn, setSelectedShopForCheckIn] = useState('');
            const [alertModal, setAlertModal] = useState({ isOpen: false, message: '' }); // State for the new alert modal
            const [savingsBalance, setSavingsBalance] = useState(0); // NEW: State for savings balance
            
            // FIX: Set the month filter to default to the current month, respecting the user's local timezone.
            const [selectedMonth, setSelectedMonth] = useState(() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                return `${year}-${month}`;
            });

            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from AppDataProvider to reduce DB reads.
            const { shops, shifts } = useAppData();

            // PHASE 1 OPTIMIZATION: Queries for the salary preview are now filtered by the current user's ID.
            const staffQueryConstraints = useMemo(() => userProfile?.id ? [where("staffId", "==", userProfile.id)] : [], [userProfile?.id]);
            const attendanceQueryConstraints = useMemo(() => userProfile?.id ? [where("employeeId", "==", userProfile.id)] : [], [userProfile?.id]);

            // Fetch all data needed for the payroll hook
            const allData = {
                shops: shops, // Use data from context
                attendance: useCollection('attendance', attendanceQueryConstraints).data,
                leaveRequests: useCollection('leaveRequests', staffQueryConstraints).data,
                otRequests: useCollection('otRequests', staffQueryConstraints).data,
                staffLoans: useCollection('staffLoans', staffQueryConstraints).data,
                employeeStates: useCollection('employeeStates', staffQueryConstraints).data,
                salaryRevisions: useCollection('salaryRevisions', staffQueryConstraints).data,
                shifts: shifts, // Use data from context
            };
            
            // --- NEW: Step 4/5 - Real-time listener for the employee's savings balance ---
            useEffect(() => {
                // This effect runs only for the logged-in user.
                if (!db || !userProfile?.id) return;
                
                const { doc, onSnapshot } = window.firebaseSDK;
                // The document ID in 'employeeSavings' collection is the employee's ID.
                const savingsDocRef = doc(db, 'employeeSavings', userProfile.id);

                const unsubscribe = onSnapshot(savingsDocRef, (doc) => {
                    if (doc.exists()) {
                        setSavingsBalance(doc.data().currentBalance || 0);
                    } else {
                        setSavingsBalance(0); // If no document exists, balance is 0.
                    }
                }, (error) => { console.error("Error fetching savings balance:", error); });
                return () => unsubscribe(); // Clean up the listener on component unmount.
            }, [db, userProfile?.id]);
            
            const isMultiShopManager = userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop);

            // Set the default shop for check-in
            useEffect(() => {
                if (!isMultiShopManager) {
                    setSelectedShopForCheckIn(userProfile.shop);
                }
            }, [userProfile, isMultiShopManager]);

            const userShop = useMemo(() => {
                if (!selectedShopForCheckIn) return null;
                return allData.shops.find(s => s.name === selectedShopForCheckIn);
            }, [selectedShopForCheckIn, allData.shops]);

            // --- START TIMEZONE FIX ---
            // Get today's date string ('YYYY-MM-DD') based on the shop's specific timezone.
            // This is crucial for correctly identifying today's attendance records.
            const todayInShopTimezone = useMemo(() => {
                // Fallback to user's local date if shop isn't selected or has no timezone.
                if (!userShop?.timezone) {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                return Utils.formatDateInTimezone({ toDate: () => new Date() }, userShop.timezone).localDate;
            }, [userShop]);

            const userAttendanceToday = useMemo(() => {
                // Filter attendance records by comparing their date (in shop timezone) with today's date (in shop timezone).
                return (allData.attendance || [])
                    .filter(a => {
                        if (a.employeeId !== userProfile.id) return false;
                        const { localDate: recordDate } = Utils.formatDateInTimezone(a.timestamp, userShop?.timezone);
                        return recordDate === todayInShopTimezone;
                    })
                    .sort((a, b) => (b.timestamp?.toDate() || 0) - (a.timestamp?.toDate() || 0));
            }, [userProfile, allData.attendance, userShop, todayInShopTimezone]);
            // --- END TIMEZONE FIX ---
            
            const lastAction = userAttendanceToday[0] || null;

            // Update time every second
            useEffect(() => { const timerId = setInterval(() => setCurrentTime(new Date()), 1000); return () => clearInterval(timerId); }, []);
            
            // Get user's location and check distance from shop
            const getLocation = useCallback((isCheckAction = false) => {
                if (!userShop) { 
                    setStatus(isMultiShopManager ? "Please select a shop to enable check-in." : "Your assigned shop could not be found."); 
                    setLoading(false);
                    return Promise.reject("No user shop selected"); 
                }
                
                setStatus("Getting your current location...");
                setLoading(true);

                return new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude, accuracy: posAccuracy } = position.coords;
                            const newLocation = { latitude, longitude };
                            setLocation(newLocation);
                            setAccuracy(posAccuracy);
                            
                            const dist = Utils.getDistance(latitude, longitude, parseFloat(userShop.latitude), parseFloat(userShop.longitude));
                            setDistance(dist);
                            
                            const radius = parseFloat(userShop.radius) || 500;
                            const isInRange = dist <= radius;
                            
                            setStatus(isInRange 
                                ? `You are ${Math.round(dist)}m from the shop. Check-in is enabled.`
                                : `You are ${Math.round(dist)}m from the shop. Check-in is disabled.`
                            );
                            setLoading(false);
                            // Resolve with location data for the check-in handler to use
                            resolve({ location: newLocation, distance: dist, shop: userShop });
                        },
                        (error) => {
                            setStatus(error.code === 1 ? "Location permission denied." : "Could not get your location."); 
                            setLoading(false);
                            reject(error);
                        }, 
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Optimized options
                    );
                });
            }, [userShop, isMultiShopManager]);

            const handleCheckAction = useCallback(async () => {
                setLoading(true);
                setStatus("Getting fresh location for check action...");
                
                try {
                    // Step 1: Get a fresh location reading.
                    const { location: freshLocation, distance: freshDistance, shop } = await getLocation(true);

                    // Step 2: Verify the user is still in range.
                    if (freshDistance > (parseFloat(shop.radius) || 500)) {
                        setStatus(`Cannot check-in. You are ${Math.round(freshDistance)}m away.`);
                        setLoading(false);
                        return;
                    }
                    
                    // Step 3: Proceed with saving the attendance record.
                    const { addDoc, collection, serverTimestamp, getDocs, query, where } = window.firebaseSDK;
                    const nextActionType = lastAction?.type === 'in' ? 'out' : 'in';
                    const checkInTimestamp = new Date();
                    
                    await addDoc(collection(db, 'attendance'), { employeeId: userProfile.id, employeeName: userProfile.name, shop: selectedShopForCheckIn, timestamp: serverTimestamp(), type: nextActionType, location: freshLocation });
                    
                    // Step 4: Handle late check-in logic if applicable.
                    if (nextActionType === 'in') {
                        const employeeShiftName = userProfile.shift;
                        const shiftDetails = (allData.shifts || []).find(s => s.name === employeeShiftName && s.shopName === selectedShopForCheckIn);
                        let isLate = false;

                        // FIX: Use the shop's timezone for late detection.
                        if (shiftDetails && shiftDetails.lateThreshold && shop.timezone) {
                            const [lateHour, lateMinute] = shiftDetails.lateThreshold.split(':').map(Number);
                            
                            // Get the current hour and minute in the shop's specific timezone.
                            // 'en-GB' is used to get a reliable 24-hour format (HH:mm).
                            const timeInZoneString = checkInTimestamp.toLocaleTimeString('en-GB', { timeZone: shop.timezone, hour: '2-digit', minute: '2-digit' });
                            const [checkInHour, checkInMinute] = timeInZoneString.split(':').map(Number);
                            
                            // Check if check-in time is strictly greater than the late threshold
                            if (checkInHour > lateHour || (checkInHour === lateHour && checkInMinute > lateMinute)) {
                                isLate = true;
                            }
                        }
                        
                        if (isLate) {
                            // --- START TIMEZONE FIX ---
                            // Get the date string for the late check-in based on the shop's timezone.
                            // This ensures the deduction is recorded on the correct calendar day for the employee.
                            const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => checkInTimestamp }, shop.timezone);
                            // --- END TIMEZONE FIX ---
                            const approvedLeaveToday = (allData.leaveRequests || []).find(lr => lr.staffId === userProfile.id && lr.status === 'Approved' && todayStr >= lr.leaveDate && todayStr < lr.returnDate);
                            if (!approvedLeaveToday) {
                                // FIX: Check if a late deduction already exists for this user today
                                const q = query(collection(db, "employeeStates"), where("staffId", "==", userProfile.id), where("date", "==", todayStr));
                                const existingDeductionsSnap = await getDocs(q);
                                
                                // REVISED: Use a more specific startsWith check and add console logging for easier debugging.
                                const hasLateDeductionToday = existingDeductionsSnap.docs.some(doc => doc.data().note?.startsWith('CheckIn Late @'));

                                if (hasLateDeductionToday) {
                                    console.log(`Late deduction for ${userProfile.name} on ${todayStr} already exists. Skipping creation.`);
                                } else {
                                    console.log(`No existing late deduction found for ${userProfile.name} on ${todayStr}. Creating new record.`);
                                    const pendingLeaveToday = (allData.leaveRequests || []).find(lr => lr.staffId === userProfile.id && lr.status === 'Pending' && lr.leaveDate === todayStr);
                                    if (pendingLeaveToday) { setAlertModal({ isOpen: true, message: 'Your leave request for today is pending. A late deduction has been applied.' }); }
                                
                                    // FIX: Format the alert time using the shop's timezone as well.
                                    const formattedTime = checkInTimestamp.toLocaleTimeString('en-US', { timeZone: shop.timezone, hour: '2-digit', minute: '2-digit', hour12: true });

                                    // FIX: Use a more specific note for late check-ins to be consistent with reports
                                    await addDoc(collection(db, 'employeeStates'), { staffId: userProfile.id, staffName: userProfile.name, shop: selectedShopForCheckIn, date: todayStr, statusState: 'Deduction', amount: 5000, note: `CheckIn Late @${formattedTime}` });
                                }
                            } // FIX: Added missing closing brace for the 'if (!approvedLeaveToday)' block.
                        }
                    }
                    // REVISED: Show a success alert modal instead of just updating the status text.
                    setAlertModal({ isOpen: true, message: `Successfully checked ${nextActionType} at ${checkInTimestamp.toLocaleTimeString()}.` });
                    setStatus(`Last action: Checked ${nextActionType}.`); // Keep a simple status for the main display
                } catch (error) {
                    // Error is already set by getLocation, but we can add a fallback.
                    if (!status.includes('permission') && !status.includes('Could not get')) {
                        setStatus("Failed to record attendance.");
                    }
                    console.error("Error during check action:", error);
                } finally {
                    setLoading(false);
                }
            }, [db, lastAction, userProfile, selectedShopForCheckIn, allData.leaveRequests, getLocation]);

            const canCheck = distance !== null && userShop && distance <= (parseFloat(userShop.radius) || 500);

            // Use the new centralized hook with the selected month
            const { inputs, calculations } = usePayrollCalculator(userProfile, selectedMonth, allData);

            return (
                <Card className="max-w-2xl mx-auto"><div className="flex flex-col items-center justify-center p-4 sm:p-8 space-y-8">
                    <div className="text-center">
                        <p className="text-4xl sm:text-7xl font-bold text-slate-100 tracking-wider">
                            {/* FIX: Display time based on the selected shop's timezone. Fallback to user's local timezone if not set. */}
                            {currentTime.toLocaleTimeString('en-US', { timeZone: userShop?.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone, hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })}
                        </p>
                        <p className="text-xl text-slate-400 mt-2">
                            {/* FIX: Display date based on the selected shop's timezone. */}
                            {currentTime.toLocaleDateString('en-US', { timeZone: userShop?.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone, weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
                        </p>
                    </div>
                    {isMultiShopManager && (
                        <div className="w-full max-w-md">
                            <label className="text-sm font-medium text-slate-400">Select Shop for Check-in</label>
                            <select value={selectedShopForCheckIn} onChange={e => setSelectedShopForCheckIn(e.target.value)} className="select">
                                <option value="">-- Select Your Shop --</option>
                                {userProfile.shop.map(shopName => <option key={shopName} value={shopName}>{shopName}</option>)}
                            </select>
                        </div>
                    )}
                    <div className="flex gap-4">
                        <button onClick={handleCheckAction} disabled={lastAction?.type === 'in' || loading} className={`px-8 py-3 text-lg font-semibold rounded-lg shadow-md transition-colors transform hover:scale-105 ${lastAction?.type === 'in' || loading ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-green-600 text-white hover:bg-green-700'}`}>{loading && lastAction?.type !== 'in' ? <i className="fas fa-spinner fa-spin"></i> : 'Check In'}</button>
                        <button onClick={handleCheckAction} disabled={lastAction?.type !== 'in' || loading} className={`px-8 py-3 text-lg font-semibold rounded-lg shadow-md transition-colors transform hover:scale-105 ${lastAction?.type !== 'in' || loading ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-slate-600 text-white hover:bg-slate-500'}`}>{loading && lastAction?.type === 'in' ? <i className="fas fa-spinner fa-spin"></i> : 'Check Out'}</button>
                    </div>
                    <div className="w-full max-w-md">
                        <Button onClick={() => getLocation(false)} disabled={loading || !userShop} variant="secondary" className="w-full">
                            {loading ? 'Refreshing...' : 'Refresh Location'}
                        </Button>
                    </div>
                    <div className={`p-4 rounded-lg text-center w-full max-w-md ${canCheck ? 'bg-green-900/50 border-green-700' : 'bg-red-900/50 border-red-700'} border`}>
                        <p className="font-medium text-lg text-slate-100">{status}</p>
                        {accuracy && <p className="text-xs text-slate-400 mt-1">Accuracy: {Math.round(accuracy)}m</p>}
                    </div>

                    {/* --- NEW: Step 4/5 - Savings Program Balance Display --- */}
                    {userProfile?.savingsProgramStatus === 'Active' && (
                        <div className="w-full max-w-md mt-8 p-4 bg-indigo-900/50 border border-indigo-700 rounded-lg text-center">
                            <h4 className="text-lg font-semibold text-indigo-200">My Savings Program</h4>
                            <p className="text-sm text-slate-400">Total Accumulated Savings</p>
                            <p className="text-4xl font-bold text-white mt-2">
                                {Utils.formatCurrency(savingsBalance)}
                            </p>
                        </div>
                    )}

                    <div className="text-center text-sm text-slate-400"><p>Welcome, <span className="font-bold text-slate-200">{userProfile?.name}</span></p><p>Your selected shop is <span className="font-bold text-slate-200">{selectedShopForCheckIn || 'N/A'}</span></p>{lastAction && (<p className="mt-2">Last action: Checked <span className="font-semibold text-slate-200">{
                        /* FIX: Format the last action timestamp using the shop's timezone for consistency. */
                        Utils.formatDateInTimezone(lastAction.timestamp, userShop?.timezone).localTime
                    }</span></p>)}</div>
                    {/* New Salary Preview Section */}
                    <div className="w-full max-w-md mt-8 p-4 bg-slate-700/50 border border-slate-600 rounded-lg">
                        <div className="flex justify-between items-center mb-4">
                             <h4 className="text-lg font-semibold text-slate-100">ប្រាក់ខែរកបាន</h4>
                             <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input !mt-0 w-auto" />
                        </div>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            {/* Earnings Column */}
                            <div className="space-y-2">
                                <h5 className="font-semibold text-slate-200 border-b border-slate-600 pb-1 mb-2">ប្រាក់ចំណូល :</h5>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ថ្ងៃធ្វើការ :</span><span className="font-semibold text-slate-200">{inputs.workDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ផ្តល់ជូន :</span><span className="font-semibold text-slate-200">{inputs.givenOffDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ថែមម៉ោង :</span><span className="font-semibold text-slate-200">{inputs.otDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ប្រាក់បន្ថែម :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(calculations.engagements)}</span></div>
                                <div className="pt-2 border-t border-slate-600 flex justify-between items-center text-sm"><span className="font-bold text-green-400">ប្រាក់ចំណូលសរុប :</span><span className="font-bold text-green-400">{Utils.formatCurrency(calculations.grossSalary)}</span></div>
                            </div>
                            {/* Deductions Column */}
                            <div className="space-y-2">
                                <h5 className="font-semibold text-slate-200 border-b border-slate-600 pb-1 mb-2">ការកាត់ប្រាក់ :</h5>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ច្បាប់សម្រាក :</span><span className="font-semibold text-slate-200">{inputs.leaveDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">មកយឺតសរុប :</span><span className="font-semibold text-slate-200">{inputs.totalLateDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm" title="អវត្តមាន + ភ្លេចចុចចេញ"><span className="text-slate-400">អវត្តមាន :</span><span className="font-semibold text-slate-200">{inputs.noAttendance || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">បំណុលរំលួស :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(inputs.loanDeduction)}</span></div>
                                {calculations.savingsDeduction > 0 && (
                                    <div className="flex justify-between items-center text-sm">
                                        <span className="text-slate-400">ការកាត់សន្សំ :</span>
                                        <span className="font-semibold text-blue-400">{Utils.formatCurrency(calculations.savingsDeduction)}</span>
                                    </div>
                                )}
                                {calculations.rejectedLeavePenaltyAmount > 0 && (
                                    <div className="flex justify-between items-center text-sm" title="Penalty for absence on a day with a rejected leave request">
                                        <span className="text-slate-400">ច្បាប់សម្រាកបដិសេធ :</span>
                                        <span className="font-semibold text-red-400">{Utils.formatCurrency(calculations.rejectedLeavePenaltyAmount)}</span>
                                    </div>
                                )}
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ការកាត់ផ្សេងៗ :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(calculations.otherDeductions)}</span></div>
                                <div className="pt-2 border-t border-slate-600 flex justify-between items-center text-sm"><span className="font-bold text-red-400">ការកាត់ប្រាក់សរុប :</span><span className="font-bold text-red-400">{Utils.formatCurrency(calculations.totalDeductions)}</span></div>
                            </div>
                        </div>
                        <div className="mt-4 pt-4 border-t border-slate-600 flex justify-between items-center">
                            <span className="font-bold text-slate-200">ប្រាក់ខែសុទ្ធទទួលបាន :</span>
                            <span className="text-xl font-bold text-blue-400">{Utils.formatCurrency(calculations.netSalary)}</span>
                        </div>
                    </div>
                </div>
                {/* Alert Modal for Pending Leave */}
                <Modal isOpen={alertModal.isOpen} onClose={() => setAlertModal({ isOpen: false, message: '' })} maxWidth="max-w-sm">
                    <ModalHeader title="Notification" onClose={() => setAlertModal({ isOpen: false, message: '' })} />
                    <ModalBody><p className="text-slate-300">{alertModal.message}</p></ModalBody>
                    <ModalFooter><Button variant="primary" onClick={() => setAlertModal({ isOpen: false, message: '' })}>OK</Button></ModalFooter>
                </Modal>
                </Card>
            );
        };
        
        // Component: Leave Request Modal
        const LeaveRequestModal = ({ isOpen, onClose, onSave, request, userProfile }) => {
            const [formData, setFormData] = useState({});
            
            // Get global data from context
            const { shops, employees } = useAppData();

            const isManagerial = useMemo(() => userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager', [userProfile]);

            // Filter employees for the dropdown based on the selected shop in the modal
            const employeesInShop = useMemo(() => {
                if (!formData.shop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shop) && emp.status === 'Active';
                });
            }, [formData.shop, employees]);
            
            // Determine which shops should be available in the dropdown
            const availableShopsForModal = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return []; // Staff don't get a shop dropdown
            }, [userProfile, shops]);

            useEffect(() => {
                if (request) { // EDIT mode: Populate with existing request data
                    setFormData(request);
                } else if (userProfile) { // NEW request mode
                    const initialData = {
                        leaveDate: new Date().toISOString().substring(0, 10),
                        returnDate: new Date().toISOString().substring(0, 10),
                        numberOfDays: 1,
                        leaveSession: 'Full Day',
                        leaveType: 'Annual Leave',
                        reason: '',
                        // Conditionally pre-fill based on role
                        shop: isManagerial ? '' : (Array.isArray(userProfile.shop) ? userProfile.shop[0] : userProfile.shop || ''),
                        staffId: isManagerial ? '' : (userProfile.id || ''),
                        staffName: isManagerial ? '' : (userProfile.name || ''),
                        supervisor: isManagerial ? '' : (userProfile.supervisor || ''),
                    };
                    setFormData(initialData);
                }
            }, [request, userProfile, isOpen, isManagerial]);

            const dateDiffInDays = useMemo(() => {
                if (formData.leaveDate && formData.returnDate) {
                    const start = new Date(formData.leaveDate);
                    const end = new Date(formData.returnDate);
                    if (end <= start) return 0;
                    const diffTime = end.getTime() - start.getTime();
                    return Math.round(diffTime / (1000 * 60 * 60 * 24));
                }
                return 0;
            }, [formData.leaveDate, formData.returnDate]);

            const isMultiDayLeave = dateDiffInDays > 1;

            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                let newFormData = { ...formData, [name]: value };

                // When a manager selects a shop, reset the staff selection
                if (name === 'shop') {
                    newFormData.staffId = '';
                    newFormData.staffName = '';
                    newFormData.supervisor = '';
                }

                // When a manager selects a staff member, populate their details
                if (name === 'staffId') {
                    const selectedEmployee = employees.find(emp => emp.id === value);
                    if (selectedEmployee) {
                        newFormData.staffName = selectedEmployee.name;
                        newFormData.supervisor = selectedEmployee.supervisor || '';
                    } else {
                        newFormData.staffName = '';
                        newFormData.supervisor = '';
                    }
                }

                // Recalculate days based on dates and session.
                const { leaveDate, returnDate, leaveSession } = newFormData;

                if (leaveDate && returnDate) {
                    const start = new Date(leaveDate);
                    const end = new Date(returnDate);
                    start.setHours(0, 0, 0, 0); // Normalize to avoid timezone issues
                    end.setHours(0, 0, 0, 0);

                    if (end < start) {
                        newFormData.numberOfDays = 0;
                    } else {
                        const diffTime = end.getTime() - start.getTime();
                        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                        // Case: User selects same leave and return date. We interpret this as a single-day event.
                        if (diffDays === 0) {
                            if (leaveSession === 'Full Day') { newFormData.numberOfDays = 1; } 
                            else { newFormData.numberOfDays = 0.5; }
                        } 
                        // Case: Standard single day leave (e.g., leave Mon, return Tue)
                        else if (diffDays === 1) {
                            if (leaveSession === 'Full Day') { newFormData.numberOfDays = 1; } 
                            else { newFormData.numberOfDays = 0.5; }
                        } 
                        // Case: Multi-day leave
                        else {
                            newFormData.numberOfDays = diffDays;
                            newFormData.leaveSession = 'Full Day'; // Force full day for multi-day leaves
                        }
                    }
                } else {
                    newFormData.numberOfDays = 0;
                }
                
                setFormData(newFormData);
            }, [formData, employees]);
            
            const handleSubmit = useCallback((e) => { 
                e.preventDefault(); 
                if ((isManagerial || Array.isArray(userProfile.shop)) && !formData.shop) {
                    alert("Please select a shop for the leave request.");
                    return;
                }
                const dataToSave = { ...formData };
                if (dataToSave.leaveDate && dataToSave.leaveDate === dataToSave.returnDate) {
                    const returnDate = new Date(dataToSave.returnDate);
                    returnDate.setDate(returnDate.getDate() + 1);
                    dataToSave.returnDate = returnDate.toISOString().substring(0, 10);
                }
                onSave(dataToSave); 
            }, [onSave, formData, isManagerial, userProfile]);
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={request ? "Edit Leave Request" : "New Leave Request"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div><label className="text-sm">Leave Date</label><input type="date" name="leaveDate" value={formData.leaveDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Return Date</label><input type="date" name="returnDate" value={formData.returnDate || ''} onChange={handleChange} className="input" required /></div>
                                
                                <div>
                                    <label className="text-sm">Session</label>
                                    <select name="leaveSession" value={formData.leaveSession || 'Full Day'} onChange={handleChange} className="select" disabled={isMultiDayLeave}>
                                        <option value="Full Day">Full Day</option>
                                        <option value="AM">AM (Morning)</option>
                                        <option value="PM">PM (Afternoon)</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm">No. Day(s)</label>
                                    <input 
                                        type="number"
                                        name="numberOfDays" 
                                        value={formData.numberOfDays || ''} 
                                        className="input" required 
                                        disabled
                                    />
                                </div>
                                
                                {isManagerial ? (
                                    <div>
                                        <label className="text-sm">Shop Name</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" required>
                                            <option value="">Select Shop</option>
                                            {availableShopsForModal.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Shop Name</label><input value={formData.shop || ''} className="input" disabled /></div>
                                )}
                                
                                {isManagerial && !request ? (
                                    <div>
                                        <label className="text-sm">Staff Name</label>
                                        <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shop}>
                                            <option value="">Select Staff</option>
                                            {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Staff Name</label><input value={formData.staffName || ''} className="input" disabled /></div>
                                )}
                                
                                <div><label className="text-sm">Supervisor</label><input value={formData.supervisor || ''} className="input" disabled /></div>

                                <div className="lg:col-span-3"><label className="text-sm">Leave Type</label>
                                    <select name="leaveType" value={formData.leaveType || 'Annual Leave'} onChange={handleChange} className="select" required>
                                        <option>Relaxing Leave</option>
                                        <option>Sick Leave</option>
                                        <option>Emergency Leave</option>
                
                                    </select>
                                </div>
                                <div className="lg:col-span-3"><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3" required></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Submit Request</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // Component: OT Request Modal
        const OTRequestModal = ({ isOpen, onClose, onSave, request, userProfile }) => {
            const [formData, setFormData] = useState({});
            
            // Get global data from context
            const { shops, employees } = useAppData();

            const isManagerial = useMemo(() => userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager', [userProfile]);
            
            // Filter employees for dropdown based on selected shop
            const employeesInShop = useMemo(() => {
                if (!formData.shop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shop) && emp.status === 'Active';
                });
            }, [formData.shop, employees]);

            // Determine available shops for dropdown
            const availableShopsForModal = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [userProfile, shops]);

            // Initialize form data
            useEffect(() => {
                if (request) { // EDIT mode
                    setFormData(request);
                } else if (userProfile) { // NEW request mode
                    const initialData = {
                        reqDate: new Date().toISOString().substring(0, 10),
                        startTime: '', endTime: '', numberOfOTDays: 0, reason: '',
                        shop: isManagerial ? '' : (Array.isArray(userProfile.shop) ? userProfile.shop[0] : userProfile.shop || ''),
                        staffId: isManagerial ? '' : (userProfile.id || ''),
                        staffName: isManagerial ? '' : (userProfile.name || ''),
                        supervisor: isManagerial ? '' : (userProfile.supervisor || ''),
                    };
                    setFormData(initialData);
                }
            }, [request, userProfile, isOpen, isManagerial]);

            // Calculate OT days from start and end times
            useEffect(() => {
                if (formData.startTime && formData.endTime && formData.staffId && employees) {
                    const selectedEmployee = employees.find(e => e.id === formData.staffId);
                    const employeeShift = selectedEmployee ? selectedEmployee.shift : null;

                    if (employeeShift && (employeeShift === 'AM' || employeeShift === 'PM')) {
                        if (formData.startTime === '07:30' && formData.endTime === '17:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1 })); return; }
                        if (formData.startTime === '07:30' && formData.endTime === '21:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1.5 })); return; }
                    }
                    if (employeeShift && employeeShift === 'APM') {
                         if (formData.startTime === '07:30' && formData.endTime === '21:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1 })); return; }
                    }

                    const [startHour, startMinute] = formData.startTime.split(':').map(Number);
                    const [endHour, endMinute] = formData.endTime.split(':').map(Number);

                    if (!isNaN(startHour) && !isNaN(startMinute) && !isNaN(endHour) && !isNaN(endMinute)) {
                        const startDate = new Date(0, 0, 0, startHour, startMinute, 0);
                        let endDate = new Date(0, 0, 0, endHour, endMinute, 0);
                        if (endDate < startDate) { endDate.setDate(endDate.getDate() + 1); }
                        const diffMillis = endDate - startDate;
                        const diffHours = diffMillis / (1000 * 60 * 60);
                        let otDays = 0;
                        const OT_HOURS_PER_DAY = 8;
                        if (diffHours < 4) { otDays = 0; } 
                        else if (diffHours >= 4 && diffHours <= 5) { otDays = 0.5; } 
                        else { otDays = diffHours / OT_HOURS_PER_DAY; }
                        setFormData(prev => ({ ...prev, numberOfOTDays: otDays > 0 ? otDays.toFixed(2) : 0 }));
                    }
                }
            }, [formData.startTime, formData.endTime, formData.staffId, employees]);

            const handleChange = useCallback((e) => { 
                const { name, value } = e.target;
                let newFormData = { ...formData, [name]: value };

                if (name === 'shop') {
                    newFormData.staffId = '';
                    newFormData.staffName = '';
                    newFormData.supervisor = '';
                }
                if (name === 'staffId') {
                    const selectedEmployee = employees.find(emp => emp.id === value);
                    if (selectedEmployee) {
                        newFormData.staffName = selectedEmployee.name;
                        newFormData.supervisor = selectedEmployee.supervisor || '';
                    } else {
                        newFormData.staffName = '';
                        newFormData.supervisor = '';
                    }
                }
                setFormData(newFormData);
            }, [formData, employees]);
            
            const handleSubmit = useCallback((e) => { 
                e.preventDefault(); 
                if ((isManagerial || Array.isArray(userProfile.shop)) && !formData.shop) {
                    alert("Please select a shop for the OT request.");
                    return;
                }
                onSave(formData); 
            }, [onSave, formData, isManagerial, userProfile]);
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={request ? "Edit OT Request" : "New OT Request"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div><label className="text-sm">OT Date</label><input type="date" name="reqDate" value={formData.reqDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Start Hour</label><input type="time" name="startTime" value={formData.startTime || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">End Hour</label><input type="time" name="endTime" value={formData.endTime || ''} onChange={handleChange} className="input" required /></div>
                                
                                {isManagerial ? (
                                    <div>
                                        <label className="text-sm">Shop Name</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" required>
                                            <option value="">Select Shop</option>
                                            {availableShopsForModal.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Shop Name</label><input value={formData.shop || ''} className="input" disabled /></div>
                                )}
                                
                                {isManagerial && !request ? (
                                    <div>
                                        <label className="text-sm">Staff Name</label>
                                        <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shop}>
                                            <option value="">Select Staff</option>
                                            {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Staff Name</label><input value={formData.staffName || ''} className="input" disabled /></div>
                                )}
                                
                                <div><label className="text-sm">Supervisor</label><input value={formData.supervisor || ''} className="input" disabled /></div>
                                
                                <div className="lg:col-span-3"><label className="text-sm">No. OT Day(s)</label><input type="number" name="numberOfOTDays" value={formData.numberOfOTDays || ''} className="input" disabled /></div>
                                <div className="lg:col-span-3"><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3" required></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Submit Request</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // Component: A single card for displaying a request in the mobile view
        const RequestCard = memo(({ request, userProfile, config, onUpdateStatus, onEdit, onDelete }) => {
            const { cardFields } = config;

            return (
                <div className="bg-slate-700/50 rounded-lg p-4 space-y-3 flex flex-col">
                    <div className="flex justify-between items-start">
                        <div>
                            <p className="font-bold text-lg text-slate-100">{request.staffName}</p>
                            <p className="text-sm text-slate-300">{request.shop}</p>
                        </div>
                        <span className="px-2 py-1 text-xs font-semibold rounded-full bg-yellow-200 text-yellow-900">{request.status}</span>
                    </div>
                    <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-2 border-t border-slate-600 flex-grow">
                        {cardFields.map(field => (
                            <div key={field.label}>
                                <p className="text-slate-400">{field.label}</p>
                                <p className="text-slate-200 font-medium">{field.value(request)}</p>
                            </div>
                        ))}
                        <div className="col-span-2">
                            <p className="text-slate-400">Reason</p>
                            <p className="text-slate-200 font-medium whitespace-pre-wrap">{request.reason}</p>
                        </div>
                    </div>
                    <div className="flex justify-end space-x-3 pt-2">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && userProfile.id !== request.staffId)) && request.status === 'Pending' && (
                            <>
                                <Button variant="icon-approve" icon="fa-check-circle" onClick={() => onUpdateStatus(request.id, 'Approved')} title="Approve" className="text-xl" />
                                <Button variant="icon-reject" icon="fa-times-circle" onClick={() => onUpdateStatus(request.id, 'Rejected')} title="Reject" className="text-xl" />
                            </>
                        )}
                        <Button variant="icon-edit-alt" icon="fa-edit" onClick={() => onEdit(request)} title="Edit" className="text-xl" />
                        <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(request.id)} title="Delete" className="text-xl" />
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Request Filters Component
        const RequestFilters = memo(({
            title, userProfile, shops, employeesInShop,
            selectedShop, setSelectedShop, selectedEmployeeId, setSelectedEmployeeId,
            filterPeriod, setFilterPeriod, customDate, setCustomDate,
            onNewRequest
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <h3 className="text-xl font-semibold text-slate-100">{title}s</h3>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile.role === 'Admin' || (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile.role === 'Admin' ? 'All Shops' : 'All My Shops'}</option>
                                {(userProfile.role === 'Admin' ? shops : (userProfile.shop || []).map(name => ({ id: name, name: name }))).map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                        {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && selectedShop && (
                            <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Staff</option>
                                {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                            </select>
                        )}
                        {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && (
                            <select value={filterPeriod} onChange={e => setFilterPeriod(e.target.value)} className="select w-full sm:w-auto">
                                <option value="thisWeek">This Week</option><option value="thisMonth">This Month</option>
                                <option value="lastMonth">Last Month</option><option value="thisYear">This Year</option>
                                <option value="custom">Custom Date</option>
                            </select>
                        )}
                        {filterPeriod === 'custom' && (<input type="date" value={customDate} onChange={e => setCustomDate(e.target.value)} className="input w-full sm:w-auto" />)}
                        <Button variant="primary" icon="fa-plus" onClick={onNewRequest}>New Request</Button>
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Pending Requests Grid
        const PendingRequestsGrid = memo(({ requests, userProfile, config, onUpdateStatus, onEdit, onDelete }) => {
            if (requests.length === 0) return null;
            return (
                <div className="mb-8">
                    <h4 className="text-lg font-semibold text-slate-200 mb-4">Pending Requests</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        {requests.map(req => (
                            <RequestCard
                                key={req.id}
                                request={req}
                                userProfile={userProfile}
                                config={config}
                                onUpdateStatus={onUpdateStatus}
                                onEdit={onEdit}
                                onDelete={onDelete}
                            />
                        ))}
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Request History Table
        const RequestHistoryTable = memo(({ requests, title, config, onEdit, onDelete, onViewReason }) => {
            const { tableColumns } = config;
            return (
                <div>
                    <h4 className="text-lg font-semibold text-slate-200 mb-4">{title} History</h4>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    {tableColumns.map(col => <th key={col.header} className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">{col.header}</th>)}
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Reason</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Approval Time</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {requests.map(req => (
                                    <tr key={req.id} className="hover:bg-slate-700/50">
                                        {tableColumns.map(col => <td key={col.header} className="px-4 py-4 text-sm text-slate-300">{typeof col.accessor === 'function' ? col.accessor(req) : req[col.accessor]}</td>)}
                                        <td className="px-4 py-4 text-center text-sm"><Button variant="icon-view" icon="fa-eye" onClick={() => onViewReason(req.reason)} /></td>
                                        <td className="px-4 py-4 text-center text-sm"><span className={`px-2 py-1 text-xs font-semibold rounded-full ${req.status === 'Approved' ? 'bg-green-200 text-green-900' : 'bg-red-200 text-red-900'}`}>{req.status}</span></td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{req.status === 'Approved' ? req.approvalTimestamp || '' : ''}</td>
                                        <td className="px-4 py-4 text-center whitespace-nowrap">
                                            <div className="flex items-center justify-center gap-4">
                                                <Button variant="icon-edit-alt" icon="fa-edit" onClick={() => onEdit(req)} title="Edit" />
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(req.id)} title="Delete" />
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        });

        // Component: Generic Tab for managing requests (Leave, OT, etc.)
        const RequestManagementTab = ({ userProfile, config }) => {
            const { collectionName, title, ModalComponent, dateField, submissionDateField } = config;
            const { db } = useFirebase();
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingRequest, setEditingRequest] = useState(null);
            const [requestToDelete, setRequestToDelete] = useState(null);
            const [reasonToView, setReasonToView] = useState(null);
            const { where } = window.firebaseSDK;
            // REFACTORED: Get global data from context instead of separate collection calls.
            const { shops, employees } = useAppData();
            const [selectedShop, setSelectedShop] = useState('');
            const [filterPeriod, setFilterPeriod] = useState('thisMonth');
            const [customDate, setCustomDate] = useState(new Date().toISOString().slice(0, 10));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');

            // Set initial shop filter based on user role
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            // Define query constraints to fetch requests based on user role
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("staffId", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) return [where("shop", "in", shops)];
                    return [where("staffId", "==", "null")];
                }
                return [where("staffId", "==", userProfile.id)];
            }, [userProfile]);

            const { data: requests } = useCollection(collectionName, queryConstraints);

            // Get employees for the filter dropdown based on selected shop
            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            // Filter and sort requests for display
            const { pendingRequests, historyRequests } = useMemo(() => {
                const filtered = requests.filter(req => {
                    if (!req[dateField]) return false;
                    const now = new Date();
                    let dateMatch = false;
                    switch (filterPeriod) {
                        case 'thisWeek':
                            const startOfWeek = new Date(now);
                            startOfWeek.setDate(now.getDate() - now.getDay());
                            startOfWeek.setHours(0, 0, 0, 0);
                            const endOfWeek = new Date(startOfWeek);
                            endOfWeek.setDate(startOfWeek.getDate() + 6);
                            endOfWeek.setHours(23, 59, 59, 999);
                            const reqDate = new Date(req[dateField]);
                            dateMatch = reqDate >= startOfWeek && reqDate <= endOfWeek;
                            break;
                        // FIX: The following cases now use local date components to avoid timezone errors.
                        case 'thisMonth':
                            const year_tm = now.getFullYear();
                            const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                            dateMatch = req[dateField].startsWith(`${year_tm}-${month_tm}`);
                            break;
                        case 'lastMonth':
                            const lastMonthDate = new Date();
                            lastMonthDate.setMonth(lastMonthDate.getMonth() - 1);
                            const year_lm = lastMonthDate.getFullYear();
                            const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                            dateMatch = req[dateField].startsWith(`${year_lm}-${month_lm}`);
                            break;
                        case 'thisYear':
                            dateMatch = req[dateField].startsWith(now.getFullYear().toString());
                            break;
                        case 'custom':
                            dateMatch = req[dateField] === customDate;
                            break;
                        default:
                            dateMatch = true;
                    }
                    return dateMatch && (!selectedShop || req.shop === selectedShop) && (!selectedEmployeeId || req.staffId === selectedEmployeeId);
                });

                const pending = filtered.filter(req => req.status === 'Pending').sort((a, b) => (b[submissionDateField]?.toDate() || 0) - (a[submissionDateField]?.toDate() || 0));
                const history = filtered.filter(req => req.status !== 'Pending').sort((a, b) => (b[submissionDateField]?.toDate() || 0) - (a[submissionDateField]?.toDate() || 0));
                
                return { pendingRequests: pending, historyRequests: history };
            }, [requests, selectedShop, selectedEmployeeId, filterPeriod, customDate, dateField, submissionDateField]);

            const handleOpenModal = useCallback((request = null) => { setEditingRequest(request); setModalOpen(true); }, []);
            const handleCloseModal = useCallback(() => { setEditingRequest(null); setModalOpen(false); }, []);
            
            const handleSaveRequest = useCallback(async (formData) => {
                const { doc, addDoc, updateDoc, collection, serverTimestamp } = window.firebaseSDK;
                const staffName = employees.find(e => e.id === formData.staffId)?.name || '';
                try {
                    if (formData.id) { 
                        const { id, ...dataToUpdate } = formData; 
                        await updateDoc(doc(db, collectionName, id), { ...dataToUpdate, staffName }); 
                    } else { 
                        const dataToAdd = { ...formData, staffName, status: 'Pending' };
                        dataToAdd[submissionDateField] = serverTimestamp();
                        await addDoc(collection(db, collectionName), dataToAdd); 
                    }
                    handleCloseModal();
                } catch (error) { console.error(`Error saving ${title}:`, error); }
            }, [db, employees, handleCloseModal, collectionName, title, submissionDateField]);

            const handleUpdateRequestStatus = useCallback(async (id, status) => {
                const { doc, updateDoc } = window.firebaseSDK;
                const dataToUpdate = { status };
                if (status === 'Approved') {
                    const now = new Date();
                    const formattedTimestamp = `${String(now.getDate()).padStart(2, '0')}/${String(now.getMonth() + 1).padStart(2, '0')} | ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}`;
                    dataToUpdate.approvalTimestamp = formattedTimestamp;
                }
                try { await updateDoc(doc(db, collectionName, id), dataToUpdate); } 
                catch (error) { console.error(`Error updating status for ${title} ${id}:`, error); }
            }, [db, collectionName, title]);

            const confirmDelete = useCallback(async () => {
                if (!requestToDelete) return;
                try { await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, collectionName, requestToDelete)); } 
                catch (error) { console.error(`Error deleting ${title} ${requestToDelete}:`, error); } 
                finally { setRequestToDelete(null); }
            }, [db, requestToDelete, collectionName, title]);

            return (
                <Card>
                    <RequestFilters
                        title={title}
                        userProfile={userProfile}
                        shops={shops}
                        employeesInShop={employeesInShop}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        selectedEmployeeId={selectedEmployeeId}
                        setSelectedEmployeeId={setSelectedEmployeeId}
                        filterPeriod={filterPeriod}
                        setFilterPeriod={setFilterPeriod}
                        customDate={customDate}
                        setCustomDate={setCustomDate}
                        onNewRequest={() => handleOpenModal()}
                    />
                    <PendingRequestsGrid
                        requests={pendingRequests}
                        userProfile={userProfile}
                        config={config}
                        onUpdateStatus={handleUpdateRequestStatus}
                        onEdit={handleOpenModal}
                        onDelete={setRequestToDelete}
                    />
                    <RequestHistoryTable
                        requests={historyRequests}
                        title={title}
                        config={config}
                        onEdit={handleOpenModal}
                        onDelete={setRequestToDelete}
                        onViewReason={setReasonToView}
                    />
                    {/* REFACTORED: Removed shops and employees props as the modal now gets them from context */}
                    <ModalComponent isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSaveRequest} request={editingRequest} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!requestToDelete} onClose={() => setRequestToDelete(null)} onConfirm={confirmDelete} title={`Delete ${title}`} message={`Are you sure you want to permanently delete this ${title.toLowerCase()}?`} />
                    <Modal isOpen={!!reasonToView} onClose={() => setReasonToView(null)} maxWidth="max-w-md">
                        <ModalHeader title={`${title} Reason`} onClose={() => setReasonToView(null)} />
                        <ModalBody><p className="text-slate-300">{reasonToView}</p></ModalBody>
                        <ModalFooter><Button variant="secondary" onClick={() => setReasonToView(null)}>Close</Button></ModalFooter>
                    </Modal>
                </Card>
            );
        };
        
        // Component: Main CheckInMe Page (Tab Container)
        const CheckInMePage = ({ userProfile, initialTab = 'checkInOut' }) => {
            const [activeTab, setActiveTab] = useState(initialTab);

            useEffect(() => {
                setActiveTab(initialTab);
            }, [initialTab]);
            
            // Define configurations for our generic request management tab
            const leaveRequestConfig = {
                collectionName: 'leaveRequests',
                title: 'Leave Request',
                ModalComponent: LeaveRequestModal,
                dateField: 'leaveDate',
                submissionDateField: 'requestDate',
                cardFields: [
                    { label: 'Leave Date', value: (req) => Utils.formatISOToDisplay(req.leaveDate) },
                    { label: 'Return Date', value: (req) => Utils.formatISOToDisplay(req.returnDate) },
                    { label: 'Days', value: (req) => req.numberOfDays },
                    { label: 'Session', value: (req) => req.leaveSession || '-' },
                    { label: 'Supervisor', value: (req) => req.supervisor },
                    { label: 'Submitted', value: (req) => Utils.formatRequestDate(req.requestDate) },
                    { label: 'Type', value: (req) => req.leaveType },
                ],
                tableColumns: [
                    { header: 'Request Date', accessor: (req) => Utils.formatRequestDate(req.requestDate) },
                    { header: 'Shop', accessor: 'shop' },
                    { header: 'Name', accessor: 'staffName' },
                    { header: 'Leave Date', accessor: (req) => Utils.formatISOToDisplay(req.leaveDate) },
                    { header: 'Return Date', accessor: (req) => Utils.formatISOToDisplay(req.returnDate) },
                    { header: 'No. Days', accessor: 'numberOfDays' },
                    { header: 'Session', accessor: 'leaveSession' },
                    { header: 'Leave Type', accessor: 'leaveType' },
                    { header: 'Supervisor', accessor: 'supervisor' },
                ]
            };
            
            const otRequestConfig = {
                collectionName: 'otRequests',
                title: 'OT Request',
                ModalComponent: OTRequestModal,
                dateField: 'reqDate',
                submissionDateField: 'submissionDate',
                cardFields: [
                    { label: 'OT Date', value: (req) => Utils.formatISOToDisplay(req.reqDate) },
                    { label: 'Days', value: (req) => req.numberOfOTDays },
                    { label: 'Start Time', value: (req) => req.startTime || 'N/A' },
                    { label: 'End Time', value: (req) => req.endTime || 'N/A' },
                    { label: 'Supervisor', value: (req) => req.supervisor },
                    { label: 'Submitted', value: (req) => Utils.formatRequestDate(req.submissionDate) },
                ],
                tableColumns: [
                    { header: 'Request Date', accessor: (req) => Utils.formatRequestDate(req.submissionDate) },
                    { header: 'Shop', accessor: 'shop' },
                    { header: 'Name', accessor: 'staffName' },
                    { header: 'OT Date', accessor: (req) => Utils.formatISOToDisplay(req.reqDate) },
                    { header: 'Start Time', accessor: 'startTime' },
                    { header: 'End Time', accessor: 'endTime' },
                    { header: 'No. OT Days', accessor: 'numberOfOTDays' },
                    { header: 'Supervisor', accessor: 'supervisor' },
                ]
            };

            return (
                <TabbedPage tabs={{ checkInOut: 'Check In/Out', leaveRequest: 'Leave Request', otRequest: 'OT Request', employeeState: 'Engagements / Deductions' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="checkInOut"><CheckInOutTab userProfile={userProfile} /></div>
                    <div id="leaveRequest"><RequestManagementTab userProfile={userProfile} config={leaveRequestConfig} /></div>
                    <div id="otRequest"><RequestManagementTab userProfile={userProfile} config={otRequestConfig} /></div>
                    <div id="employeeState"><EmployeeStateTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };
        // --- END CHECKINME PAGE COMPONENTS ---

        // --- START ATTENDANCE REPORT PAGE ---

        // NEW: Phase 1 Refactoring - Daily Report Filters Component
        const DailyReportFilters = memo(({
            userProfile, selectedShop, setSelectedShop, selectedEmployeeId, setSelectedEmployeeId, availableShops,
            employeesInShop, filterType, setFilterType, customMonth, setCustomMonth,
            selectedShift, setSelectedShift, uniqueShiftNames, onExportExcel
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <CardTitle>Daily Attendance Report</CardTitle>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                        {userProfile?.role !== 'Staff' && selectedShop && (
                            <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Staff</option>
                                {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                            </select>
                        )}
                        <select value={filterType} onChange={e => setFilterType(e.target.value)} className="select w-full sm:w-auto">
                            <option value="today">Today</option>
                            <option value="yesterday">Yesterday</option>
                            <option value="thisMonth">This Month</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="custom">Custom Month</option>
                        </select>
                        {filterType === 'custom' && (
                            <input type="month" value={customMonth} onChange={e => setCustomMonth(e.target.value)} className="input w-full sm:w-auto" />
                        )}
                        <select value={selectedShift} onChange={e => setSelectedShift(e.target.value)} className="select w-full sm:w-auto">
                            <option value="">All Shifts</option>
                            {uniqueShiftNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                            <Button variant="success" icon="fa-file-excel" onClick={onExportExcel}>Excel</Button>
                    </div>
                </div>
            );
        });
        
        // NEW: Phase 1 Refactoring - Daily Report Table Component
        const DailyReportTable = memo(({ attendanceReport, userProfile, onAddCheckOut, onDeleteRecord }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shift</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Check In</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Check Out</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Leave Status</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">OT Status</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {attendanceReport.map((report) => (
                                <tr key={`${report.employeeId}-${report.date}`} className="transition-colors hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.date}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.employeeName}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shift}</td>
                                    <td className={`px-4 py-4 text-sm ${report.isLate ? 'bg-red-900/60 text-red-300 font-semibold' : 'text-slate-300'}`}>{report.checkIn}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.checkOut}</td>
                                    <td className={`px-4 py-4 text-sm text-center ${report.isOnLeave === 'Absent' ? 'text-red-400 font-semibold' : 'text-slate-300'}`}>{report.isOnLeave}</td>
                                    <td className="px-4 py-4 text-sm text-center text-slate-300">{report.otStatus}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && report.checkIn && !report.checkOut && (
                                                <Button variant="icon-add-time" icon="fa-clock" onClick={() => onAddCheckOut(report)} title="Add Check-Out"/>
                                            )}
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && report.docIds.length > 0 && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDeleteRecord(report)} title="Delete" />
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Work Day Report Filters Component
        const WorkDayReportFilters = memo(({
            userProfile, selectedShop, setSelectedShop, selectedEmployeeId, setSelectedEmployeeId, availableShops,
            employeesInShop, filterType, setFilterType, selectedMonth, setSelectedMonth,
            selectedShift, setSelectedShift, uniqueShiftNames, onExportExcel
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <CardTitle>Monthly Work Day Report</CardTitle>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                         {userProfile?.role !== 'Staff' && selectedShop && (
                            <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Staff</option>
                                {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                            </select>
                        )}
                        <select value={filterType} onChange={e => setFilterType(e.target.value)} className="select w-full sm:w-auto">
                            <option value="thisMonth">This Month</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="custom">Custom Month</option>
                        </select>
                        {filterType === 'custom' && (
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm-w-auto" />
                        )}
                        <select value={selectedShift} onChange={e => setSelectedShift(e.target.value)} className="select w-full sm:w-auto">
                            <option value="">All Shifts</option>
                            {uniqueShiftNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                        <Button variant="success" icon="fa-file-excel" onClick={onExportExcel}>Excel</Button>
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Work Day Report Table Component
        const WorkDayReportTable = memo(({ workDayReport }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No. Work Day</th>
                                {/* BUG FIX: Re-add the Given Off Day column header */}
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Given Off Day</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total OT</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total Leave No</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total LATE</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No-CheckOut</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No-Absent</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total-Day</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {workDayReport.map((report, index) => (
                                <tr key={`${report.staffName}-${report.dueTime}-${index}`} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.dueTime}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shopName}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.staffName}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-blue-400">{report.workDays}</td>
                                    {/* BUG FIX: Re-add the Given Off Day data cell */}
                                    <td className="px-4 py-4 text-sm font-semibold text-cyan-400">{report.givenOffDays}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-green-400">{report.totalOT > 0 ? report.totalOT.toFixed(2) : 0}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-yellow-400">{report.totalLeave}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-red-400">{report.totalLate}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-orange-400">{report.noCheckOutCount}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-red-500">{report.noAbsentCount}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-teal-400">{report.totalDay}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

         const AttendanceReportPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('daily');
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;
            const [reportData, setReportData] = useState({ leaveRequests: [], otRequests: [] });
            const [loading, setLoading] = useState(false);

            // PHASE 3 OPTIMIZATION: For Admins/CEOs, we now fetch this data on-demand in the child components.
            // For other roles, we maintain the real-time listener for a better experience on their smaller datasets.
            const isRealTime = userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO';
            
            const staffQueryConstraints = useMemo(() => {
                const { role, id, shop } = userProfile || {};
                if (role === 'Staff' && id) {
                    return [where("staffId", "==", id)];
                }
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        return [where("shop", "in", managedShops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops assigned, so return no results.
                }
                return []; // Admin query is built on-demand.
            }, [userProfile]);
            
            // Real-time data for Staff/Managers
            const { data: realTimeLeaveRequests } = useCollection('leaveRequests', isRealTime ? staffQueryConstraints : []);
            const { data: realTimeOtRequests } = useCollection('otRequests', isRealTime ? staffQueryConstraints : []);
            
            // On-demand data for Admins (passed down)
            const leaveRequests = isRealTime ? realTimeLeaveRequests : reportData.leaveRequests;
            const otRequests = isRealTime ? realTimeOtRequests : reportData.otRequests;

            return (
                <TabbedPage tabs={{ daily: 'Daily Report', monthly: 'No. Work Day' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="daily"><DailyReportTab userProfile={userProfile} leaveRequests={leaveRequests} otRequests={otRequests} setAdminReportData={setReportData} setLoadingAdminReport={setLoading} isAdminLoading={loading} /></div>
                    <div id="monthly"><WorkDayReportTab userProfile={userProfile} leaveRequests={leaveRequests} otRequests={otRequests} setAdminReportData={setReportData} setLoadingAdminReport={setLoading} isAdminLoading={loading} /></div>
                </TabbedPage>
            );
        };

        // NEW: Modal for manually adding a check-out time
        const ManualCheckOutModal = ({ isOpen, onClose, onSave, record }) => {
            const [checkOutTime, setCheckOutTime] = useState('');

            useEffect(() => {
                // Reset time when modal opens for a new record
                if (isOpen) {
                    setCheckOutTime('');
                }
            }, [isOpen]);
            
            const handleSubmit = (e) => {
                e.preventDefault();
                if (record && checkOutTime) {
                    onSave(record, checkOutTime);
                }
            };

            if (!record) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-md">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title="Add Manual Check-Out" onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <input value={record.employeeName} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Date</label>
                                    <input value={record.date} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Check-Out Time</label>
                                    <input
                                        type="time"
                                        value={checkOutTime}
                                        onChange={(e) => setCheckOutTime(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Save Check-Out</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        const DailyReportTab = ({ userProfile, leaveRequests, otRequests, setAdminReportData, setLoadingAdminReport, isAdminLoading }) => {
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;
            const [recordToDelete, setRecordToDelete] = useState(null);
            const [recordToCorrect, setRecordToCorrect] = useState(null);
            const [isCorrectionModalOpen, setCorrectionModalOpen] = useState(false);

            // Filters State
            const [selectedShop, setSelectedShop] = useState('');
            const [filterType, setFilterType] = useState('today');
            const [customMonth, setCustomMonth] = useState(new Date().toISOString().slice(0, 7));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const [selectedShift, setSelectedShift] = useState('');

            // Data State
            const { data: shops } = useCollection('shops');
            const { data: employees } = useCollection('employees');
            const { data: shifts } = useCollection('shifts');
            
            // NEW: Create a unique list of shift names for the filter dropdown to avoid duplicates.
            const uniqueShiftNames = useMemo(() => {
                if (!shifts) return [];
                const shiftNames = shifts.map(s => s.name);
                // Use a Set to get unique names, then spread it back into an array and sort it.
                return [...new Set(shiftNames)].sort();
            }, [shifts]);
            
            // PHASE 3: Data state for Admin's one-time fetches
            const [adminAttendance, setAdminAttendance] = useState([]);
            
            // PHASE 2 & 3: Combined logic for fetching attendance data.
            const isRealTime = userProfile?.role !== 'Admin';
            const attendanceQueryConstraints = useMemo(() => {
                // This is ONLY for real-time listeners (Staff/Manager)
                if (!isRealTime) return []; 
                
                const { role, id, shop } = userProfile || {};
                if (role === 'Staff' && id) return [where("employeeId", "==", id)];
                
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) return [where("shop", "in", managedShops)];
                    return [where("employeeId", "==", "null")];
                }
                return []; // Should not happen for real-time
            }, [userProfile, isRealTime]);
            
            const { data: realTimeAttendance, loading: attendanceLoading } = useCollection('attendance', attendanceQueryConstraints);
            const attendance = isRealTime ? realTimeAttendance : adminAttendance;
            const isReportLoading = isRealTime ? attendanceLoading : isAdminLoading;
            
            // PHASE 3: ON-DEMAND DATA FETCHING FOR ADMIN (OPTIMIZED) ---
            useEffect(() => {
                // This effect now runs whenever the main filters change.
                if (userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO') return;

                const fetchAdminData = async () => {
                    setLoadingAdminReport(true);
                    
                    const startDate = new Date();
                    const endDate = new Date();
                    
                    // Logic to determine date range based on filterType
                    switch (filterType) {
                        case 'today': startDate.setHours(0, 0, 0, 0); endDate.setHours(23, 59, 59, 999); break;
                        case 'yesterday': startDate.setDate(startDate.getDate() - 1); startDate.setHours(0, 0, 0, 0); endDate.setDate(endDate.getDate() - 1); endDate.setHours(23, 59, 59, 999); break;
                        case 'thisMonth': startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setMonth(endDate.getMonth() + 1); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                        case 'lastMonth': startDate.setMonth(startDate.getMonth() - 1); startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                        case 'custom': const [year, month] = customMonth.split('-').map(Number); if (year && month) { startDate.setFullYear(year, month - 1, 1); startDate.setHours(0, 0, 0, 0); endDate.setFullYear(year, month, 0); endDate.setHours(23, 59, 59, 999); } break;
                    }
                    
                    // --- Build Queries with Filters ---
                    // Start with base date-range queries.
                    let attendanceQuery = query(collection(db, 'attendance'), where('timestamp', '>=', startDate), where('timestamp', '<=', endDate));
                    let leaveQuery = query(collection(db, 'leaveRequests'), where('leaveDate', '<=', endDate.toISOString().slice(0, 10)));
                    let otQuery = query(collection(db, 'otRequests'), where('reqDate', '>=', startDate.toISOString().slice(0, 10)), where('reqDate', '<=', endDate.toISOString().slice(0, 10)));
                    
                    try {
                        const [attSnap, leaveSnap, otSnap] = await Promise.all([
                            getDocs(attendanceQuery),
                            getDocs(leaveQuery),
                            getDocs(otQuery)
                        ]);
                        
                        // FIX: Apply shop/employee filters on the client-side to prevent index errors
                        const attendanceData = attSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || rec.employeeId === selectedEmployeeId;
                                return shopMatch && empMatch;
                            });
                        setAdminAttendance(attendanceData);
                        
                        const leaveData = leaveSnap.docs.map(d => ({ id: d.id, ...d.data() }))
                            .filter(lr => {
                                const shopMatch = !selectedShop || lr.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || lr.staffId === selectedEmployeeId;
                                const dateMatch = lr.returnDate >= startDate.toISOString().slice(0, 10);
                                return shopMatch && empMatch && dateMatch;
                            });

                        const otData = otSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || rec.staffId === selectedEmployeeId;
                                return shopMatch && empMatch;
                            });
                        
                        setAdminReportData({
                            leaveRequests: leaveData,
                            otRequests: otData
                        });

                    } catch (error) {
                        console.error("Error fetching admin report data:", error);
                    } finally {
                        setLoadingAdminReport(false);
                    }
                };
                
                fetchAdminData();

            }, [userProfile, filterType, customMonth, selectedShop, selectedEmployeeId, db, setLoadingAdminReport, setAdminReportData]);

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    // For managers with multiple shops, default to showing all their shops.
                    // For single-shop users, their shop is pre-selected.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Admins see all shops, Managers see their assigned shops for filtering.
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return []; // Not used for other roles in the UI dropdown
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const attendanceReport = useMemo(() => {
                // --- START PERFORMANCE FIX ---
                // This entire block is refactored for efficiency.
                const startDate = new Date();
                const endDate = new Date();

                // 1. Determine Date Range from Filters
                switch (filterType) {
                    case 'today': startDate.setHours(0, 0, 0, 0); endDate.setHours(23, 59, 59, 999); break;
                    case 'yesterday': startDate.setDate(startDate.getDate() - 1); startDate.setHours(0, 0, 0, 0); endDate.setDate(endDate.getDate() - 1); endDate.setHours(23, 59, 59, 999); break;
                    case 'thisMonth': startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setMonth(endDate.getMonth() + 1); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                    case 'lastMonth': startDate.setMonth(startDate.getMonth() - 1); startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                    case 'custom': const [year, month] = customMonth.split('-').map(Number); if (year && month) { startDate.setFullYear(year, month - 1, 1); startDate.setHours(0, 0, 0, 0); endDate.setFullYear(year, month, 0); endDate.setHours(23, 59, 59, 999); } break;
                }

                // 2. Get a list of employees to report on, based on user role and filters.
                const relevantEmployees = employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : (emp.shop ? [emp.shop] : []);
                    const userManagedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);

                    let roleMatch = false;
                    if (userProfile.role === 'Admin' || userProfile.role === 'CEO') roleMatch = true;
                    else if (userProfile.role === 'Shop Manager') roleMatch = employeeShops.some(s => userManagedShops.includes(s));
                    else roleMatch = emp.id === userProfile.id;

                    const shopMatch = !selectedShop || employeeShops.includes(selectedShop);
                    const shiftMatch = !selectedShift || emp.shift === selectedShift;
                    return emp.status === 'Active' && roleMatch && shopMatch && (!selectedEmployeeId || emp.id === selectedEmployeeId) && shiftMatch && emp.role !== 'Admin' && emp.role !== 'CEO';
                });
                
                // --- START BUG FIX ---
                // Create a Set of relevant employee IDs for efficient lookup.
                const relevantEmployeeIds = new Set(relevantEmployees.map(e => e.id));

                // 3. Process ONLY the available attendance data.
                const reportMap = new Map();
                attendance.forEach(record => {
                    // Only process records for employees who match the current filters (including shift).
                    if (!relevantEmployeeIds.has(record.employeeId)) return;
                    
                    if (!record.timestamp) return;
                    const recordDate = record.timestamp.toDate();
                    if (!(recordDate >= startDate && recordDate <= endDate)) return;

                    const recordShop = shops.find(s => s.name === record.shop);
                    const { localDate: dateKey } = Utils.formatDateInTimezone(record.timestamp, recordShop?.timezone);
                    const reportKey = `${record.employeeId}_${dateKey}`;

                    if (!reportMap.has(reportKey)) {
                        reportMap.set(reportKey, {
                            date: dateKey,
                            employeeId: record.employeeId,
                            checkInRecords: [],
                            checkOutRecords: [],
                            docIds: []
                        });
                    }
                    
                    const entry = reportMap.get(reportKey);
                    // FIX: Store the full record object (date and shop) instead of just the date.
                    // This allows us to track where check-ins and check-outs happened.
                    const recordData = { date: record.timestamp.toDate(), shop: record.shop };
                    if (record.type === 'in') entry.checkInRecords.push(recordData);
                    if (record.type === 'out') entry.checkOutRecords.push(recordData);
                    entry.docIds.push(record.id);
                });
                // --- END BUG FIX ---

                // 4. Intelligently add absent days for past and present dates.
                const today = new Date();
                today.setHours(0,0,0,0);
                const currentDate = new Date(startDate);
                // FIX: Changed condition from `< today` to `<= today` to include the current day
                // when checking for absent employees. This ensures the "Today" filter shows everyone.
                while(currentDate <= endDate && currentDate <= today) {
                    const dateKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}`;
                    for (const employee of relevantEmployees) {
                         const reportKey = `${employee.id}_${dateKey}`;
                         if (!reportMap.has(reportKey)) {
                            // FIX: Always add an entry for an employee who has no attendance record on a past day.
                            // The finalization step (step 5) will correctly determine if they were on approved leave or were absent.
                            // The previous logic incorrectly filtered out employees on approved leave at this stage.
                            reportMap.set(reportKey, {
                                date: dateKey, employeeId: employee.id,
                                checkInRecords: [], checkOutRecords: [], docIds: []
                            });
                         }
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                // 5. Finalize calculations for each entry.
                const reportArray = Array.from(reportMap.values()).map(entry => {
                    const employee = employees.find(e => e.id === entry.employeeId);
                    if (!employee) return null; // Skip if employee not found

                    // FIX: Find the earliest check-in and latest check-out record objects
                    // to get both their time and their specific shop location.
                    const firstCheckInRecord = entry.checkInRecords.length > 0
                        ? entry.checkInRecords.reduce((earliest, current) => current.date < earliest.date ? current : earliest)
                        : null;
                    const lastCheckOutRecord = entry.checkOutRecords.length > 0
                        ? entry.checkOutRecords.reduce((latest, current) => current.date > latest.date ? current : latest)
                        : null;

                    const checkIn = firstCheckInRecord ? firstCheckInRecord.date : null;
                    const checkOut = lastCheckOutRecord ? lastCheckOutRecord.date : null;
                    
                    const shopDetails = shops.find(s => s.name === (firstCheckInRecord?.shop || (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop)));
                    const shopTimezone = shopDetails?.timezone;

                    let isLate = false;
                    if (checkIn && employee) {
                        const shiftDetails = (shifts || []).find(s => s.name === employee.shift && s.shopName === firstCheckInRecord.shop);
                        if (shiftDetails?.lateThreshold) {
                            const [lateHour, lateMinute] = shiftDetails.lateThreshold.split(':').map(Number);
                            const timeInZoneString = checkIn.toLocaleTimeString('en-GB', { timeZone: shopTimezone, hour: '2-digit', minute: '2-digit' });
                            const [checkInHour, checkInMinute] = timeInZoneString.split(':').map(Number);
                            if (checkInHour > lateHour || (checkInHour === lateHour && checkInMinute > lateMinute)) {
                                isLate = true;
                            }
                        }
                    }

                    const approvedLeave = leaveRequests.find(lr => lr.staffId === employee.id && lr.status === 'Approved' && entry.date >= lr.leaveDate && entry.date < lr.returnDate);
                    let isOnLeave; // Start undefined

                    if (approvedLeave) {
                        // Case 1: Employee is on approved leave.
                        isOnLeave = approvedLeave.leaveSession === 'Full Day' ? 'Y-Full Day' : `Y-${approvedLeave.leaveSession}`;
                    } else if (checkIn || checkOut) {
                        // Case 2: Employee has check-in/out records, so they are not on leave.
                        isOnLeave = 'N';
                    } else {
                        // Case 3: No approved leave and no attendance.
                        // Check if we are still loading data before declaring them absent.
                        if (isReportLoading) {
                            isOnLeave = '-'; // Neutral state during load
                        } else {
                            isOnLeave = 'Absent'; // Confirmed absence after load
                        }
                    }

                    const isOnOT = otRequests.some(ot => ot.staffId === employee.id && ot.status === 'Approved' && ot.reqDate === entry.date);
                    const otStatus = isOnOT ? 'Y' : 'N';
                    
                    const { localTime: checkInTimeStr } = checkIn ? Utils.formatDateInTimezone({ toDate: () => checkIn }, shopTimezone) : { localTime: '' };
                    const { localTime: checkOutTimeStr } = checkOut ? Utils.formatDateInTimezone({ toDate: () => checkOut }, shopTimezone) : { localTime: '' };
                    
                    // FIX: Create a more informative shop display for multi-shop activity.
                    let shopDisplay = Array.isArray(employee.shop) ? employee.shop.join(', ') : employee.shop;
                    if (firstCheckInRecord && lastCheckOutRecord) {
                        if (firstCheckInRecord.shop === lastCheckOutRecord.shop) {
                            shopDisplay = firstCheckInRecord.shop;
                        } else {
                            shopDisplay = `${firstCheckInRecord.shop} (In) → ${lastCheckOutRecord.shop} (Out)`;
                        }
                    } else if (firstCheckInRecord) {
                        shopDisplay = firstCheckInRecord.shop;
                    } else if (lastCheckOutRecord) {
                        shopDisplay = lastCheckOutRecord.shop; // For a checkout-only record
                    }

                    return {
                        date: entry.date,
                        employeeId: employee.id,
                        employeeName: employee.name,
                        shop: shopDisplay,
                        shift: employee.shift,
                        checkIn: checkInTimeStr,
                        checkOut: checkOutTimeStr,
                        isLate, isOnLeave, otStatus, docIds: entry.docIds
                    };
                }).filter(Boolean);
                
                // 6. Sort and return.
                return reportArray.sort((a, b) => (a.shop || '').localeCompare(b.shop || '') || b.date.localeCompare(a.date) || a.employeeName.localeCompare(b.employeeName));
                // --- END PERFORMANCE FIX ---
            }, [attendance, selectedShop, filterType, customMonth, selectedEmployeeId, employees, leaveRequests, otRequests, selectedShift, shops, shifts, userProfile, isReportLoading]);

            const handleDelete = async () => {
                if (!recordToDelete?.docIds) return;
                const { doc, writeBatch } = window.firebaseSDK;
                const batch = writeBatch(db);
                // Delete all attendance docs for that employee on that day
                recordToDelete.docIds.forEach(id => batch.delete(doc(db, 'attendance', id)));
                try { await batch.commit(); } catch (error) { console.error("Error deleting attendance records: ", error); } 
                finally { setRecordToDelete(null); }
            };

            const handleOpenCorrectionModal = useCallback((record) => {
                setRecordToCorrect(record);
                setCorrectionModalOpen(true);
            }, []);

            const handleCloseCorrectionModal = useCallback(() => {
                setRecordToCorrect(null);
                setCorrectionModalOpen(false);
            }, []);
            
            const handleSaveCheckOut = useCallback(async (record, time) => {
                const { addDoc, collection } = window.firebaseSDK;
                const [hour, minute] = time.split(':');
                
                // Important: Use the date from the record and combine it with the new time.
                // The record.date is a string 'YYYY-MM-DD'.
                const checkOutDateTime = new Date(`${record.date}T${time}:00`);

                try {
                    await addDoc(collection(db, 'attendance'), {
                        employeeId: record.employeeId,
                        employeeName: record.employeeName,
                        shop: record.shop,
                        timestamp: checkOutDateTime, // Use the combined date-time object
                        type: 'out',
                        location: { manualEntry: true, note: 'Added by Admin' }
                    });
                    handleCloseCorrectionModal();
                } catch (error) {
                    console.error("Error saving manual check-out:", error);
                    alert("Failed to save the manual check-out time.");
                }
            }, [db, handleCloseCorrectionModal]);

            const handleExportExcel = useCallback(() => {
                const dataToExport = attendanceReport.map(report => ({
                    'Date': report.date,
                    'Shop Name': report.shop,
                    'Staff Name': report.employeeName,
                    'Shift': report.shift,
                    'Check In': report.checkIn,
                    'Check Out': report.checkOut,
                    'On Leave': report.isOnLeave,
                    'OT Status': report.otStatus,
                    'Late Check-In': report.isLate ? 'Yes' : 'No'
                }));

                const getReportFilename = () => {
                    const todayStr = new Date().toISOString().slice(0, 10);
                    switch (filterType) {
                        case 'today': return `Daily_Attendance_Report_Today_${todayStr}.xlsx`;
                        case 'yesterday': 
                            const yesterday = new Date();
                            yesterday.setDate(yesterday.getDate() - 1);
                            return `Daily_Attendance_Report_Yesterday_${yesterday.toISOString().slice(0, 10)}.xlsx`;
                        case 'thisMonth': return `Daily_Attendance_Report_ThisMonth_${new Date().toISOString().slice(0, 7)}.xlsx`;
                        case 'lastMonth': 
                            const lastMonth = new Date();
                            lastMonth.setMonth(lastMonth.getMonth() - 1);
                            return `Daily_Attendance_Report_LastMonth_${lastMonth.toISOString().slice(0, 7)}.xlsx`;
                        case 'custom': return `Daily_Attendance_Report_${customMonth}.xlsx`;
                        default: return 'Daily_Attendance_Report.xlsx';
                    }
                };

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Daily Attendance");

                worksheet["!cols"] = [ { wch: 12 }, { wch: 15 }, { wch: 25 }, { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 15 } ];
                
                XLSX.writeFile(workbook, getReportFilename());
            }, [attendanceReport, filterType, customMonth]);

            return (
                <Card>
                    <DailyReportFilters
                        userProfile={userProfile}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        selectedEmployeeId={selectedEmployeeId}
                        setSelectedEmployeeId={setSelectedEmployeeId}
                        availableShops={availableShops}
                        employeesInShop={employeesInShop}
                        filterType={filterType}
                        setFilterType={setFilterType}
                        customMonth={customMonth}
                        setCustomMonth={setCustomMonth}
                        selectedShift={selectedShift}
                        setSelectedShift={setSelectedShift}
                        uniqueShiftNames={uniqueShiftNames}
                        onExportExcel={handleExportExcel}
                    />
                    <DailyReportTable
                        attendanceReport={attendanceReport}
                        userProfile={userProfile}
                        onAddCheckOut={handleOpenCorrectionModal}
                        onDeleteRecord={setRecordToDelete}
                    />
                    <ConfirmationModal isOpen={!!recordToDelete} onClose={() => setRecordToDelete(null)} onConfirm={handleDelete} title="Delete Attendance Record" message={`Are you sure you want to delete all attendance records for ${recordToDelete?.employeeName} on ${recordToDelete?.date}? This action cannot be undone.`} />
                    <ManualCheckOutModal isOpen={isCorrectionModalOpen} onClose={handleCloseCorrectionModal} onSave={handleSaveCheckOut} record={recordToCorrect} />
                </Card>
            );
        };
        
        const WorkDayReportTab = ({ userProfile, leaveRequests, otRequests, setAdminReportData, setLoadingAdminReport, isAdminLoading }) => {
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;

            // Filter States
            const [selectedShop, setSelectedShop] = useState('');
            const [filterType, setFilterType] = useState('thisMonth');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const [selectedShift, setSelectedShift] = useState(''); // NEW: State for shift filter

            // Data States
            const { data: shops } = useCollection('shops');
            const { data: employees } = useCollection('employees');
            const { data: shifts } = useCollection('shifts'); // NEW: Get shifts data

            // NEW: Get unique shift names for the filter dropdown
            const uniqueShiftNames = useMemo(() => {
                if (!shifts) return [];
                const shiftNames = shifts.map(s => s.name);
                return [...new Set(shiftNames)].sort();
            }, [shifts]);
            
            // PHASE 3: Data states for Admin's one-time fetches
            const [adminAttendance, setAdminAttendance] = useState([]);
            const [adminEmployeeStates, setAdminEmployeeStates] = useState([]);

            // PHASE 2 & 3: Combined logic for fetching data.
            const isRealTime = userProfile?.role !== 'Admin';
            
            const realTimeQueryConstraints = useMemo(() => {
                if (!isRealTime) return { attendance: [], employeeStates: [] };
                const { role, id, shop } = userProfile || {};
                
                let attendanceCons = [], statesCons = [];

                if (role === 'Staff' && id) {
                    attendanceCons = [where("employeeId", "==", id)];
                    statesCons = [where("staffId", "==", id)];
                } else if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        attendanceCons = [where("shop", "in", managedShops)];
                        statesCons = [where("shop", "in", managedShops)];
                    } else {
                        attendanceCons = [where("employeeId", "==", "null")];
                        statesCons = [where("staffId", "==", "null")];
                    }
                }
                return { attendance: attendanceCons, employeeStates: statesCons };
            }, [userProfile, isRealTime]);

            const { data: realTimeAttendance } = useCollection('attendance', realTimeQueryConstraints.attendance);
            const { data: realTimeEmployeeStates } = useCollection('employeeStates', realTimeQueryConstraints.employeeStates);
            
            const attendance = isRealTime ? realTimeAttendance : adminAttendance;
            const employeeStates = isRealTime ? realTimeEmployeeStates : adminEmployeeStates;

             // --- PHASE 3: ON-DEMAND DATA FETCHING FOR ADMIN ---
            useEffect(() => {
                if (userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO') return;

                const fetchAdminData = async () => {
                    setLoadingAdminReport(true);
                    
                    let targetMonth;
                    const now = new Date();
                    switch (filterType) {
                        case 'lastMonth': const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1); targetMonth = `${lastMonthDate.getFullYear()}-${String(lastMonthDate.getMonth() + 1).padStart(2, '0')}`; break;
                        case 'custom': targetMonth = selectedMonth; break;
                        default: targetMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`; break;
                    }

                    const startDate = `${targetMonth}-01`;
                    const endDate = `${targetMonth}-31`; // Firestore handles date strings correctly

                    // --- Build Queries with Filters ---
                    // Start with base date-range queries.
                    let attendanceQuery = query(collection(db, 'attendance'), where('timestamp', '>=', new Date(startDate)), where('timestamp', '<=', new Date(endDate + "T23:59:59")));
                    let statesQuery = query(collection(db, 'employeeStates'), where('date', '>=', startDate), where('date', '<=', endDate));
                    let leaveQuery = query(collection(db, 'leaveRequests'), where('leaveDate', '<=', endDate));
                    let otQuery = query(collection(db, 'otRequests'), where('reqDate', '>=', startDate), where('reqDate', '<=', endDate));
                    
                    try {
                        const [attSnap, statesSnap, leaveSnap, otSnap] = await Promise.all([ getDocs(attendanceQuery), getDocs(statesQuery), getDocs(leaveQuery), getDocs(otQuery) ]);
                        
                        // FIX: Apply shop/employee filters on the client-side to prevent index errors
                        const attendanceData = attSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || rec.employeeId === selectedEmployeeId;
                                return shopMatch && empMatch;
                            });
                        setAdminAttendance(attendanceData);

                        const statesData = statesSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || rec.staffId === selectedEmployeeId;
                                return shopMatch && empMatch;
                            });
                        setAdminEmployeeStates(statesData);
                        
                        const leaveData = leaveSnap.docs.map(d => ({ id: d.id, ...d.data() }))
                            .filter(lr => {
                                const shopMatch = !selectedShop || lr.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || lr.staffId === selectedEmployeeId;
                                const dateMatch = lr.returnDate >= startDate;
                                return shopMatch && empMatch && dateMatch;
                            });
                        
                        const otData = otSnap.docs.map(d => ({id: d.id, ...d.data()}))
                             .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                const empMatch = !selectedEmployeeId || rec.staffId === selectedEmployeeId;
                                return shopMatch && empMatch;
                            });

                        setAdminReportData({
                            leaveRequests: leaveData,
                            otRequests: otData
                        });

                    } catch (error) {
                        console.error("Error fetching admin work day report data:", error);
                    } finally {
                        setLoadingAdminReport(false);
                    }
                };
                
                fetchAdminData();

            }, [userProfile, filterType, selectedMonth, selectedShop, selectedEmployeeId, db, setLoadingAdminReport, setAdminReportData]);

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                     // For managers with multiple shops, default to showing all their shops.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            // Admins see all shops, Managers see their assigned shops for filtering.
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return []; // Not used for other roles in the UI dropdown
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const workDayReport = useMemo(() => {
                let targetMonth;
                const now = new Date();
                switch (filterType) {
                    case 'lastMonth':
                        const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                        const year_lm = lastMonthDate.getFullYear();
                        const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                        targetMonth = `${year_lm}-${month_lm}`;
                        break;
                    case 'custom':
                        targetMonth = selectedMonth;
                        break;
                    case 'thisMonth':
                    default:
                        const year_tm = now.getFullYear();
                        const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                        targetMonth = `${year_tm}-${month_tm}`;
                        break;
                }

                // 1. Determine which employees to generate a report for based on filters
                const employeesToReportOn = employees.filter(emp => {
                    if (emp.status !== 'Active') return false;

                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : (emp.shop ? [emp.shop] : []);
                    const userManagedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);

                    let roleMatch = false;
                    if (userProfile.role === 'Admin' || userProfile.role === 'CEO') roleMatch = true;
                    else if (userProfile.role === 'Shop Manager') roleMatch = employeeShops.some(s => userManagedShops.includes(s));
                    else roleMatch = emp.id === userProfile.id; // Staff see only themselves
                    
                    const shopFilterMatch = !selectedShop || employeeShops.includes(selectedShop);
                    const employeeFilterMatch = !selectedEmployeeId || emp.id === selectedEmployeeId;
                    const shiftFilterMatch = !selectedShift || emp.shift === selectedShift; // NEW: Add shift filter condition

                    return roleMatch && shopFilterMatch && employeeFilterMatch && shiftFilterMatch && emp.role !== 'Admin' && emp.role !== 'CEO'; // NEW: Apply shift filter
                });
                
                // 2. Generate a report row for each of those employees
                const report = employeesToReportOn.map(employee => {
                    const employeeShopName = Array.isArray(employee.shop) ? employee.shop[0] : employee.shop;
                    const employeeShop = shops.find(s => s.name === employeeShopName);
                    const employeeShopTimezone = employeeShop?.timezone;

                    const monthAttendance = attendance.filter(r => r.employeeId === employee.id && r.timestamp?.toDate().toISOString().startsWith(targetMonth));
                    const monthLeave = leaveRequests.filter(r => r.staffId === employee.id && r.status === 'Approved' && r.leaveDate.startsWith(targetMonth));
                    const monthOT = otRequests.filter(r => r.staffId === employee.id && r.status === 'Approved' && r.reqDate.startsWith(targetMonth));
                    const monthStates = employeeStates.filter(r => r.staffId === employee.id && r.date.startsWith(targetMonth));

                    const totalLeave = monthLeave.reduce((sum, r) => sum + (parseFloat(r.numberOfDays) || 0), 0);
                    const totalOT = monthOT.reduce((sum, r) => sum + (parseFloat(r.numberOfOTDays) || 0), 0);
                    // FIX: Use the more specific 'CheckIn Late @' to be consistent with the payroll calculation.
                    const totalLate = monthStates.filter(es => es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @')).length;
                    
                    const dailyRecords = {};
                    monthAttendance.forEach(rec => {
                        const { localDate: dayKey } = Utils.formatDateInTimezone(rec.timestamp, employeeShopTimezone);
                        if (!dailyRecords[dayKey]) dailyRecords[dayKey] = [];
                        dailyRecords[dayKey].push({ date: rec.timestamp.toDate(), type: rec.type });
                    });
                    
                    let workDays = 0;
                    let noCheckOutCount = 0;
                    const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => new Date() }, employeeShopTimezone);

                    Object.entries(dailyRecords).forEach(([dayKey, dayRecs]) => {
                        const ins = dayRecs.filter(r => r.type === 'in').sort((a,b) => a.date - b.date);
                        const outs = dayRecs.filter(r => r.type === 'out').sort((a,b) => b.date - a.date);
                        if (ins.length > 0 && outs.length > 0) {
                            const diffHours = (outs[0].date.getTime() - ins[0].date.getTime()) / 3600000;
                            if (diffHours >= 7) workDays += 1;
                            else if (diffHours >= 4) workDays += 0.5;
                        } else if (ins.length > 0 && dayKey < todayStr) {
                            noCheckOutCount += 1;
                        }
                    });

                    const [year, month] = targetMonth.split('-').map(Number);
                    const daysInMonth = new Date(year, month, 0).getDate();
                    const attendedDays = new Set(Object.keys(dailyRecords));
                    let noAbsentCount = 0;

                    for (let day = 1; day <= daysInMonth; day++) {
                        const dayKey = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        if (dayKey >= todayStr) break;
                        if (!attendedDays.has(dayKey)) {
                            const isOnLeave = monthLeave.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                            if (!isOnLeave) noAbsentCount++;
                        }
                    }

                    // BUG FIX: Re-add the "Given Off Day" calculation
                    const givenOffDays = Math.floor(workDays / 6.5);
                    // BUG FIX: Correct the "Total-Day" calculation to include given off days
                    const totalDay = workDays + givenOffDays + totalLeave;
                    const [reportYear, reportMonth] = targetMonth.split('-');

                    return { 
                        dueTime: `${reportMonth}-${reportYear.substring(2)}`, 
                        shopName: employeeShopName, 
                        staffName: employee.name, 
                        workDays, 
                        givenOffDays, // Re-add to the returned object
                        totalOT, 
                        totalLeave, 
                        totalLate, 
                        noCheckOutCount, 
                        noAbsentCount, 
                        totalDay
                    };
                });
                
                return report.sort((a, b) => (a.shopName || '').localeCompare(b.shopName || '') || (a.staffName || '').localeCompare(b.staffName || ''));

            }, [attendance, leaveRequests, otRequests, employeeStates, employees, shops, filterType, selectedMonth, selectedShop, selectedEmployeeId, userProfile, selectedShift]); // NEW: Add selectedShift to dependencies

            const handleExportExcel = useCallback(() => {
                const dataToExport = workDayReport.map(rec => ({
                    'Due Time (MM-YY)': rec.dueTime,
                    'Shop Name': rec.shopName,
                    'Staff Name': rec.staffName,
                    'No. Work Day': rec.workDays,
                    'Given Off Day': rec.givenOffDays, // BUG FIX: Re-add to Excel export
                    'Total OT': rec.totalOT,
                    'Total Leave No': rec.totalLeave,
                    'Total LATE': rec.totalLate,
                    'No-CheckOut': rec.noCheckOutCount,
                    'No-Absent': rec.noAbsentCount,
                    'Total-Day': rec.totalDay,
                }));

                const getReportFilename = () => {
                    const now = new Date();
                    switch (filterType) {
                        case 'thisMonth':
                            const year_tm = now.getFullYear();
                            const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                            return `Monthly_Work_Day_Report_${year_tm}-${month_tm}.xlsx`;
                        case 'lastMonth': 
                            const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                            const year_lm = lastMonthDate.getFullYear();
                            const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                            return `Monthly_Work_Day_Report_${year_lm}-${month_lm}.xlsx`;
                        case 'custom': return `Monthly_Work_Day_Report_${selectedMonth}.xlsx`;
                        default: return 'Monthly_Work_Day_Report.xlsx';
                    }
                };

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Monthly Work Day Report");
                
                worksheet["!cols"] = [ { wch: 18 }, { wch: 20 }, { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 } ]; // Adjust column widths
                
                XLSX.writeFile(workbook, getReportFilename());
            }, [workDayReport, filterType, selectedMonth]);

            return (
                <Card>
                    <WorkDayReportFilters
                        userProfile={userProfile}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        setSelectedEmployeeId={setSelectedEmployeeId}
                        availableShops={availableShops}
                        employeesInShop={employeesInShop}
                        filterType={filterType}
                        setFilterType={setFilterType}
                        selectedMonth={selectedMonth}
                        setSelectedMonth={setSelectedMonth}
                        selectedShift={selectedShift}
                        setSelectedShift={setSelectedShift}
                        uniqueShiftNames={uniqueShiftNames}
                        onExportExcel={handleExportExcel}
                    />
                    <WorkDayReportTable workDayReport={workDayReport} />
                </Card>
            );
        };
        // --- END ATTENDANCE REPORT PAGE ---

        // --- START LOAN MANAGER PAGE ---
        const LoanManagerPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('management');
            return (
                <TabbedPage tabs={{ management: 'Loan Management', history: 'Loan History' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="management"><LoanManagementTab userProfile={userProfile} /></div>
                    <div id="history"><LoanHistoryTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };

        const LoanManagementTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingLoan, setEditingLoan] = useState(null);
            const [loanToDelete, setLoanToDelete] = useState(null);
            const { where } = window.firebaseSDK;
            
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) {
                        return [where("shop", "in", shops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops, no data
                }
                return [where("shop", "==", userProfile.shop || null)];
            }, [userProfile]);

            const { data: loans } = useCollection('staffLoans', queryConstraints);
            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();
            const [selectedShop, setSelectedShop] = useState(''); // For the modal's employee list
            const [formData, setFormData] = useState({});
            const [filterShop, setFilterShop] = useState(''); // For filtering the main list
            const [searchTerm, setSearchTerm] = useState(''); // State for the search input

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setFilterShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShopsForFilter = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const filteredLoans = useMemo(() => {
                return loans.filter(loan =>
                    (!filterShop || loan.shop === filterShop) &&
                    (loan.staffName.toLowerCase().includes(searchTerm.toLowerCase()))
                );
            }, [loans, filterShop, searchTerm]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);
            
            const availableShopsForModal = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const canSelectShopInModal = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager';

            const handleOpenModal = (loan = null) => {
                setEditingLoan(loan);
                let initialShop = '';
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
                    if (managedShops.length === 1) initialShop = managedShops[0];
                } else if (userProfile.role !== 'Admin') {
                    initialShop = userProfile.shop || '';
                }

                const initialData = loan ? { ...loan } : { loanDate: new Date().toISOString().substring(0, 10), effectiveDate: new Date().toISOString().substring(0, 10), shop: initialShop, staffId: '', loanAmount: '', agreedMonthlyDeduction: '', reason: '', totalPaid: 0, status: 'Active' };
                setFormData(initialData);
                setSelectedShop(initialData.shop || '');
                setModalOpen(true);
            };

            const handleCloseModal = () => { setModalOpen(false); setEditingLoan(null); };
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
                if (name === 'shop') { setSelectedShop(value); setFormData(prev => ({...prev, staffId: ''})); }
            };
            const handleSave = async () => {
                const { addDoc, updateDoc, doc, collection } = window.firebaseSDK;
                const dataToSave = { ...formData, loanAmount: parseFloat(formData.loanAmount) || 0, agreedMonthlyDeduction: parseFloat(formData.agreedMonthlyDeduction) || 0, staffName: employees.find(e => e.id === formData.staffId)?.name || '' };
                try {
                    if (editingLoan) { await updateDoc(doc(db, 'staffLoans', editingLoan.id), dataToSave); } 
                    else { await addDoc(collection(db, 'staffLoans'), dataToSave); }
                    handleCloseModal();
                } catch (error) { console.error("Error saving loan:", error); }
            };
            const confirmDelete = async () => {
                if (!loanToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'staffLoans', loanToDelete.id));
                } catch (error) { 
                    console.error("Error deleting loan:", error); 
                } finally {
                    setLoanToDelete(null);
                }
            };
            
            return (
                 <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Loan Management</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input
                                type="text"
                                placeholder="Search by staff name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={filterShop} onChange={e => setFilterShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add New Loan</Button>
                        </div>
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Loan Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Effective Date</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Loan Amount</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Agreed Amount</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Paid</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Balance</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{filteredLoans.map(loan => { const balance = loan.loanAmount - loan.totalPaid; return (<tr key={loan.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{loan.staffName}</td><td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(loan.loanDate)}</td><td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(loan.effectiveDate)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.loanAmount)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.agreedMonthlyDeduction)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.totalPaid)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(balance)}</td><td className="px-4 py-4 text-center text-sm"><span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${balance <= 0 ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}`}>{balance <= 0 ? 'Paid Off' : 'Active'}</span></td><td className="px-4 py-4 text-center whitespace-nowrap"><div className="flex items-center justify-center gap-4"><Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(loan)} title="Edit" /><Button variant="icon-delete" icon="fa-trash" onClick={() => setLoanToDelete(loan)} title="Delete" /></div></td></tr>); })}</tbody></table></div>
                    <Modal isOpen={isModalOpen} onClose={handleCloseModal}><ModalHeader title={editingLoan ? "Edit Loan" : "Add New Loan"} onClose={handleCloseModal} /><ModalBody><div className="space-y-4"><div><label className="text-sm">Shop</label><select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={!canSelectShopInModal}><option value="">Select Shop</option>{availableShopsForModal.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}</select></div><div><label className="text-sm">Staff</label><select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" disabled={!selectedShop}><option value="">Select Staff</option>{employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}</select></div><div><label className="text-sm">Loan Date</label><input type="date" name="loanDate" value={formData.loanDate || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Effective Date</label><input type="date" name="effectiveDate" value={formData.effectiveDate || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Loan Amount</label><input type="number" name="loanAmount" value={formData.loanAmount || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Agreed Monthly Deduction</label><input type="number" name="agreedMonthlyDeduction" value={formData.agreedMonthlyDeduction || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3"></textarea></div></div></ModalBody><ModalFooter><Button variant="secondary" onClick={handleCloseModal}>Cancel</Button><Button variant="primary" onClick={handleSave} className="px-6">Save Loan</Button></ModalFooter></Modal>
                    <ConfirmationModal isOpen={!!loanToDelete} onClose={() => setLoanToDelete(null)} onConfirm={confirmDelete} title="Delete Loan" message="Are you sure you want to delete this loan record?" />
                </Card>
            );
        };
        
        const LoanHistoryTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { where } = window.firebaseSDK;
            const [selectedShop, setSelectedShop] = useState('');
            // REFACTORED: Get global data from App Data Context.
            const { shops } = useAppData();

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return selectedShop ? [where("shop", "==", selectedShop)] : [];
                }
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (managedShops.length === 0) return [where("shop", "==", "null")];
                    if (selectedShop) {
                        return [where("shop", "==", selectedShop)];
                    }
                    return [where("shop", "in", managedShops)];
                }
                return [where("shop", "==", userProfile.shop || null)];
            }, [userProfile, selectedShop]);
            
            const { data: loanPayments } = useCollection('loanPayments', queryConstraints);
            const { data: staffLoans } = useCollection('staffLoans');
            const [paymentToDelete, setPaymentToDelete] = useState(null);

            const confirmDelete = async () => {
                if (!paymentToDelete) return;
                const { doc, updateDoc, deleteDoc } = window.firebaseSDK;
                try {
                    // Revert the loan's totalPaid amount
                    const loan = staffLoans.find(l => l.id === paymentToDelete.loanId);
                    if (loan) {
                        const newTotalPaid = (loan.totalPaid || 0) - paymentToDelete.amountPaid;
                        const newStatus = newTotalPaid >= loan.loanAmount ? 'Paid Off' : 'Active';
                        await updateDoc(doc(db, 'staffLoans', loan.id), { totalPaid: newTotalPaid, status: newStatus });
                    }
                    await deleteDoc(doc(db, 'loanPayments', paymentToDelete.id));
                } catch (error) { console.error("Error deleting loan payment:", error); alert("Failed to delete loan payment."); } 
                finally { setPaymentToDelete(null); }
            };
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            return (
                 <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Loan Payment History</h3>
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Payment Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount Paid</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Remaining Balance</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{loanPayments.map(payment => (<tr key={payment.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{payment.paymentDate}</td><td className="px-4 py-4 text-sm text-slate-300">{payment.staffName}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(payment.amountPaid)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(payment.remainingBalance)}</td><td className="px-4 py-4 text-sm text-slate-300">{payment.note}</td><td className="px-4 py-4 text-center whitespace-nowrap"><Button variant="icon-delete" icon="fa-trash" onClick={() => setPaymentToDelete(payment)} title="Delete" /></td></tr>))}</tbody></table></div>
                    <ConfirmationModal isOpen={!!paymentToDelete} onClose={() => setPaymentToDelete(null)} onConfirm={confirmDelete} title="Delete Loan Payment" message="Are you sure you want to delete this payment record? This will also update the loan's total paid amount." />
                </Card>
            );
        };
        // --- END LOAN MANAGER PAGE ---

        // --- START PAYROLL PAGE ---
        const PayrollPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('calculator');
            const [editingRecord, setEditingRecord] = useState(null);
            
            // Function to switch to calculator tab and load record for editing
            const handleEdit = (record) => { 
                setEditingRecord(record); 
                setActiveTab('calculator'); 
            };

            // Function to handle successful save, switch to history tab
            const handleSaveSuccess = () => { 
                setEditingRecord(null); 
                setActiveTab('history'); 
            };

            return (
                <TabbedPage tabs={{ calculator: 'Payroll Calculator', history: 'Payroll History' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                   <div id="calculator"><PayrollCalculatorTab userProfile={userProfile} editingRecord={editingRecord} onSaveSuccess={handleSaveSuccess} /></div>
                    <div id="history"><PayrollHistoryTab onEdit={handleEdit} userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };

        // A dedicated component for rendering the payslip. It only displays data it receives.
        const PayslipPreview = memo(({ selectedEmployee, selectedMonth, manualInputs, calculations }) => {
            return (
                <div id="payslip-preview" className="bg-white text-slate-800 p-6 rounded-lg shadow-2xl font-sans">
                    <div className="text-center mb-6">
                        <h2 className="text-2xl font-bold">PAYSLIP</h2>
                        <p className="text-slate-500">For the month of {selectedMonth}</p>
                    </div>
                    {selectedEmployee ? (
                    <>
                        <div className="grid grid-cols-2 gap-4 mb-6 text-sm">
                            <div>
                                <p className="font-bold">{selectedEmployee.name}</p>
                                <p>{selectedEmployee.position}</p>
                                <p>Shift: {selectedEmployee.shift}</p>
                            </div>
                            <div className="text-right">
                                <p>Shop: {Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop.join(', ') : selectedEmployee.shop}</p>
                                <p>Base Salary: {Utils.formatCurrency(calculations.baseSalary)}</p>
                                <p>Worked Dur.: {Utils.calculateWorkedDuration(selectedEmployee.joinedDate)}</p>
                            </div>
                        </div>
                        <div className="grid grid-cols-2 gap-6">
                            <div className="space-y-2 p-4 border-t-4 border-green-500 bg-green-50 rounded-b-lg">
                                <h3 className="text-lg font-semibold text-slate-900">Earnings</h3>
                                <div className="flex justify-between text-sm"><p>Work Days</p><p>{manualInputs.workDays || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Given Off Days</p><p>{manualInputs.givenOffDays || 0}</p></div>
                                <div className="flex justify-between text-sm pt-2 border-t border-slate-200"><p>Salary Earned</p><p>{Utils.formatCurrency(calculations.baseSalaryEarned)}</p></div>
                                <div className="flex justify-between text-sm"><p>OT Salary ({manualInputs.otDays || 0})</p><p>{Utils.formatCurrency(calculations.otSalary)}</p></div>
                                <div className="flex justify-between text-sm"><p>Engagements</p><p>{Utils.formatCurrency(calculations.engagements)}</p></div>
                                <div className="flex justify-between font-bold pt-2 border-t border-slate-300"><p>Gross Salary</p><p>{Utils.formatCurrency(calculations.grossSalary)}</p></div>
                            </div>
                            <div className="space-y-2 p-4 border-t-4 border-red-500 bg-red-50 rounded-b-lg">
                                <h3 className="text-lg font-semibold text-slate-900">Deductions</h3>
                                <div className="flex justify-between text-sm"><p>Leave Days</p><p className="text-red-600">-{manualInputs.leaveDays || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Late ({manualInputs.totalLateDays || 0})</p><p>{Utils.formatCurrency(calculations.lateDeductionsAmount)}</p></div>
                                {/* REVISED: Changed No-CheckOut to No-Attendance */}
                                <div className="flex justify-between text-sm" title="Absent + No-CheckOut"><p>No-Attendance</p><p>{manualInputs.noAttendance || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Loan Deduction</p><p>{Utils.formatCurrency(manualInputs.loanDeduction)}</p></div>
                                <div className="flex justify-between text-sm"><p>Other Deductions</p><p>{Utils.formatCurrency(calculations.otherDeductions)}</p></div>
                                {/* NEW: Display the rejected leave penalty if it exists */}
                                {calculations.rejectedLeavePenaltyAmount > 0 && (
                                    <div className="flex justify-between text-sm text-red-700 font-semibold" title="Penalty: Absence on a day with a rejected leave request. (Salary Per Day x 2)">
                                        <p>Penalty Leave Rejected</p>
                                        <p>{Utils.formatCurrency(calculations.rejectedLeavePenaltyAmount)}</p>
                                    </div>
                                )}
                                {/* --- NEW: Step 3 - Display Savings Deduction on Payslip --- */}
                                {calculations.savingsDeduction > 0 && (
                                    <div className="flex justify-between text-sm text-blue-700 font-semibold" title="Voluntary Savings Program">
                                        <p>Savings Deduction</p>
                                        <p>{Utils.formatCurrency(calculations.savingsDeduction)}</p>
                                    </div>
                                )}
                                <div className="flex justify-between font-bold pt-2 border-t border-slate-300"><p>Total Deductions</p><p className="text-red-600">{Utils.formatCurrency(calculations.totalDeductions)}</p></div>
                            </div>
                        </div>
                        <div className="mt-6 p-4 bg-blue-100 border border-blue-300 rounded-lg text-center">
                            <p className="text-sm font-semibold text-blue-800">NET SALARY</p>
                            <p className="text-3xl font-bold text-blue-900">{Utils.formatCurrency(calculations.netSalary)}</p>
                        </div>
                    </>
                    ) : (
                        <div className="text-center py-20 text-slate-500"><i className="fas fa-file-invoice-dollar text-4xl mb-4"></i><p>Please select an employee to view the payslip.</p></div>
                    )}
                </div>
            );
        });

        const PayrollCalculatorTab = ({ userProfile, editingRecord, onSaveSuccess }) => {
            const { db } = useFirebase();
            const currentMonth = new Date().toISOString().slice(0, 7);
            const [selectedMonth, setSelectedMonth] = useState(currentMonth);
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from the App Data context provider
            const { shops, employees, shifts } = useAppData();

            // PHASE 2 OPTIMIZATION: Add query constraints for Shop Managers to only load data for their shops.
            const payrollQueryConstraints = useMemo(() => {
                const { role, shop } = userProfile || {};
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        // Return constraints for different collection structures
                        return {
                            standard: [where("shop", "in", managedShops)], // For collections with 'shop' field
                            salary: [where("shopName", "in", managedShops)] // For 'salaryRevisions' with 'shopName' field
                        };
                    }
                     // If manager has no shops, return a query that finds nothing.
                    return {
                        standard: [where("shop", "==", "null")],
                        salary: [where("shopName", "==", "null")]
                    };
                }
                // Admin and Staff roles will not have server-side constraints here.
                return { standard: [], salary: [] };
            }, [userProfile]);
            
            const allData = {
                shops: shops, // Use data from context
                employees: employees, // Use data from context
                attendance: useCollection('attendance', payrollQueryConstraints.standard).data,
                leaveRequests: useCollection('leaveRequests', payrollQueryConstraints.standard).data,
                otRequests: useCollection('otRequests', payrollQueryConstraints.standard).data,
                staffLoans: useCollection('staffLoans', payrollQueryConstraints.standard).data,
                employeeStates: useCollection('employeeStates', payrollQueryConstraints.standard).data,
                salaryRevisions: useCollection('salaryRevisions', payrollQueryConstraints.salary).data,
                shifts: shifts, // Use data from context
            };
            
            const [manualLoanDeduction, setManualLoanDeduction] = useState(undefined);
            const [isProcessing, setIsProcessing] = useState(false);
        
            const managedShops = useMemo(() => {
                if (!userProfile?.shop) return [];
                return Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
            }, [userProfile]);
        
            const isShopManager = userProfile?.role === 'Shop Manager';

            const selectedEmployee = useMemo(() => employees.find(emp => emp.id === selectedEmployeeId), [selectedEmployeeId, employees]);
            
            // Use the centralized calculator hook
            const { inputs: autoInputs, calculations } = usePayrollCalculator(selectedEmployee, selectedMonth, allData, manualLoanDeduction);

            // Effect to load editing record or reset form
            useEffect(() => {
                if (editingRecord) {
                    setSelectedMonth(editingRecord.month); 
                    setSelectedShop(editingRecord.shop); 
                    setSelectedEmployeeId(editingRecord.employeeId);
                    setManualLoanDeduction(editingRecord.manualInputs.loanDeduction);
                } else if (userProfile) {
                    if (userProfile.role === 'Admin' || isShopManager) { setSelectedShop(''); } 
                    else { setSelectedShop(userProfile.shop || ''); }
                    setSelectedEmployeeId(''); 
                    setSelectedMonth(currentMonth);
                    setManualLoanDeduction(undefined);
                }
            }, [editingRecord, userProfile, currentMonth, isShopManager]);
            
            // Effect to update manual loan deduction when auto-calculated value changes
            useEffect(() => {
                if (autoInputs.loanDeduction !== undefined && manualLoanDeduction === undefined) {
                    setManualLoanDeduction(autoInputs.loanDeduction);
                }
            }, [autoInputs.loanDeduction, manualLoanDeduction]);
            
            const handleManualLoanChange = (e) => {
                const value = e.target.value;
                setManualLoanDeduction(value === '' ? undefined : parseFloat(value));
            };
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (isShopManager) {
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile, isShopManager, managedShops]);

            const employeesForDropdown = useMemo(() => {
                let relevantEmployees = [];
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') {
                     relevantEmployees = selectedShop 
                        ? employees.filter(e => Array.isArray(e.shop) ? e.shop.includes(selectedShop) : e.shop === selectedShop)
                        : employees;
                } else if (isShopManager) {
                    const shopsToFilter = selectedShop ? [selectedShop] : managedShops;
                    relevantEmployees = employees.filter(e => {
                        const employeeShops = Array.isArray(e.shop) ? e.shop : [e.shop];
                        return employeeShops.some(s => shopsToFilter.includes(s));
                    });
                } else { // Staff
                    relevantEmployees = employees.filter(e => e.shop === userProfile.shop);
                }
                return relevantEmployees.filter(e => e.status === 'Active');
            }, [selectedShop, employees, userProfile, isShopManager, managedShops]);

            const handleDownloadPayslip = () => {
                const payslipElement = document.getElementById('payslip-preview');
                if (!payslipElement || !selectedEmployee) { alert("Please select an employee to generate a payslip."); return; }
                const [year, month] = selectedMonth.split('-');
                const shopName = Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop[0] : selectedEmployee.shop;
                html2canvas(payslipElement, { backgroundColor: '#ffffff', scale: 2 }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `${shopName}-${selectedEmployee.name}-${month}-${year.substring(2)}.png`;
                    link.href = canvas.toDataURL('image/png'); link.click();
                });
            };

            const handleSaveAndDownload = async () => {
                setIsProcessing(true);
                if (!selectedEmployee || calculations.netSalary === undefined) {
                    alert("Cannot process. Please ensure an employee is selected and payroll is calculated.");
                    setIsProcessing(false);
                    return;
                }
                const shopName = Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop[0] : selectedEmployee.shop;
                const { addDoc, collection, serverTimestamp, doc, updateDoc, getDocs, query, where } = window.firebaseSDK;
                
                // NEW: Check for duplicates before saving, but only if it's NOT an edit
                if (!editingRecord) {
                    const payrollCheckQuery = query(collection(db, "payrollHistory"), where("employeeId", "==", selectedEmployee.id), where("month", "==", selectedMonth));
                    const existingPayrollSnap = await getDocs(payrollCheckQuery);
                    if (!existingPayrollSnap.empty) {
                        alert(`Payroll for ${selectedEmployee.name} for ${selectedMonth} has already been generated and saved.`);
                        setIsProcessing(false);
                        return; // Stop the function to prevent a duplicate
                    }
                }

                const finalInputs = { ...autoInputs, loanDeduction: manualLoanDeduction };
                const payrollData = { month: selectedMonth, shop: shopName, employeeId: selectedEmployee.id, employeeName: selectedEmployee.name, baseSalary: calculations.baseSalary, netSalary: calculations.netSalary, manualInputs: finalInputs, calculations: calculations };
                
                let payrollRecordId;
                let success = false;
                try {
                    if (editingRecord) { 
                        await updateDoc(doc(db, 'payrollHistory', editingRecord.id), payrollData); 
                        payrollRecordId = editingRecord.id;
                    } 
                    else { 
                        const newDocRef = await addDoc(collection(db, 'payrollHistory'), { ...payrollData, createdAt: serverTimestamp() }); 
                        payrollRecordId = newDocRef.id;
                    }
                    
                    if (finalInputs.loanDeduction > 0) {
                        const activeLoan = allData.staffLoans.find(loan => loan.staffId === selectedEmployee.id && loan.status === 'Active');
                        if (activeLoan) {
                            const newTotalPaid = (activeLoan.totalPaid || 0) + finalInputs.loanDeduction;
                            const newBalance = activeLoan.loanAmount - newTotalPaid;
                            const newStatus = newBalance <= 0 ? 'Paid Off' : 'Active';
                            await updateDoc(doc(db, 'staffLoans', activeLoan.id), { totalPaid: newTotalPaid, status: newStatus });
                            await addDoc(collection(db, 'loanPayments'), { paymentDate: `${selectedMonth}-${new Date(selectedMonth.split('-')[0], selectedMonth.split('-')[1], 0).getDate()}`, staffId: selectedEmployee.id, staffName: selectedEmployee.name, shop: shopName, loanId: activeLoan.id, amountPaid: finalInputs.loanDeduction, remainingBalance: newBalance, note: "Paid via payroll" });
                        }
                    }

                    // --- NEW: Step 3 - Process Savings Contribution ---
                    if (calculations.savingsDeduction > 0) {
                        await Utils.manageSavingsContribution(
                            db,
                            selectedEmployee.id,
                            selectedEmployee.name,
                            calculations.savingsDeduction,
                            payrollRecordId // Link to the payroll record
                        );
                    }
                    // --- END: Step 3 ---

                    alert('Payroll saved successfully!');
                    success = true;
                } catch (error) {
                    console.error("Error saving payroll: ", error);
                    alert('Failed to save payroll.');
                    success = false;
                }

                if (success) {
                    setTimeout(() => {
                        handleDownloadPayslip();
                        onSaveSuccess(selectedMonth);
                    }, 500);
                } else {
                    setIsProcessing(false);
                }
            };
           
            const canSelectShop = (userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || isShopManager) && !editingRecord;
        
            return (
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <Card><CardTitle>Payroll Calculator</CardTitle><div className="space-y-6"><div className="grid grid-cols-1 md:grid-cols-3 gap-4"><div><label className="text-sm font-medium text-slate-400">Month</label><input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input" /></div><div><label className="text-sm font-medium text-slate-400">Shop</label>{canSelectShop ? (<select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select"><option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>{availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}</select>) : (<input value={selectedShop} className="input" disabled />)}</div><div><label className="text-sm font-medium text-slate-400">Employee</label><select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select" disabled={employeesForDropdown.length === 0}><option value="">Select Employee</option>{employeesForDropdown.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}</select></div></div>{selectedEmployee && (<><div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-6 border-t border-slate-700"><h3 className="md:col-span-3 text-lg font-semibold text-slate-200">Attendance & Deductions</h3><div><label className="text-sm">Work Days</label><input type="number" name="workDays" value={autoInputs.workDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Given Off Days</label><input type="number" name="givenOffDays" value={autoInputs.givenOffDays ?? ''} className="input" disabled /></div><div><label className="text-sm">OT Days</label><input type="number" name="otDays" value={autoInputs.otDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Leave Days</label><input type="number" name="leaveDays" value={autoInputs.leaveDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Total Late Days</label><input type="number" name="totalLateDays" value={autoInputs.totalLateDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Loan Deduction</label><input type="number" name="loanDeduction" value={manualLoanDeduction ?? ''} onChange={handleManualLoanChange} className="input" /></div></div><div className="pt-6 border-t border-slate-700 flex flex-col sm:flex-row gap-4">
                        <Button variant="primary" onClick={handleSaveAndDownload} disabled={isProcessing} className="flex-1">
                            {isProcessing ? (<><i className="fas fa-spinner fa-spin"></i> Processing...</>) : (<><i className="fas fa-save"></i> Save & Download</>)}
                        </Button>
                    </div></>)}</div></Card>
                    <PayslipPreview 
                        selectedEmployee={selectedEmployee}
                        selectedMonth={selectedMonth}
                        manualInputs={{...autoInputs, loanDeduction: manualLoanDeduction }}
                        calculations={calculations}
                    />
                </div>
            );
        };

        const PayrollHistoryTab = ({ onEdit, userProfile }) => {
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;

            // Filter states
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));

            // Data states
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(false);
            // REFACTORED: Get shops from central context.
            const { shops } = useAppData();

            // PHASE 3: Fetch payroll history on-demand for all roles for consistency and performance
            useEffect(() => {
                const fetchHistory = async () => {
                    if (!userProfile) return;
                    setLoading(true);

                    const { role, shop } = userProfile;
                    let q = query(collection(db, 'payrollHistory'));

                    // 1. Filter by role
                    if (role === 'Shop Manager') {
                        const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                        if (managedShops.length > 0) {
                            q = query(q, where("shop", "in", managedShops));
                        } else {
                            q = query(q, where("shop", "==", "null")); // No shops, no data
                        }
                    }
                    // Staff don't see this page, so no specific filter needed.

                    // 3. Admin's shop filter is also applied on the server
                    if ((role === 'Admin' || role === 'CEO') && selectedShop) {
                        q = query(q, where("shop", "==", selectedShop));
                    }
                    
                    // FIX: Add the month filter to the query
                    if (selectedMonth) {
                        q = query(q, where("month", "==", selectedMonth));
                    }
                    
                    try {
                        const snapshot = await getDocs(q);
                        const historyData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setHistory(historyData);
                    } catch (error) {
                        console.error("Error fetching payroll history:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchHistory();
            }, [db, userProfile, selectedMonth, selectedShop]); // Refetch when filters change

            const [recordToDelete, setRecordToDelete] = useState(null);
            
            // ... (rest of the component logic remains largely the same, but uses `history` state instead of `useCollection` data)
            
            const isMultiShopManager = userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop) && userProfile.shop.length > 1;
            const canFilterByShop = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || isMultiShopManager;

            const availableShopsForFilter = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (isMultiShopManager) {
                    // Map shop names to the structure expected by the select dropdown
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                return [];
            }, [shops, userProfile, isMultiShopManager]);
            
            // NEW: Set initial shop state based on user role - now only for Admin UI
            useEffect(() => { 
                if (userProfile && userProfile.role === 'Shop Manager' && !isMultiShopManager) {
                     setSelectedShop(userProfile.shop || ''); 
                } else {
                    setSelectedShop('');
                }
            }, [userProfile, isMultiShopManager]);

            const { filteredHistory, totals } = useMemo(() => {
                // Client-side filtering is now simpler as server does most of the work
                const filtered = history.filter(rec => {
                    // For managers with multiple shops, they can further filter down from their total set of shops
                    if (userProfile?.role === 'Shop Manager' && selectedShop) {
                        return rec.shop === selectedShop;
                    }
                    return true;
                });
                    const sorted = [...filtered].sort((a,b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
                const totals = sorted.reduce((acc, curr) => { 
                    acc.baseSalary += curr.baseSalary || 0; 
                    acc.engagements += curr.calculations?.engagements || 0;
                    acc.otSalary += curr.calculations?.otSalary || 0;
                    acc.loanDeduction += curr.manualInputs?.loanDeduction || 0; 
                    acc.otherDeductions += curr.calculations?.otherDeductions || 0;
                    acc.savingsDeduction += curr.calculations?.savingsDeduction || 0; // NEW: Add savings to totals
                    acc.netSalary += curr.netSalary || 0; 
                    return acc; 
                }, { baseSalary: 0, engagements: 0, otSalary: 0, loanDeduction: 0, otherDeductions: 0, savingsDeduction: 0, netSalary: 0 }); // NEW: Initialize savings
                return { filteredHistory: sorted, totals };
            }, [history, selectedShop, userProfile]);

            const handleDelete = async () => {
                if (!recordToDelete) return;
                try { 
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'payrollHistory', recordToDelete.id)); 
                    // Refetch data after delete
                    // A simple way is to just refetch all, though a more advanced solution could remove it from state.
                    setSelectedMonth(prev => `${prev}`); // Trigger useEffect refetch
                } 
                catch (error) { console.error("Error deleting payroll record:", error); }
                finally {
                    setRecordToDelete(null);
                }
            };

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6"><CardTitle>Payroll History</CardTitle><div className="flex flex-wrap gap-4 items-center">
                        {canFilterByShop && (
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                        <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                    </div></div>
                    {loading ? (
                         <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                        <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Employee</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Base Salary</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Engagements</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">OT Salary</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Loan Deduction</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Other Deductions</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Savings Deduction</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Final Salary</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{filteredHistory.map(rec => (<tr key={rec.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{rec.month}</td><td className="px-4 py-4 text-sm text-slate-300">{rec.shop}</td><td className="px-4 py-4 text-sm text-slate-300">{rec.employeeName}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(rec.baseSalary)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(rec.calculations?.engagements)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(rec.calculations?.otSalary)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(rec.manualInputs?.loanDeduction)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(rec.calculations?.otherDeductions)}</td><td className="px-4 py-4 text-sm text-blue-400 text-right">{Utils.formatCurrency(rec.calculations?.savingsDeduction)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(rec.netSalary)}</td><td className="px-4 py-4 text-center whitespace-nowrap"><div className="flex items-center justify-center gap-4">{(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (<><Button variant="icon-edit" icon="fa-edit" onClick={() => onEdit(rec)} title="Edit" /><Button variant="icon-delete" icon="fa-trash" onClick={() => setRecordToDelete(rec)} title="Delete" /></>)}</div></td></tr>))}</tbody><tfoot className="bg-slate-900/50"><tr><td colSpan="3" className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Sub-Total</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.baseSalary)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.engagements)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.otSalary)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.loanDeduction)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.otherDeductions)}</td><td className="px-4 py-3 text-right font-bold text-blue-400">{Utils.formatCurrency(totals.savingsDeduction)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.netSalary)}</td><td></td></tr></tfoot></table></div>
                    )}
                    <ConfirmationModal isOpen={!!recordToDelete} onClose={() => setRecordToDelete(null)} onConfirm={handleDelete} title="Delete Payroll Record" message="Are you sure you want to delete this payroll record? This action cannot be undone." />
                </Card>
            );
        };

        const EmployeeStateTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const fileInputRef = useRef(null); // For triggering file upload
            const [isImporting, setIsImporting] = useState(false);
            const [importResult, setImportResult] = useState(null);
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingRecord, setEditingRecord] = useState(null);
            const [recordToDelete, setRecordToDelete] = useState(null);
            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();

            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("staffId", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) {
                        return [where("shop", "in", shops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops, no data
                }
                // Staff can only see their own records.
                return [where("staffId", "==", userProfile.id || null)];
            }, [userProfile]);

            const { data: employeeStates } = useCollection('employeeStates', queryConstraints);
            
            const [selectedShop, setSelectedShop] = useState('');
            const [filterMode, setFilterMode] = useState('month'); // 'month' or 'date'
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [selectedDate, setSelectedDate] = useState(new Date().toISOString().slice(0, 10));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');

            // NEW: Add collections needed for penalty calculation
            const salaryRevQueryConstraints = useMemo(() => {
                if (!userProfile) return [where("shopName", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.length > 0 ? [where("shopName", "in", shops)] : [where("shopName", "==", "null")];
                }
                const userShop = employees.find(e => e.id === userProfile.id)?.shop;
                return [where("shopName", "==", userShop || null)];
            }, [userProfile, employees]);
            
            const { data: attendance } = useCollection('attendance', queryConstraints);
            const { data: leaveRequests } = useCollection('leaveRequests', queryConstraints);
            const { data: salaryRevisions } = useCollection('salaryRevisions', salaryRevQueryConstraints);


            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    // For managers with multiple shops, default to showing all their shops.
                    // For single-shop users, their shop is pre-selected.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const filteredRecords = useMemo(() => {
                const dbRecords = employeeStates.filter(rec => {
                    const dateMatch = filterMode === 'month'
                        ? (!selectedMonth || (rec.date && rec.date.startsWith(selectedMonth)))
                        : (!selectedDate || rec.date === selectedDate);
                    
                    return dateMatch &&
                           (!selectedShop || rec.shop === selectedShop) &&
                           (!selectedEmployeeId || rec.staffId === selectedEmployeeId);
                });

                // NEW: Calculate penalty records for the selected month
                const calculatedPenaltyRecords = [];
                if (filterMode === 'month' && selectedMonth) {
                    const [year, monthNum] = selectedMonth.split('-').map(Number);
                    const daysInMonth = new Date(year, monthNum, 0).getDate();
                    
                    const employeesToCheck = employees.filter(emp => 
                        emp.status === 'Active' &&
                        (!selectedShop || (Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop)) &&
                        (!selectedEmployeeId || emp.id === selectedEmployeeId)
                    );

                    for (const employee of employeesToCheck) {
                        const monthAttendance = (attendance || []).filter(r => r.employeeId === employee.id && r.timestamp?.toDate().toISOString().startsWith(selectedMonth));
                        const attendedDays = new Set(monthAttendance.map(r => r.timestamp.toDate().toISOString().split('T')[0]));
                        const approvedLeaves = (leaveRequests || []).filter(lr => lr.staffId === employee.id && lr.status === 'Approved');
                        
                        const applicableRevisions = (salaryRevisions || [])
                            .filter(rev => rev.staffId === employee.id && rev.effectiveDate && rev.effectiveDate <= `${selectedMonth}-31` && rev.status === 'Approved')
                            .sort((a, b) => b.effectiveDate.localeCompare(a.effectiveDate));
                        
                        const baseSalary = applicableRevisions.length > 0
                            ? (parseFloat(String(applicableRevisions[0].updatedSalary).replace(/[^0-9.-]/g, '')) || 0)
                            : (parseFloat(String(employee.salary).replace(/[^0-9.-]/g, '')) || 0);
                        
                        const salaryPerDay = baseSalary > 0 && daysInMonth > 0 ? baseSalary / daysInMonth : 0;
                        const rejectedLeaves = (leaveRequests || []).filter(lr => lr.staffId === employee.id && lr.status === 'Rejected');
                        
                        let penaltyAmount = 0;
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);

                        for (let day = 1; day <= daysInMonth; day++) {
                            const currentDay = new Date(year, monthNum - 1, day);
                            if (currentDay >= today) break;

                            const dayKey = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                            if (!attendedDays.has(dayKey)) {
                                const isOnApprovedLeave = approvedLeaves.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                                if (!isOnApprovedLeave) {
                                    const hadRejectedLeave = rejectedLeaves.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                                    if (hadRejectedLeave) {
                                        penaltyAmount += (salaryPerDay * 2);
                                    }
                                }
                            }
                        }

                        if (penaltyAmount > 0) {
                            calculatedPenaltyRecords.push({
                                id: `virtual_penalty_${employee.id}`,
                                date: `${selectedMonth}-01`, // Assign to the start of the month for sorting
                                shop: Array.isArray(employee.shop) ? employee.shop[0] : employee.shop,
                                staffId: employee.id,
                                staffName: employee.name,
                                statusState: 'Deduction',
                                amount: penaltyAmount,
                                note: 'Penalty (Absence on Rejected Leave)',
                                status: 'Approved',
                                isVirtual: true,
                            });
                        }
                    }
                }
                
                // Combine DB records with calculated ones and sort
                const combinedRecords = [...dbRecords, ...calculatedPenaltyRecords];
                
                return combinedRecords.sort((a, b) => {
                    if (a.status === 'Pending' && b.status !== 'Pending') return -1;
                    if (a.status !== 'Pending' && b.status === 'Pending') return 1;
                    return new Date(b.date) - new Date(a.date);
                });
            }, [employeeStates, selectedShop, selectedMonth, selectedDate, filterMode, selectedEmployeeId, employees, attendance, leaveRequests, salaryRevisions]);
            
            const handleOpenModal = (record = null) => { setEditingRecord(record); setModalOpen(true); };
            const handleCloseModal = () => { setEditingRecord(null); setModalOpen(false); };

            const handleSave = async (formData) => {
                const { addDoc, collection, doc, updateDoc } = window.firebaseSDK;
                const staffName = employees.find(e => e.id === formData.staffId)?.name || '';
                const dataToSave = { ...formData, amount: parseFloat(formData.amount) || 0, staffName: staffName };

                // Add approval status for new records
                if (!formData.id) {
                    dataToSave.status = dataToSave.statusState === 'Engagement' ? 'Pending' : 'Approved';
                }

                try {
                    if (formData.id) { const { id, ...data } = dataToSave; await updateDoc(doc(db, 'employeeStates', id), data); } 
                    else { await addDoc(collection(db, 'employeeStates'), dataToSave); }
                    handleCloseModal();
                } catch (error) { console.error("Error saving employee state:", error); }
            };

            const handleDelete = async () => {
                if (!recordToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'employeeStates', recordToDelete.id));
                    setRecordToDelete(null);
                } catch (error) { console.error("Error deleting record:", error); setRecordToDelete(null); }
            };

            const handleUpdateStatus = useCallback(async (recordId, newStatus) => {
                if (!recordId || !newStatus) return;
                try {
                    await window.firebaseSDK.updateDoc(window.firebaseSDK.doc(db, 'employeeStates', recordId), { status: newStatus });
                } catch (error) {
                    console.error(`Error updating record ${recordId} status:`, error);
                }
            }, [db]);

            // NEW: Function to download the Excel template
            const handleDownloadTemplate = useCallback(() => {
                const templateData = [
                    { employeeId: '(Optional)', staffName: 'Example Staff Name', shop: 'Example Shop Name', date: '2025-09-26', statusState: 'Deduction', amount: 5000, note: 'Sample reason' },
                ];
                // Explicitly set the header order
                const worksheet = XLSX.utils.json_to_sheet(templateData, { header: ["employeeId", "staffName", "shop", "date", "statusState", "amount", "note"] });
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Template");
                worksheet["!cols"] = [ { wch: 20 }, { wch: 25 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 40 } ];
                XLSX.writeFile(workbook, "Engagement_Deduction_Template.xlsx");
            }, []);

            // NEW: Function to trigger the hidden file input
            const triggerFileUpload = () => {
                if (fileInputRef.current) {
                    fileInputRef.current.value = ""; // Allow re-uploading the same file
                }
                fileInputRef.current.click();
            };
            
            // NEW: Function to handle the file upload and processing
            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setIsImporting(true);
                setImportResult(null);

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: "array", cellDates: true });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        // Convert dates to YYYY-MM-DD format string to avoid timezone issues
                        const json = XLSX.utils.sheet_to_json(worksheet, { raw: false, dateNF: 'yyyy-mm-dd' });

                        if (json.length === 0) {
                            setImportResult({ success: false, message: 'The Excel file is empty or in the wrong format.' });
                            setIsImporting(false);
                            return;
                        }

                        const { collection, writeBatch, doc } = window.firebaseSDK;
                        const batch = writeBatch(db);
                        let errors = [];
                        let successCount = 0;

                        json.forEach((row, index) => {
                            const rowNum = index + 2;
                            const employeeId = row.employeeId?.trim();
                            const staffName = row.staffName?.trim();
                            const shopName = row.shop?.trim();
                            const statusState = row.statusState?.trim();
                            
                            if ((!employeeId && !staffName) || !row.date || !statusState || row.amount === undefined) {
                                errors.push(`Row ${rowNum}: Missing required data (employeeId/staffName, shop, date, statusState, amount).`);
                                return;
                            }
                            
                            let employee;
                            // Prioritize finding employee by ID for accuracy
                            if (employeeId && employeeId !== '(Optional)') {
                                employee = employees.find(e => e.id === employeeId && e.status === 'Active');
                                if (!employee) {
                                    errors.push(`Row ${rowNum}: Active employee with ID "${employeeId}" not found.`);
                                    return;
                                }
                            } else {
                                // Fallback to name if ID is not provided
                                employee = employees.find(e => e.name.toLowerCase() === staffName.toLowerCase() && e.status === 'Active');
                                if (!employee) {
                                    errors.push(`Row ${rowNum}: Active staff member "${staffName}" not found.`);
                                    return;
                                }
                            }

                            if (statusState !== 'Engagement' && statusState !== 'Deduction') {
                                errors.push(`Row ${rowNum}: Invalid statusState "${statusState}". Must be 'Engagement' or 'Deduction'.`);
                                return;
                            }
                            
                            const targetShop = shopName || (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop);
                            if (!targetShop) {
                                errors.push(`Row ${rowNum}: Shop for "${employee.name}" could not be determined. Please specify a shop in the template or employee profile.`);
                                return;
                            }
                             // Validate that the shop from the file is one of the employee's assigned shops
                            const employeeShops = Array.isArray(employee.shop) ? employee.shop : [employee.shop];
                            if (!employeeShops.includes(targetShop)) {
                                errors.push(`Row ${rowNum}: Shop "${targetShop}" is not an assigned shop for ${employee.name}.`);
                                return;
                            }

                            const newRecord = {
                                staffId: employee.id, staffName: employee.name,
                                shop: targetShop,
                                date: row.date, statusState: statusState,
                                amount: parseFloat(row.amount) || 0,
                                note: row.note || '',
                                status: statusState === 'Engagement' ? 'Pending' : 'Approved'
                            };
                            
                            const newDocRef = doc(collection(db, 'employeeStates'));
                            batch.set(newDocRef, newRecord);
                            successCount++;
                        });

                        if (errors.length > 0) {
                            setImportResult({ success: false, message: `Import failed with ${errors.length} error(s):`, errors });
                        } else if (successCount > 0) {
                            await batch.commit();
                            setImportResult({ success: true, message: `Successfully imported ${successCount} records.` });
                        } else {
                             setImportResult({ success: false, message: 'No valid records found to import.' });
                        }
                    } catch (error) {
                        console.error("Error processing Excel file:", error);
                        setImportResult({ success: false, message: `An error occurred during import: ${error.message}` });
                    } finally {
                        setIsImporting(false);
                    }
                };
                reader.readAsArrayBuffer(file);
            };

            const handleExportExcel = useCallback(() => {
                const dataToExport = filteredRecords.map(rec => ({
                    'Date': rec.date,
                    'Shop': rec.shop,
                    'Staff Name': rec.staffName,
                    'Status': rec.statusState,
                    'Amount (KHR)': parseFloat(String(rec.amount).replace(/[^0-9.-]/g, '')) || 0,
                    'Reason / Note': rec.note,
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Employee States");
                
                worksheet["!cols"] = [ { wch: 12 }, { wch: 15 }, { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 40 } ];
                
                const fileName = filterMode === 'month'
                    ? `Employee_State_Report_${selectedMonth}.xlsx`
                    : `Employee_State_Report_${selectedDate}.xlsx`;
                XLSX.writeFile(workbook, fileName);
            }, [filteredRecords, selectedMonth, selectedDate, filterMode]);
            
            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Engagements / Deductions</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                             {(userProfile.role === 'Admin' || (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && selectedShop && (
                                <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">All Staff</option>
                                    {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                </select>
                            )}
                            <select value={filterMode} onChange={e => setFilterMode(e.target.value)} className="select w-full sm:w-auto">
                                <option value="month">Filter by Month</option>
                                <option value="date">Filter by Date</option>
                            </select>
                            {filterMode === 'month' ? (
                                <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                            ) : (
                                <input type="date" value={selectedDate} onChange={e => setSelectedDate(e.target.value)} className="input w-full sm:w-auto" />
                            )}
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add New</Button>
                            )}
                            {userProfile?.role === 'Admin' && (
                                <>
                                    <input
                                        type="file"
                                        ref={fileInputRef}
                                        onChange={handleFileChange}
                                        className="hidden"
                                        accept=".xlsx, .xls"
                                    />
                                    <Button 
                                        variant="secondary" 
                                        icon="fa-download"
                                        onClick={handleDownloadTemplate}
                                    >
                                        Template
                                    </Button>
                                    <Button 
                                        variant="secondary" 
                                        icon="fa-upload"
                                        onClick={triggerFileUpload}
                                        disabled={isImporting}
                                    >
                                        {isImporting ? 'Importing...' : 'Import'}
                                    </Button>
                                </>
                            )}
                             <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                    {/* Desktop Table */}
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Reason</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{filteredRecords.map(record => (<tr key={record.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{record.isVirtual ? selectedMonth : record.date}</td><td className="px-4 py-4 text-sm text-slate-300">{record.shop}</td><td className="px-4 py-4 text-sm text-slate-300">{record.staffName}</td><td className="px-4 py-4 text-sm text-slate-300">{record.statusState}</td><td className={`px-4 py-4 text-sm text-right font-semibold ${record.note?.includes('Penalty') ? 'text-red-400' : 'text-slate-300'}`}>{Utils.formatCurrency(record.amount)}</td><td className="px-4 py-4 text-sm text-slate-300">{record.note}</td><td className="px-4 py-4 text-center text-sm">{record.statusState === 'Engagement' && (<span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${ record.status === 'Approved' ? 'bg-green-100 text-green-800' : record.status === 'Rejected' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800' }`}>{record.status || 'Pending'}</span>)}</td><td className="px-4 py-4 text-center whitespace-nowrap"><div className="flex items-center justify-center gap-4">
                                            {/* REVISED: Only Admin/CEO can approve/reject */}
                                            {!record.isVirtual && (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && record.statusState === 'Engagement' && record.status === 'Pending' && (<><Button variant="icon-approve" icon="fa-check-circle" onClick={() => handleUpdateStatus(record.id, 'Approved')} title="Approve" /><Button variant="icon-reject" icon="fa-times-circle" onClick={() => handleUpdateStatus(record.id, 'Rejected')} title="Reject" /></>)}
                                            
                                            {/* REVISED: Only Admin/CEO can edit/delete */}
                                            {!record.isVirtual && (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (<><Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(record)} title="Edit" /><Button variant="icon-delete" icon="fa-trash" onClick={() => setRecordToDelete(record)} title="Delete" /></>)}
                                        </div></td></tr>))}</tbody></table></div>
                    <EmployeeStateModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSave} record={editingRecord} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!recordToDelete} onClose={() => setRecordToDelete(null)} onConfirm={handleDelete} title="Delete Record" message="Are you sure you want to delete this record?" />
                    {/* NEW: Modal to show import results */}
                    <Modal isOpen={!!importResult} onClose={() => setImportResult(null)} maxWidth="max-w-2xl">
                        <ModalHeader title="Import Result" onClose={() => setImportResult(null)} />
                        <ModalBody>
                            {importResult && (
                                <div>
                                    <p className={`font-bold ${importResult.success ? 'text-green-400' : 'text-red-400'}`}>
                                        {importResult.message}
                                    </p>
                                    {importResult.errors && (
                                        <ul className="mt-4 list-disc list-inside space-y-1 text-slate-300 bg-slate-700 p-4 rounded-md max-h-60 overflow-y-auto">
                                            {importResult.errors.map((err, i) => <li key={i}>{err}</li>)}
                                        </ul>
                                    )}
                                </div>
                            )}
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="primary" onClick={() => setImportResult(null)}>Close</Button>
                        </ModalFooter>
                    </Modal>
                </Card>
            );
        };

        const EmployeeStateModal = ({ isOpen, onClose, onSave, record, userProfile }) => {
            const [formData, setFormData] = useState({});
            const [selectedShop, setSelectedShop] = useState('');
            
            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();

            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin') return shops
                const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                if (managedShops.length > 0) {
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const canSelectShop = useMemo(() => {
                if (!userProfile) return false;
                if (userProfile.role === 'Admin') return true;
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop) && userProfile.shop.length > 1) return true;
                return false;
            }, [userProfile]);

            useEffect(() => {
                let initialShop = '';
                if (!record && userProfile) { // Set default shop for NEW records based on user profile
                     if (userProfile.role !== 'Admin') {
                        const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                        if (managedShops.length === 1) {
                            initialShop = managedShops[0];
                        }
                     }
                }

                const initialData = record 
                    ? { ...record } 
                    : { date: new Date().toISOString().substring(0, 10), shop: initialShop, staffId: '', statusState: 'Deduction', amount: '', note: '' };
                
                setFormData(initialData);
                setSelectedShop(initialData.shop || '');
            }, [record, isOpen, userProfile]);
            
            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);
            
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
                if (name === 'shop') { 
                    setSelectedShop(value); 
                    setFormData(prev => ({ ...prev, staffId: '' })); // Reset staff selection when shop changes
                }
            };

            const handleSubmit = (e) => { 
                e.preventDefault(); 
                if (!formData.shop || !formData.staffId || !formData.amount) { 
                    alert("Please fill all required fields."); 
                    return; 
                } 
                onSave(formData); 
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose}>
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={record ? "Edit Record" : "Add New Record"} onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div><label className="text-sm">Date</label><input type="date" name="date" value={formData.date || ''} onChange={handleChange} className="input"/></div>
                                <div>
                                    <label className="text-sm">Shop</label>
                                    <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={!canSelectShop}>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                    </select>
                                </div>
                                <div><label className="text-sm">Staff</label><select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" disabled={!selectedShop}><option value="">Select Staff</option>{employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}</select></div>
                                <div><label className="text-sm">Status State</label><select name="statusState" value={formData.statusState || 'Deduction'} onChange={handleChange} className="select"><option>Deduction</option><option>Engagement</option></select></div>
                                <div><label className="text-sm">Amount (KHR)</label><input type="number" name="amount" value={formData.amount || ''} onChange={handleChange} className="input"/></div>
                                <div><label className="text-sm">Reason / Note</label><textarea name="note" value={formData.note || ''} onChange={handleChange} className="input" rows="3"></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Save Record</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        // --- END PAYROLL PAGE ---

        // --- START EXPENSE REPORT PAGE ---
        const ExpenseReportPage = ({ userProfile }) => {
            const { where } = window.firebaseSDK;
            
            const payrollQueryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) return [where("shop", "in", shops)];
                    return [where("shop", "==", "null")];
                }
                return [where("shop", "==", "null")];
            }, [userProfile]);

            const { data: payrollHistory } = useCollection('payrollHistory', payrollQueryConstraints);
            const { data: shops } = useCollection('shops');
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const { expenseSummary, totals } = useMemo(() => {
                if (!payrollHistory.length) return { expenseSummary: [], totals: {} };
                const filteredHistory = payrollHistory.filter(rec => (!selectedShop || rec.shop === selectedShop) && (!selectedMonth || rec.month === selectedMonth));
                
                const summary = filteredHistory.reduce((acc, rec) => {
                    if (!rec.shop || !rec.month) return acc;
                    const key = `${rec.shop}_${rec.month}`;
                    if (!acc[key]) { acc[key] = { month: rec.month, shopName: rec.shop, totalLoanDed: 0, totalOtherDed: 0, totalSavingsDed: 0, totalFinalSalary: 0 }; }
                    acc[key].totalLoanDed += parseFloat(rec.manualInputs?.loanDeduction) || 0;
                    acc[key].totalOtherDed += parseFloat(rec.calculations?.otherDeductions) || 0;
                    acc[key].totalSavingsDed += parseFloat(rec.calculations?.savingsDeduction) || 0;
                    acc[key].totalFinalSalary += parseFloat(rec.netSalary) || 0;
                    return acc;
                }, {});

                const summaryArray = Object.values(summary).map(item => {
                    const accountNote = (item.totalFinalSalary || 0) + (item.totalLoanDed || 0) + (item.totalOtherDed || 0) + (item.totalSavingsDed || 0);
                    return { ...item, accountNote };
                }).sort((a, b) => b.month.localeCompare(a.month) || a.shopName.localeCompare(b.shopName));

                const totals = summaryArray.reduce((acc, curr) => { 
                    acc.totalLoanDed += curr.totalLoanDed; 
                    acc.totalOtherDed += curr.totalOtherDed; 
                    acc.totalSavingsDed += curr.totalSavingsDed;
                    acc.totalFinalSalary += curr.totalFinalSalary; 
                    acc.totalAccountNote += curr.accountNote;
                    return acc; 
                }, { totalLoanDed: 0, totalOtherDed: 0, totalSavingsDed: 0, totalFinalSalary: 0, totalAccountNote: 0 });
                
                return { expenseSummary: summaryArray, totals };
            }, [payrollHistory, selectedShop, selectedMonth]);
            
            const canFilterByShop = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop));

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Expense Report Summary</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            {canFilterByShop && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                        </div>
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Month</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Loan Ded.</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Other Ded.</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Saving Program</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Final Salary</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Account Note</th></tr></thead><tbody className="divide-y divide-slate-700">{expenseSummary.map((item, index) => (<tr key={index} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{item.month}</td><td className="px-4 py-4 text-sm text-slate-300">{item.shopName}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalLoanDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalOtherDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalSavingsDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(item.totalFinalSalary)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(item.accountNote)}</td></tr>))}</tbody><tfoot className="bg-slate-900/50"><tr><td colSpan="2" className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Sub-Total</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalLoanDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalOtherDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalSavingsDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalFinalSalary)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalAccountNote)}</td></tr></tfoot></table></div>
                </Card>
            );
        };
        // --- END EXPENSE REPORT PAGE ---

        // --- START POLICY BOARD PAGE ---
        const PolicyModal = memo(({ isOpen, onClose, onSave, policy }) => {
            const [formData, setFormData] = useState({});
            const quillRef = useRef(null);
            const quillInstanceRef = useRef(null);
        
            // This useEffect now correctly handles both the CREATION and DESTRUCTION of the Quill editor instance,
            // syncing its lifecycle with the modal's `isOpen` state.
            useEffect(() => {
                // 1. CREATION LOGIC: This runs only when the modal opens (`isOpen` is true).
                if (isOpen) {
                    const initialData = policy ? { ...policy } : { title: '', category: 'General', content: '' };
                    setFormData(initialData);
        
                    // We create the editor instance only if the container element exists and an instance doesn't already.
                    if (quillRef.current && !quillInstanceRef.current) {
                        quillInstanceRef.current = new Quill(quillRef.current, {
                            theme: 'snow',
                            modules: {
                                toolbar: [
                                    [{ 'header': [1, 2, 3, false] }],
                                    ['bold', 'italic', 'underline', 'strike'],
                                    [{ 'color': [] }, { 'background': [] }],
                                    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                    [{ 'align': [] }],
                                    ['link', 'blockquote', 'code-block'],
                                    ['clean']
                                ]
                            },
                            placeholder: 'Compose the policy content here...',
                        });
        
                        // Attach the listener to update our React state as the user types.
                        quillInstanceRef.current.on('text-change', (delta, oldDelta, source) => {
                            if (source === 'user') {
                                setFormData(prev => ({ ...prev, content: quillInstanceRef.current.root.innerHTML }));
                            }
                        });

                        // Set the initial content when the editor is first created.
                        const editor = quillInstanceRef.current;
                        const newContent = initialData.content || '';
                        // Convert HTML to Quill's native 'Delta' format for the most reliable way to set content.
                        const delta = editor.clipboard.convert(newContent);
                        editor.setContents(delta, 'silent');
                    }
                }
        
                // 2. DESTRUCTION LOGIC (THE FIX): This cleanup function runs when the modal closes (when `isOpen` becomes false).
                return () => {
                    if (quillInstanceRef.current) {
                        // Destroy the Quill instance and release its resources.
                        quillInstanceRef.current = null;
                        // Manually clear the DOM element to prevent leftover Quill UI from appearing on the next open.
                        if (quillRef.current) {
                            quillRef.current.innerHTML = '';
                        }
                    }
                };
            }, [isOpen, policy]); // This effect correctly depends on `isOpen` to manage the lifecycle.
        
            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            }, []);
        
            const handleSubmit = useCallback(() => {
                onSave(formData);
            }, [onSave, formData]);
        
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <ModalHeader title={policy ? "Edit Policy" : "Add New Policy"} onClose={onClose} />
                    <ModalBody>
                        <div className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Title</label>
                                    <input name="title" value={formData.title || ''} onChange={handleChange} className="input" required />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Category</label>
                                    <input name="category" value={formData.category || ''} onChange={handleChange} className="input" placeholder="e.g., General, Leave" required />
                                </div>
                            </div>
                            <div>
                                <label className="text-sm font-medium text-slate-400">Content</label>
                                <div className="bg-slate-100 text-slate-900 mt-1 rounded-lg overflow-hidden border border-slate-600">
                                    <div ref={quillRef} style={{ height: '300px' }}></div>
                                </div>
                            </div>
                        </div>
                    </ModalBody>
                    <ModalFooter>
                        <Button variant="secondary" onClick={onClose}>Cancel</Button>
                        <Button type="button" variant="primary" onClick={handleSubmit}>Save Policy</Button>
                    </ModalFooter>
                </Modal>
            );
        });

        // NEW: Modal for reading a policy's content
        const PolicyReadModal = ({ isOpen, onClose, policy }) => {
            if (!policy) return null;

            const formatTimestamp = (timestamp) => {
                if (!timestamp || !timestamp.toDate) return 'N/A';
                return timestamp.toDate().toLocaleDateString('en-GB');
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <ModalHeader title={policy.title} onClose={onClose} />
                    <ModalBody>
                        <div className="policy-content" dangerouslySetInnerHTML={{ __html: policy.content }}></div>
                    </ModalBody>
                    <ModalFooter>
                        <div className="flex justify-between w-full items-center">
                            <span className="text-xs text-slate-500">Last updated: {formatTimestamp(policy.updatedAt || policy.createdAt)}</span>
                            <Button variant="secondary" onClick={onClose}>Close</Button>
                        </div>
                    </ModalFooter>
                </Modal>
            );
        };

        const PolicyBoardPage = ({ userProfile }) => {
            const { db } = useFirebase();
            const { data: policies, loading } = useCollection('policies');
            const [searchTerm, setSearchTerm] = useState('');
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingPolicy, setEditingPolicy] = useState(null);
            const [policyToDelete, setPolicyToDelete] = useState(null);
            const [policyToRead, setPolicyToRead] = useState(null); // State for the read modal

            const isAdmin = userProfile?.role === 'Admin';

            const categorizedPolicies = useMemo(() => {
                const filtered = policies.filter(p =>
                    (p.title?.toLowerCase() || '').includes(searchTerm.toLowerCase()) ||
                    (p.content?.toLowerCase() || '').includes(searchTerm.toLowerCase())
                );

                const grouped = filtered.reduce((acc, policy) => {
                    const category = policy.category || 'General';
                    if (!acc[category]) {
                        acc[category] = [];
                    }
                    acc[category].push(policy);
                    return acc;
                }, {});

                for (const category in grouped) {
                    grouped[category].sort((a, b) => a.title.localeCompare(b.title));
                }
                return grouped;
            }, [policies, searchTerm]);

            const sortedCategories = useMemo(() => Object.keys(categorizedPolicies).sort(), [categorizedPolicies]);

            const handleOpenModal = useCallback((policy = null) => { setEditingPolicy(policy); setModalOpen(true); }, []);
            const handleCloseModal = useCallback(() => { setEditingPolicy(null); setModalOpen(false); }, []);
            
            // Handlers for the new read modal
            const handleReadPolicy = useCallback((policy) => { setPolicyToRead(policy); }, []);
            const handleCloseReadModal = useCallback(() => { setPolicyToRead(null); }, []);

            const handleSavePolicy = useCallback(async (policyData) => {
                const { addDoc, updateDoc, doc, collection, serverTimestamp } = window.firebaseSDK;
                const dataToSave = { ...policyData };
                try {
                    if (dataToSave.id) {
                        const { id, ...data } = dataToSave;
                        await updateDoc(doc(db, 'policies', id), { ...data, updatedAt: serverTimestamp() });
                    } else {
                        await addDoc(collection(db, 'policies'), { ...dataToSave, createdAt: serverTimestamp(), updatedAt: serverTimestamp() });
                    }
                    handleCloseModal();
                } catch (error) {
                    console.error("Error saving policy:", error);
                }
            }, [db, handleCloseModal]);

            const handleDeleteConfirm = useCallback(async () => {
                if (!policyToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'policies', policyToDelete.id));
                } catch (error) {
                    console.error("Error deleting policy:", error);
                } finally {
                    setPolicyToDelete(null);
                }
            }, [db, policyToDelete]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Company Policy Board</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input type="text" placeholder="Search policies..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="input w-full sm:w-auto" />
                            {isAdmin && <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Policy</Button>}
                        </div>
                    </div>
                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                        <div className="space-y-6">
                            {sortedCategories.length > 0 ? sortedCategories.map(category => (
                                <div key={category}>
                                    <h3 className="text-xl font-semibold text-slate-100 mb-3 border-b border-slate-700 pb-2">{category}</h3>
                                    <ul className="space-y-2">
                                        {categorizedPolicies[category].map(policy => (
                                            <li key={policy.id} className="flex justify-between items-center p-3 rounded-lg bg-slate-800 hover:bg-slate-700/50 transition-colors">
                                                <button onClick={() => handleReadPolicy(policy)} className="flex-grow text-left group">
                                                    <span className="font-medium text-slate-200 group-hover:text-blue-400 transition-colors">{policy.title}</span>
                                                </button>
                                                {isAdmin && (
                                                    <div className="flex space-x-3 flex-shrink-0 ml-4">
                                                        <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(policy)} title="Edit Policy"/>
                                                        <Button variant="icon-delete" icon="fa-trash" onClick={() => setPolicyToDelete(policy)} title="Delete Policy"/>
                                                    </div>
                                                )}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            )) : (
                                <div className="text-center py-10 text-slate-400">
                                    <i className="fas fa-file-alt text-4xl mb-4"></i>
                                    <p>No policies found matching your search.</p>
                                </div>
                            )}
                        </div>
                    )}
                    <PolicyModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSavePolicy} policy={editingPolicy} />
                    <ConfirmationModal isOpen={!!policyToDelete} onClose={() => setPolicyToDelete(null)} onConfirm={handleDeleteConfirm} title="Delete Policy" message={`Are you sure you want to delete the policy "${policyToDelete?.title}"? This action cannot be undone.`} />
                    <PolicyReadModal isOpen={!!policyToRead} onClose={handleCloseReadModal} policy={policyToRead} />
                </Card>
            );
        };
        // --- END POLICY BOARD PAGE ---

        // --- START USER ACTIVITY PAGE ---
        const UserActivityPage = () => {
            const { db } = useFirebase();
            const { data: employees } = useCollection('employees');
            const employeeNameMap = useMemo(() => employees.reduce((acc, emp) => { if (emp.uid) acc[emp.uid] = emp.name; return acc; }, {}), [employees]);
            
            const [logs, setLogs] = useState([]);
            const [loading, setLoading] = useState(true);
            const [currentPage, setCurrentPage] = useState(1);
            const [pageCursors, setPageCursors] = useState({ 1: null }); // Store cursors in an object: { pageNum: cursorDoc }
            const [hasNextPage, setHasNextPage] = useState(false);
            const itemsPerPage = 15;

            // Helper function to safely format Firestore timestamps or other date formats
            const formatTimestamp = (timestamp) => {
                if (!timestamp) return 'No date';
                if (typeof timestamp.toDate === 'function') { return timestamp.toDate().toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }); }
                const date = new Date(timestamp);
                if (!isNaN(date.getTime())) { return date.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }); }
                return 'Invalid Date';
            };

            // REFACTORED: Data fetching logic is now self-contained within this effect.
            // It only re-runs when the database connection is ready or the page number changes.
            useEffect(() => {
                if (!db) return;

                const fetchLogsForPage = async () => {
                    setLoading(true);
                    const { collection, query, orderBy, limit, startAfter, getDocs } = window.firebaseSDK;
                    
                    // The cursor for the current page is the last document of the *previous* page.
                    const cursor = pageCursors[currentPage - 1];
                    
                    let q = query(
                        collection(db, 'userLogs'),
                        orderBy('timestamp', 'desc'),
                        limit(itemsPerPage + 1)
                    );

                    if (cursor) {
                        q = query(q, startAfter(cursor));
                    }
                    
                    try {
                        const documentSnapshots = await getDocs(q);
                        
                        setHasNextPage(documentSnapshots.docs.length > itemsPerPage);
                        
                        const newLogs = documentSnapshots.docs.slice(0, itemsPerPage).map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setLogs(newLogs);

                        // If there are logs, store the last one as the cursor for the CURRENT page,
                        // which will be used to fetch the NEXT page.
                        if (documentSnapshots.docs.length > 0) {
                            const lastVisible = documentSnapshots.docs[newLogs.length - 1];
                            if (lastVisible) {
                                setPageCursors(prev => ({ ...prev, [currentPage]: lastVisible }));
                            }
                        }
                    } catch (error) {
                        console.error("Error fetching user logs:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchLogsForPage();
            }, [db, currentPage]); // This dependency array is the key to the fix.

            const handleNext = () => {
                if (hasNextPage) {
                    setCurrentPage(prev => prev + 1);
                }
            };
            const handlePrevious = () => {
                if (currentPage > 1) {
                    setCurrentPage(prev => prev - 1);
                }
            };
            
            // Function to format log details for better readability
            const formatActivityDetails = (log) => {
                const { originalData, updatedData, action } = log;
                if (action === 'Add Employee' || action === 'Delete Employee') {
                    return `Details for ${log.targetName}`;
                }
                if (originalData && updatedData) {
                    const changes = [];
                    const allKeys = new Set([...Object.keys(originalData), ...Object.keys(updatedData)]);
                    
                    const formatValue = (val) => {
                        if (val === undefined || val === null) return 'empty';
                        if (Array.isArray(val)) return `[${val.join(', ')}]`;
                        // Handle objects gracefully to avoid "[object Object]"
                        if (typeof val === 'object' && val !== null) return JSON.stringify(val);
                        return String(val);
                    };

                    allKeys.forEach(key => {
                        if (key === 'id') return;
                        const originalValue = formatValue(originalData[key]);
                        const updatedValue = formatValue(updatedData[key]);
                        if (originalValue !== updatedValue) {
                            changes.push(`${key}: from '${originalValue}' to '${updatedValue}'`);
                        }
                    });
                    return changes.length > 0 ? changes.join('; ') : 'No detailed changes detected.';
                }
                return log.action || 'Unknown Action';
            };
            
            return (
                <Card>
                    <CardTitle>User Activity Log</CardTitle>
                    {loading ? (
                         <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i><p className="mt-2 text-slate-400">Loading Logs...</p></div>
                    ) : (
                        <>
                            <div className="overflow-x-auto">
                                <table className="min-w-full divide-y divide-slate-700">
                                    <thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Timestamp</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">User</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Action</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Target</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Activity Details</th></tr></thead>
                                    <tbody className="divide-y divide-slate-700">
                                        {logs.map(log => (<tr key={log.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{formatTimestamp(log.timestamp)}</td><td className="px-4 py-4 text-sm text-slate-300">{employeeNameMap[log.userId] || log.userId}</td><td className="px-4 py-4 text-sm text-slate-300">{log.action}</td><td className="px-4 py-4 text-sm text-slate-300">{log.targetName || 'N/A'}</td><td className="px-4 py-4 text-sm text-slate-300">{formatActivityDetails(log)}</td></tr>))}
                                    </tbody>
                                </table>
                            </div>
                            <div className="mt-6 flex justify-between items-center">
                                <Button variant="secondary" onClick={handlePrevious} disabled={currentPage === 1 || loading}>
                                    Previous
                                </Button>
                                <span className="text-sm text-slate-400">Page {currentPage}</span>
                                <Button variant="secondary" onClick={handleNext} disabled={!hasNextPage || loading}>
                                    Next
                                </Button>
                            </div>
                        </>
                    )}
                </Card>
            );
        };
        // --- END USER ACTIVITY PAGE ---

        // --- START SETTINGS PAGE ---
        
        const MemoAlertTab = () => {
            const { db } = useFirebase();
            const [memoContent, setMemoContent] = useState('');
            const [memoStatus, setMemoStatus] = useState('Deactive');
            const [loading, setLoading] = useState(true);
            const [saving, setSaving] = useState(false);

            useEffect(() => {
                if (!db) return;
                const { doc, onSnapshot } = window.firebaseSDK;
                const memoRef = doc(db, "settings", "memoAlert");
                const unsubscribe = onSnapshot(memoRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        setMemoContent(data.content || '');
                        setMemoStatus(data.status || 'Deactive');
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching memo: ", error);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [db]);

            const handleSave = async () => {
                if (!db) return;
                setSaving(true);
                const { doc, setDoc } = window.firebaseSDK;
                const memoRef = doc(db, "settings", "memoAlert");
                try {
                    await setDoc(memoRef, { content: memoContent, status: memoStatus }, { merge: true });
                } catch (error) {
                    console.error("Error saving memo: ", error);
                } finally {
                    setSaving(false);
                }
            };

            if (loading) {
                return <Card><CardTitle>Memo Alert</CardTitle><div>Loading...</div></Card>;
            }

            return (
                <Card>
                    <CardTitle>Memo Alert Settings</CardTitle>
                    <div className="space-y-6">
                        <div>
                            <label htmlFor="memoContent" className="block text-sm font-medium text-slate-400">Memo Content (5-6 lines recommended)</label>
                            <textarea
                                id="memoContent"
                                name="memoContent"
                                rows="6"
                                className="input mt-1"
                                value={memoContent}
                                onChange={(e) => setMemoContent(e.target.value)}
                                placeholder="Enter your memo alert here..."
                            ></textarea>
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-slate-400">Popup Status</label>
                            <div className="mt-2 space-y-2">
                                <div className="flex items-center">
                                    <input id="status-all" name="status" type="radio" value="Active All" checked={memoStatus === 'Active All'} onChange={(e) => setMemoStatus(e.target.value)} className="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500 bg-slate-600" />
                                    <label htmlFor="status-all" className="ml-3 block text-sm font-medium text-slate-300">Active All (Show to everyone)</label>
                                </div>
                                <div className="flex items-center">
                                    <input id="status-manager" name="status" type="radio" value="Active Shop Manager" checked={memoStatus === 'Active Shop Manager'} onChange={(e) => setMemoStatus(e.target.value)} className="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500 bg-slate-600" />
                                    <label htmlFor="status-manager" className="ml-3 block text-sm font-medium text-slate-300">Active Shop Manager (Only for Shop Managers)</label>
                                </div>
                                <div className="flex items-center">
                                    <input id="status-deactive" name="status" type="radio" value="Deactive" checked={memoStatus === 'Deactive'} onChange={(e) => setMemoStatus(e.target.value)} className="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500 bg-slate-600" />
                                    <label htmlFor="status-deactive" className="ml-3 block text-sm font-medium text-slate-300">Deactive (Do not show popup)</label>
                                </div>
                            </div>
                        </div>
                        <div className="flex justify-end">
                            <Button onClick={handleSave} disabled={saving} variant="primary" icon={saving ? 'fa-spinner fa-spin' : null}>
                                {saving ? 'Saving...' : 'Save Memo'}
                            </Button>
                        </div>
                    </div>
                </Card>
            );
        };
        const SettingsPage = ({ initialTab = 'shop' }) => {
            const { data: shops } = useCollection('shops');
            const { data: positions } = useCollection('positions');
            const { data: shifts } = useCollection('shifts');
            const [activeTab, setActiveTab] = useState(initialTab);

            // NEW: Effect to update the active tab if the initialTab prop changes
            // This allows the Dashboard to control which tab is shown.
            useEffect(() => {
                setActiveTab(initialTab);
            }, [initialTab]);
            
            // NEW: Timezone options for shop settings
            const timezoneOptions = [
                'Asia/Phnom_Penh',
                'Asia/Bangkok',
                'Asia/Ho_Chi_Minh',
                'Asia/Singapore',
                'Asia/Kuala_Lumpur',
                'Asia/Tokyo',
                'Europe/London',
                'America/New_York',
                'UTC'
            ];

            // Configuration for the generic CRUD component for Shops
            const shopFormFields = [
                { name: 'name', label: 'Shop Name', required: true }, 
                { name: 'latitude', label: 'Latitude' }, 
                { name: 'longitude', label: 'Longitude' }, 
                { name: 'radius', label: 'Radius (m)', type: 'number' }, 
                { name: 'timezone', label: 'Time Zone', type: 'select', options: timezoneOptions, required: true },
                { name: 'note', label: 'Note', fullWidth: true }
            ];
            const shopListColumns = [
                { header: 'Shop Name', accessor: 'name' }, 
                { header: 'Latitude', accessor: 'latitude' }, 
                { header: 'Longitude', accessor: 'longitude' }, 
                { header: 'Radius (m)', accessor: 'radius' },
                { header: 'Time Zone', accessor: 'timezone' },
                { header: 'Note', accessor: 'note' }
            ];
            
            // Configuration for the generic CRUD component for Positions
            const positionFormFields = [{ name: 'position', label: 'Position', required: true }, { name: 'note', label: 'Note', fullWidth: true }];
            const positionListColumns = [{ header: 'Position', accessor: 'position' }, { header: 'Note', accessor: 'note' }];

            // NEW: Configuration for Shifts
            const sortedShops = useMemo(() => [...shops].sort((a, b) => a.name.localeCompare(b.name)), [shops]);
            const shiftFormFields = [
                { name: 'shopName', label: 'Shop Name', type: 'select', options: sortedShops.map(s => s.name), required: true },
                { name: 'name', label: 'Shift Name', type: 'select', options: ['AM', 'PM', 'APM'], required: true }, 
                { name: 'startTime', label: 'Start Time', type: 'time', required: true }, 
                { name: 'endTime', label: 'End Time', type: 'time', required: true }, 
                { name: 'lateThreshold', label: 'Late After', type: 'time', required: true },
                { name: 'note', label: 'Note', fullWidth: true }
            ];
            const shiftListColumns = [
                { header: 'Shop Name', accessor: 'shopName' },
                { header: 'Shift Name', accessor: 'name' }, 
                { header: 'Start Time', accessor: 'startTime' }, 
                { header: 'End Time', accessor: 'endTime' }, 
                { header: 'Late After', accessor: 'lateThreshold' },
                { header: 'Note', accessor: 'note' }
            ];

            return (
                <TabbedPage tabs={{ shop: 'Shop & Shift Management', position: 'Position Management', memo: 'Memo Alert', triggerSalary: 'Trigger Salary' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="shop">
                        <SettingsCRUD title="Shop" collectionName="shops" items={shops} formFields={shopFormFields} listColumns={shopListColumns} />
                        <div className="mt-8">
                           <SettingsCRUD title="Shift" collectionName="shifts" items={shifts} formFields={shiftFormFields} listColumns={shiftListColumns} />
                        </div>
                    </div>
                    <div id="position"><SettingsCRUD title="Position" collectionName="positions" items={positions} formFields={positionFormFields} listColumns={positionListColumns} /></div>
                    <div id="memo"><MemoAlertTab /></div>
                    <div id="triggerSalary"><TriggerSalaryTab /></div>
                </TabbedPage>
            );
        }

        // NEW: Component for manually triggering payroll for a whole shop
        const TriggerSalaryTab = () => {
            const { db, userProfile } = useFirebase();
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [triggerConfirmed, setTriggerConfirmed] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processLog, setProcessLog] = useState([]);
            const [processComplete, setProcessComplete] = useState(false);

            // Fetch all data needed for calculations in one go, using one-time fetches for efficiency
            const { data: allShops, loading: shopsLoading } = useStaticCollection('shops');
            const { data: employees, loading: employeesLoading } = useStaticCollection('employees');
            const { data: attendance, loading: attendanceLoading } = useStaticCollection('attendance');
            const { data: leaveRequests, loading: leaveLoading } = useStaticCollection('leaveRequests');
            const { data: otRequests, loading: otLoading } = useStaticCollection('otRequests');
            const { data: staffLoans, loading: loansLoading } = useStaticCollection('staffLoans');
            const { data: employeeStates, loading: statesLoading } = useStaticCollection('employeeStates');
            const { data: salaryRevisions, loading: revisionsLoading } = useStaticCollection('salaryRevisions');

            const allDataReady = !shopsLoading && !employeesLoading && !attendanceLoading && !leaveLoading && !otLoading && !loansLoading && !statesLoading && !revisionsLoading;

            const handleTriggerPayroll = async () => {
                if (!triggerConfirmed || !selectedShop || !selectedMonth || !allDataReady) {
                    alert("Please select a shop, month, and confirm the action.");
                    return;
                }

                setIsProcessing(true);
                setProcessLog([]);
                setProcessComplete(false);

                const { writeBatch, collection, doc, serverTimestamp, getDocs, query, where } = window.firebaseSDK;

                const allData = { shops: allShops, employees, attendance, leaveRequests, otRequests, staffLoans, employeeStates, salaryRevisions };

                let employeesToProcess = [];
                if (selectedShop === 'ALL_SHOPS') {
                    employeesToProcess = employees.filter(e => e.status === 'Active');
                } else {
                    employeesToProcess = employees.filter(e => e.status === 'Active' && (Array.isArray(e.shop) ? e.shop.includes(selectedShop) : e.shop === selectedShop));
                }

                if (employeesToProcess.length === 0) {
                    setProcessLog(['No active employees found for the selected shop.']);
                    setIsProcessing(false);
                    return;
                }
                
                // Check if payroll for this shop/month already exists to prevent duplicates
                const payrollCheckQuery = query(collection(db, "payrollHistory"), where("month", "==", selectedMonth), where("shop", "==", selectedShop));
                const existingPayrollSnap = await getDocs(payrollCheckQuery);
                if (!existingPayrollSnap.empty) {
                     setProcessLog(prev => [...prev, `Warning: Payroll for ${selectedShop} for ${selectedMonth} may already exist. Please check history.`]);
                }

                setProcessLog(prev => [...prev, `Found ${employeesToProcess.length} employees. Starting payroll generation...`]);

                let successCount = 0;
                for (const employee of employeesToProcess) {
                    await new Promise(res => setTimeout(res, 50)); // Tiny delay for UI to update
                    setProcessLog(prev => [...prev, `[${successCount + 1}/${employeesToProcess.length}] Calculating for ${employee.name}...`]);

                    // Here we call the logic from our hook, but directly.
                    // This is a simplified version; in a real large-scale app, this would be a backend function.
                    const { inputs, calculations } = calculatePayrollForEmployee(employee, selectedMonth, allData);
                    
                    if (calculations.netSalary !== undefined) {
                        const batch = writeBatch(db);
                        
                        const shopName = Array.isArray(employee.shop) ? employee.shop[0] : employee.shop;
                        const payrollData = { month: selectedMonth, shop: shopName, employeeId: employee.id, employeeName: employee.name, baseSalary: calculations.baseSalary, netSalary: calculations.netSalary, manualInputs: inputs, calculations: calculations, createdAt: serverTimestamp() };
                        
                        const payrollDocRef = doc(collection(db, "payrollHistory"));
                        batch.set(payrollDocRef, payrollData);
                        
                        // Handle loan deduction logic
                        if (inputs.loanDeduction > 0) {
                            const activeLoan = staffLoans.find(loan => loan.staffId === employee.id && loan.status === 'Active');
                            if (activeLoan) {
                                const newTotalPaid = (activeLoan.totalPaid || 0) + inputs.loanDeduction;
                                const newBalance = activeLoan.loanAmount - newTotalPaid;
                                const newStatus = newBalance <= 0 ? 'Paid Off' : 'Active';
                                
                                const loanDocRef = doc(db, 'staffLoans', activeLoan.id);
                                batch.update(loanDocRef, { totalPaid: newTotalPaid, status: newStatus });
                                
                                const paymentDocRef = doc(collection(db, 'loanPayments'));
                                batch.set(paymentDocRef, { paymentDate: `${selectedMonth}-${new Date(selectedMonth.split('-')[0], selectedMonth.split('-')[1], 0).getDate()}`, staffId: employee.id, staffName: employee.name, shop: shopName, loanId: activeLoan.id, amountPaid: inputs.loanDeduction, remainingBalance: newBalance, note: "Paid via payroll trigger" });
                            }
                        }
                        
                        try {
                            await batch.commit();

                            // --- NEW: Step 3 - Process Savings Contribution (after batch commit) ---
                            if (calculations.savingsDeduction > 0) {
                                setProcessLog(prev => [...prev.slice(0, -1), `[${successCount + 1}/${employeesToProcess.length}] Saved for ${employee.name}. Processing savings...`]);
                                await Utils.manageSavingsContribution(
                                    db,
                                    employee.id,
                                    employee.name,
                                    calculations.savingsDeduction,
                                    payrollDocRef.id // Use the ID from the ref created for the batch
                                );
                            }
                            // --- END: Step 3 ---

                            successCount++;
                            setProcessLog(prev => [...prev.slice(0, -1), `[${successCount}/${employeesToProcess.length}] Successfully processed for ${employee.name}.`]);
                        } catch (error) {
                             setProcessLog(prev => [...prev.slice(0, -1), `[Error] Failed to save for ${employee.name}: ${error.message}`]);
                        }
                    } else {
                         setProcessLog(prev => [...prev.slice(0, -1), `[Skipped] Could not calculate salary for ${employee.name}.`]);
                    }
                }

                setProcessLog(prev => [...prev, `\nProcess finished. Successfully generated payroll for ${successCount} out of ${employeesToProcess.length} employees.`]);
                setIsProcessing(false);
                setProcessComplete(true);
                setTriggerConfirmed(false); // Reset confirmation checkbox
            };

            return (
                <Card>
                    <CardTitle>Trigger Bulk Salary Calculation</CardTitle>
                    <div className="max-w-xl mx-auto space-y-6">
                        <p className="text-slate-400">This tool allows you to generate payroll for all active employees in a selected shop for a specific month. The results will be saved to the Payroll History.</p>
                        
                        <div>
                            <label className="text-sm font-medium text-slate-400">Select Month</label>
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input" disabled={isProcessing} />
                        </div>

                        <div>
                            <label className="text-sm font-medium text-slate-400">Select Shop</label>
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select" disabled={isProcessing}>
                                <option value="">-- Select a Shop --</option>
                                <option value="ALL_SHOPS">All Shops (Admin Only)</option>
                                {allShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        </div>
                        
                        <div className="p-4 border border-yellow-600 bg-yellow-900/20 rounded-lg space-y-3">
                            <h4 className="font-bold text-yellow-300">Confirmation</h4>
                            <div className="flex items-start">
                                <input id="confirm-trigger" type="checkbox" checked={triggerConfirmed} onChange={e => setTriggerConfirmed(e.target.checked)} className="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600 mt-1" disabled={isProcessing} />
                                <label htmlFor="confirm-trigger" className="ml-3 text-sm text-slate-300">I understand that this action will generate and save payroll records for all employees in the selected shop and month. This may overwrite existing records if run multiple times.</label>
                            </div>
                        </div>

                        <Button 
                            onClick={handleTriggerPayroll} 
                            disabled={!triggerConfirmed || isProcessing || !selectedShop || !allDataReady}
                            variant="danger"
                            className="w-full py-3 text-base"
                        >
                            {isProcessing ? <><i className="fas fa-spinner fa-spin"></i> Processing...</> : <><i className="fas fa-bolt"></i> Trigger Payroll Generation</>}
                        </Button>
                        
                        {(isProcessing || processLog.length > 0) && (
                            <div className="mt-6">
                                <h4 className="font-semibold text-slate-200">Processing Log:</h4>
                                <pre className="mt-2 bg-slate-900/70 p-4 rounded-lg text-sm text-slate-300 h-64 overflow-y-auto font-mono">
                                    {processLog.join('\n')}
                                </pre>
                            </div>
                        )}
                        {processComplete && (
                             <div className="mt-4 p-4 text-center bg-green-900/50 border border-green-700 rounded-lg">
                                <p className="font-semibold text-green-300">Process Complete!</p>
                            </div>
                        )}
                    </div>
                </Card>
            );
        };

        // Generic component for CRUD operations (Create, Read, Update, Delete)
        function SettingsCRUD({ title, collectionName, items, formFields, listColumns }) {
            const { db } = useFirebase();
            const [editingItem, setEditingItem] = useState(null);
            const [itemToDelete, setItemToDelete] = useState(null);
            const getInitialState = useCallback(() => formFields.reduce((acc, field) => ({...acc, [field.name]: '' }), {}), [formFields]);
            const [newItem, setNewItem] = useState(getInitialState());

            useEffect(() => { setNewItem(getInitialState()); }, [getInitialState]);

            // NEW: Memoized grouping logic specifically for shifts
            const groupedItems = useMemo(() => {
                if (collectionName !== 'shifts') return null;

                // Group items by shopName
                const grouped = items.reduce((acc, item) => {
                    const groupKey = item.shopName || 'Uncategorized';
                    if (!acc[groupKey]) {
                        acc[groupKey] = [];
                    }
                    acc[groupKey].push(item);
                    return acc;
                }, {});

                // Sort shifts within each group (e.g., AM, PM)
                Object.keys(grouped).forEach(shop => {
                    grouped[shop].sort((a, b) => a.name.localeCompare(b.name));
                });

                return grouped;
            }, [items, collectionName]);

            // NEW: Get sorted keys for rendering the groups in alphabetical order
            const sortedGroupKeys = useMemo(() => {
                if (!groupedItems) return [];
                return Object.keys(groupedItems).sort();
            }, [groupedItems]);


            const handleSave = useCallback(async (item) => {
                const { doc, updateDoc, addDoc, collection } = window.firebaseSDK;
                try {
                    if (item.id) { const { id, ...data } = item; await updateDoc(doc(db, collectionName, id), data); } 
                    else { 
                        // NEW: Add a duplicate check specifically for new shifts before saving.
                        if (collectionName === 'shifts') {
                            const isDuplicate = items.some(
                                existingShift => existingShift.name === item.name && existingShift.shopName === item.shopName
                            );
                            if (isDuplicate) {
                                alert(`A shift with the name "${item.name}" already exists for "${item.shopName}". Please choose a different name.`);
                                return; // Stop the function to prevent saving a duplicate.
                            }
                        }
                        await addDoc(collection(db, collectionName), item); 
                    }
                    setEditingItem(null); setNewItem(getInitialState());
                } catch (e) { console.error(`Error saving ${collectionName}:`, e); }
            }, [db, collectionName, getInitialState, items]); // Added `items` to dependency array for duplicate check
            
            const handleDelete = useCallback(async () => {
                if (!itemToDelete) return;
                try { 
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, collectionName, itemToDelete.id)); 
                } catch (e) { 
                    console.error(`Error deleting ${collectionName}:`, e); 
                } finally {
                    setItemToDelete(null);
                }
            }, [db, collectionName, itemToDelete]);

            // Reusable form renderer
            const renderForm = (item, setItem, isNew = false) => (<form onSubmit={(e) => { e.preventDefault(); handleSave(item); }} className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 items-end p-4 bg-slate-800/50 rounded-lg mb-6 border border-slate-700">{formFields.map(field => (<div key={field.name} className={field.fullWidth ? 'col-span-full' : 'sm:col-span-1'}><label className="block text-sm font-medium text-slate-400">{field.label}</label>{field.type === 'select' ? (<select name={field.name} value={item[field.name] || ''} onChange={(e) => setItem({...item, [field.name]: e.target.value})} className="select" required={field.required}><option value="">Select {field.label}</option>{(field.options || []).map(option => (<option key={option} value={option}>{option}</option>))}</select>) : (<input type={field.type || 'text'} name={field.name} value={item[field.name] || ''} onChange={(e) => setItem({...item, [field.name]: e.target.value})} className="input" required={field.required} />)}</div>))}<div className="flex space-x-2 col-span-full md:col-span-1 self-end mt-4 md:mt-0"><Button type="submit" variant="primary" className="w-full">{isNew ? `Add ${title}` : 'Save'}</Button>{!isNew && <Button type="button" variant="secondary" onClick={() => setEditingItem(null)} className="w-full">Cancel</Button>}</div></form>);

            return (<Card><CardTitle>{title} Management</CardTitle>{renderForm(newItem, setNewItem, true)}<div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr>{listColumns.map(col => <th key={col.accessor} className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">{col.header}</th>)}<th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead>
                <tbody className="divide-y divide-slate-700">
                    {/* NEW: Conditional rendering for grouped shifts vs. flat lists */}
                    {collectionName === 'shifts' && groupedItems ? (
                        sortedGroupKeys.map(shopName => (
                            <React.Fragment key={shopName}>
                                <tr className="bg-slate-900">
                                    <td colSpan={listColumns.length + 1} className="px-4 py-2 text-sm font-semibold text-blue-400 tracking-wider">
                                        {shopName}
                                    </td>
                                </tr>
                                {groupedItems[shopName].map(item => (
                                    <tr key={item.id} className="hover:bg-slate-700/50">
                                        {editingItem?.id === item.id ? (
                                            <td colSpan={listColumns.length + 1} className="p-0">{renderForm(editingItem, setEditingItem)}</td>
                                        ) : (
                                            <>
                                                {listColumns.map(col => <td key={col.accessor} className="px-4 py-4 text-sm text-slate-300">{item[col.accessor]}</td>)}
                                                <td className="px-4 py-4 text-sm">
                                                    <div className="flex items-center justify-end gap-4">
                                                        <Button variant="icon-edit" icon="fa-edit" onClick={() => setEditingItem({ ...item })} />
                                                        <Button variant="icon-delete" icon="fa-trash" onClick={() => setItemToDelete(item)} />
                                                    </div>
                                                </td>
                                            </>
                                        )}
                                    </tr>
                                ))}
                            </React.Fragment>
                        ))
                    ) : (
                        items.map(item => (<tr key={item.id} className="hover:bg-slate-700/50">{editingItem?.id === item.id ? (<td colSpan={listColumns.length + 1} className="p-0">{renderForm(editingItem, setEditingItem)}</td>) : (<>{listColumns.map(col => <td key={col.accessor} className="px-4 py-4 text-sm text-slate-300">{item[col.accessor]}</td>)}<td className="px-4 py-4 text-sm"><div className="flex items-center justify-end gap-4"><Button variant="icon-edit" icon="fa-edit" onClick={() => setEditingItem({ ...item })} /><Button variant="icon-delete" icon="fa-trash" onClick={() => setItemToDelete(item)} /></div></td></>)}</tr>))
                    )}
                </tbody>
            </table></div><ConfirmationModal isOpen={!!itemToDelete} onClose={() => setItemToDelete(null)} onConfirm={handleDelete} title={`Delete ${title}`} message="Are you sure you want to delete this item?" /></Card>);
        }
        // --- END SETTINGS PAGE ---

        // --- START LAYOUT & MAIN APP COMPONENTS ---
        const Sidebar = memo(({ activePage, setActivePage, isSidebarOpen, toggleSidebar, userProfile }) => {
            const { isOnline } = useConnectivity();
            const sidebarLinks = useMemo(() => [ 
                { key: 'policy', icon: 'fa-book-open', label: 'Policy Board' },
                { key: 'employees', icon: 'fa-users', label: 'Employees' }, 
                { key: 'checkinme', icon: 'fa-user-clock', label: 'CheckInMe' }, 
                { key: 'savingProgram', icon: 'fa-piggy-bank', label: 'Saving Program' },
                { key: 'attendanceReport', icon: 'fa-file-alt', label: 'Attendance Report' }, 
                { key: 'loanManager', icon: 'fa-hand-holding-usd', label: 'Loan Manager' }, 
                { key: 'payroll', icon: 'fa-money-check-dollar', label: 'Payroll' }, 
                { key: 'expenseReport', icon: 'fa-file-invoice-dollar', label: 'Expense Report' }, 
                { key: 'userActivity', icon: 'fa-chart-line', label: 'User Activity' }, 
                { key: 'settings', icon: 'fa-cog', label: 'Settings' }, 
            ], []);

            // Filter sidebar links based on user permissions
            const availableLinks = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return sidebarLinks; // Admin & CEO see all available links
                if (!userProfile?.permissions) {
                    // If no permissions array exists, just show the policy board to be safe.
                    return sidebarLinks.filter(link => link.key === 'policy');
                }
                // Create a set of allowed pages, ensuring 'policy' is always included without duplication.
                const allowedPages = new Set(userProfile.permissions);
                allowedPages.add('policy');
        
                return sidebarLinks.filter(link => allowedPages.has(link.key));
            }, [userProfile, sidebarLinks]);

             const handleLinkClick = useCallback((pageKey) => { 
                setActivePage(pageKey); 
                if (window.innerWidth < 768) toggleSidebar(); // Close sidebar on mobile after navigation
            }, [setActivePage, toggleSidebar]);

            return (
                <aside className={`w-64 bg-slate-900 text-slate-300 p-4 flex flex-col transform ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 transition-transform duration-300 ease-in-out z-40 fixed md:relative h-full border-r border-slate-700`}>
                    <div className="flex items-center mb-2 px-2">
                        <i className="fas fa-building-user text-3xl text-blue-500 mr-3"></i>
                        <h1 className="text-2xl font-bold text-white">HR System</h1>
                    </div>
                    {/* Desktop Connectivity Status */}
                    <div className="px-2 mb-6 hidden md:block">
                        {isOnline ? (
                            <div className="flex items-center gap-2 text-xs text-green-400 font-medium">
                                <i className="fas fa-circle text-[8px]"></i> Online
                            </div>
                        ) : (
                            <div className="flex items-center gap-2 text-xs text-red-400 font-medium">
                                <i className="fas fa-circle text-[8px]"></i> Offline Mode
                            </div>
                        )}
                    </div>
                    <nav className="flex-grow">{availableLinks.map(link => (<a href="#" key={link.key} onClick={() => handleLinkClick(link.key)} className={`flex items-center py-3 px-4 rounded-lg transition duration-200 mt-2 ${activePage === link.key ? 'bg-blue-600 text-white shadow-lg' : 'hover:bg-slate-700/50'}`}><i className={`fas ${link.icon} w-6 mr-4`}></i><span className="font-medium">{link.label}</span></a>))}</nav>
                </aside>
            );
        });

        const Header = memo(({ pageTitle, toggleSidebar, userProfile, pendingLeaves, pendingOTs, onNotificationClick }) => {
            const { auth } = useFirebase();
            const { isOnline } = useConnectivity();

            const handleLogout = useCallback(async () => { 
                try { await window.firebaseSDK.signOut(auth); } 
                catch (error) { console.error("Error signing out: ", error); } 
            }, [auth]);

            const showNotifications = userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager';

            return (
                <header className="bg-slate-800/80 backdrop-blur-sm shadow-md p-4 flex justify-between items-center z-30 border-b border-slate-700 sticky top-0">
                    <div className="flex items-center min-w-0">
                        <button onClick={toggleSidebar} className="text-slate-400 focus:outline-none md:hidden mr-4"><i className="fas fa-bars text-2xl"></i></button>
                        <div className="flex flex-col">
                            <h2 className="text-xl sm:text-2xl font-bold text-slate-100 truncate">{pageTitle}</h2>
                             {/* Mobile Connectivity Status */}
                            <div className="md:hidden">
                                {isOnline ? (
                                    <div className="flex items-center gap-1.5 text-xs text-green-400 font-medium">
                                        <i className="fas fa-circle text-[8px]"></i> Online
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-1.5 text-xs text-red-400 font-medium">
                                        <i className="fas fa-circle text-[8px]"></i> Offline Mode
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                    <div className="flex items-center gap-2 sm:gap-4 flex-shrink-0">
                        {userProfile && (<div className="text-right hidden sm:block"><span className="text-sm text-slate-400">Welcome, </span><span className="font-medium text-slate-200">{userProfile.name}</span></div>)}
                        {showNotifications && (
                            <NotificationBell
                                pendingLeaves={pendingLeaves}
                                pendingOTs={pendingOTs}
                                onNotificationClick={onNotificationClick}
                            />
                        )}
                        <button onClick={handleLogout} title="Logout" className="bg-slate-700 text-slate-300 w-10 h-10 rounded-full hover:bg-slate-600 hover:text-white transition duration-150 flex items-center justify-center flex-shrink-0"><i className="fas fa-sign-out-alt"></i></button>
                    </div>
                </header>
            );
        });
        
        const Dashboard = ({ userProfile }) => {
            const [isSidebarOpen, setSidebarOpen] = useState(false);
            const [activePage, setActivePage] = useState('');
            const [initialCheckInMeTab, setInitialCheckInMeTab] = useState('checkInOut');
            const [showNotificationModal, setShowNotificationModal] = useState(true);
            const [memoAlert, setMemoAlert] = useState(null);
            const [isMemoVisible, setMemoVisible] = useState(false);
            const [memoShownThisSession, setMemoShownThisSession] = useState(false);
            const { db } = useFirebase();

            // Fetch memo alert data
            useEffect(() => {
                if (!db) return;
                const { doc, onSnapshot } = window.firebaseSDK;
                const memoRef = doc(db, "settings", "memoAlert");
                const unsubscribe = onSnapshot(memoRef, (doc) => {
                    if (doc.exists()) {
                        setMemoAlert(doc.data());
                    } else {
                        setMemoAlert(null);
                    }
                });
                return () => unsubscribe();
            }, [db]);

            // Logic to show memo modal
            useEffect(() => {
                if (memoAlert && userProfile && !memoShownThisSession) {
                    const shouldShow = 
                        (memoAlert.status === 'Active All') ||
                        (memoAlert.status === 'Active Shop Manager' && userProfile.role === 'Shop Manager');

                    if (shouldShow) {
                        setMemoVisible(true);
                        setMemoShownThisSession(true); // Ensure it only shows once per session/reload
                    }
                }
            }, [memoAlert, userProfile, memoShownThisSession]);
            
            // Set the default page based on user role and permissions
            useEffect(() => {
                if (userProfile) {
                    let defaultPage = 'checkinme'; // Fallback for staff
                    if (userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') {
                        // Default Admins/Managers to Employees page if they have access, otherwise their first permission
                        defaultPage = userProfile.permissions?.includes('employees') 
                            ? 'employees' 
                            : userProfile.permissions?.[0] || 'checkinme';
                    } else if (userProfile.permissions && userProfile.permissions.length > 0) {
                        // For other roles, default to their first permission
                        defaultPage = userProfile.permissions[0];
                    }
                    setActivePage(defaultPage);
                }
            }, [userProfile]);

            const toggleSidebar = useCallback(() => setSidebarOpen(prev => !prev), []);
            
            const { where } = window.firebaseSDK;
            const requestQueryConstraints = useMemo(() => {
                // This logic determines which pending requests to fetch for notifications.
                if (userProfile?.role === 'Admin') {
                    // Admin sees all pending requests from all shops.
                    return [where("status", "==", "Pending")];
                }
                if (userProfile?.role === 'Shop Manager') {
                    // Shop Manager is restricted to see pending requests only from their assigned shop.
                    return [
                        where("status", "==", "Pending"),
                        where("shop", "==", userProfile.shop || null) // Using || null for safety.
                    ];
                }
                // For any other role (e.g., Staff), return a query that will match no documents.
                // This prevents fetching unnecessary data for users who won't see the notifications.
                return [where("status", "==", "non-existent-status")];
            }, [userProfile]);

            const { data: pendingLeaves } = useCollection('leaveRequests', requestQueryConstraints);
            const { data: pendingOTs } = useCollection('otRequests', requestQueryConstraints);

            const handleNotificationClick = useCallback((targetTab) => {
                setActivePage('checkinme');
                setInitialCheckInMeTab(targetTab);
                setShowNotificationModal(false);
            }, []);

            const pageTitles = useMemo(() => ({ 
                employees: 'Employees', checkinme: 'CheckInMe', attendanceReport: 'Attendance Report', 
                loanManager: 'Loan Manager', payroll: 'Payroll', expenseReport: 'Expense Report', 
                userActivity: 'User Activity', settings: 'Settings', policy: 'Company Policy Board',
                savingProgram: 'Salary Saving Program',
            }), []);
            
            const totalPending = pendingLeaves.length + pendingOTs.length;
            // Renders the component for the currently active page
            const renderActivePage = useCallback(() => {
                const hasPermission = (userProfile?.role === 'Admin') || (userProfile?.role === 'CEO' && activePage !== 'sysConfig') || userProfile?.permissions?.includes(activePage) || activePage === 'policy';
                if (!activePage) return null;
                if (!hasPermission) return <Card><CardTitle>Access Denied</CardTitle><p>You do not have permission to view this page.</p></Card>;
                
                switch(activePage) {
                    case 'employees': return <EmployeesPage userProfile={userProfile} />;
                    case 'checkinme': return <CheckInMePage userProfile={userProfile} initialTab={initialCheckInMeTab} />;
                    case 'savingProgram': return <SavingsProgramPage userProfile={userProfile} />;
                    case 'attendanceReport': return <AttendanceReportPage userProfile={userProfile} />;
                    case 'loanManager': return <LoanManagerPage userProfile={userProfile} />;
                    case 'payroll': return <PayrollPage userProfile={userProfile} />;
                    case 'expenseReport': return <ExpenseReportPage userProfile={userProfile} />;
                    case 'policy': return <PolicyBoardPage userProfile={userProfile} />;
                    case 'userActivity': return <UserActivityPage />;
                    case 'settings': return <SettingsPage />;
                    default: return <UnderConstructionPage title="Page Not Found" />;
                }
            }, [activePage, userProfile, initialCheckInMeTab]);

            return (
                <div className="flex h-screen bg-slate-900 text-slate-300">
                    <Sidebar activePage={activePage} setActivePage={setActivePage} isSidebarOpen={isSidebarOpen} toggleSidebar={toggleSidebar} userProfile={userProfile} />
                    <div className="flex-1 flex flex-col overflow-hidden">
                        <Header 
                            pageTitle={pageTitles[activePage] || 'Dashboard'} 
                            toggleSidebar={toggleSidebar} 
                            userProfile={userProfile}
                            pendingLeaves={pendingLeaves}
                            pendingOTs={pendingOTs}
                            onNotificationClick={handleNotificationClick}
                        />
                        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-slate-800 p-4 sm:p-6">
                            {renderActivePage()}
                        </main>
                        <Modal isOpen={showNotificationModal && totalPending > 0 && userProfile?.role !== 'Staff'} onClose={() => setShowNotificationModal(false)} maxWidth="max-w-md">
                            <ModalHeader title="Pending Approvals" onClose={() => setShowNotificationModal(false)} />
                            <ModalBody>
                                <p className="text-slate-300">You have {totalPending} new request(s) waiting for your approval.</p>
                                <ul className="mt-4 space-y-2">
                                    {pendingLeaves.length > 0 && <li><span className="font-semibold">{pendingLeaves.length}</span> Leave Request(s)</li>}
                                    {pendingOTs.length > 0 && <li><span className="font-semibold">{pendingOTs.length}</span> OT Request(s)</li>}
                                </ul>
                            </ModalBody>
                            <ModalFooter>
                                <Button variant="secondary" onClick={() => setShowNotificationModal(false)}>Dismiss</Button>
                                <Button variant="primary" onClick={() => handleNotificationClick('leaveRequest')}>View Requests</Button>
                            </ModalFooter>
                        </Modal>
                        {memoAlert && (
                            <Modal isOpen={isMemoVisible} onClose={() => setMemoVisible(false)} maxWidth="max-w-lg">
                                <ModalHeader title="ដំណឹងប្រាប់ពត៏មាន" onClose={() => setMemoVisible(false)} />
                                <ModalBody>
                                    <pre className="text-slate-300 whitespace-pre-wrap font-sans">{memoAlert.content}</pre>
                                </ModalBody>
                                <ModalFooter>
                                    <Button variant="primary" onClick={() => setMemoVisible(false)}>ទទួលបាន</Button>
                                </ModalFooter>
                            </Modal>
                        )}
                    </div>
                </div>
            );
        };

        // Main App Component: Decides whether to show Login or Dashboard
        function AppContent() {
            const { currentUser, userProfile, loading } = useFirebase();
            
            if (loading) return <div className="flex items-center justify-center h-screen text-lg text-slate-300">Loading Application...</div>;
            
            return (
                <div>
                    {currentUser ? <Dashboard userProfile={userProfile} /> : <LoginPage />}
                </div>
            );
        }

        // Root Component with Firebase Provider
        function App() {
            return (
                <FirebaseProvider>
                    <AppDataProvider> {/* NEW: Wrap AppContent with the new data provider */}
                        <AppContent />
                    </AppDataProvider>
                </FirebaseProvider>
            );
        }

        // Render the application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <ConnectivityProvider>
                <App />
            </ConnectivityProvider>
        );
        // --- END LAYOUT & MAIN APP COMPONENTS ---
    </script>
</body>
</html>

