<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart HR Management System</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" xintegrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoVBL5gI9kLmbG0C+wFjr8bCqwY2SA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- FIX (Bug #1): Add DOMPurify library to sanitize HTML and prevent XSS attacks. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.10/purify.min.js" xintegrity="sha512-C3B32e/iyn0Lhj3mG4PzKAftE49fXUDf2l2Rk2HM71PaGNm1LpB4i/kXdiG5YkF1r83lWWI41D0OMfVYl43hJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- Quill Rich Text Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    
    <!-- Custom Styles & Fonts -->
    <style>
        @import url('https://rsms.me/inter/inter.css');
        html, body { 
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; /* Prevents horizontal scrolling */
        }
        /* Base input styles for a consistent look */
        .input, .select {
            margin-top: 0.25rem; display: block; width: 100%; padding: 0.5rem 0.75rem;
            border-width: 1px; border-color: #475569; border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); line-height: 1.5;
            background-color: #334155; color: #f1f5f9;
        }
        .input:focus, .select:focus {
            outline: 2px solid transparent; outline-offset: 2px;
            --tw-ring-color: #2563eb; border-color: #2563eb;
        }
        .input[disabled], .select[disabled] {
            background-color: #475569;
            cursor: not-allowed;
            opacity: 0.7;
        }
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Styles for rendered policy content */
        .policy-content p { margin-bottom: 1rem; line-height: 1.6; }
        .policy-content h1, .policy-content h2, .policy-content h3 { font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; color: #f1f5f9; border-bottom: 1px solid #475569; padding-bottom: 0.25rem; }
        .policy-content h1 { font-size: 1.5em; }
        .policy-content h2 { font-size: 1.25em; }
        .policy-content h3 { font-size: 1.1em; }
        .policy-content ul, .policy-content ol { margin-left: 1.5rem; margin-bottom: 1rem; }
        .policy-content ul { list-style-type: disc; }
        .policy-content ol { list-style-type: decimal; }
        .policy-content a { color: #60a5fa; text-decoration: underline; }
        .policy-content strong { font-weight: bold; }
        .policy-content em { font-style: italic; }
        .policy-content u { text-decoration: underline; }
        .policy-content pre { background-color: #1e293b; padding: 1rem; border-radius: 0.5rem; white-space: pre-wrap; }
        .policy-content blockquote { border-left: 4px solid #475569; padding-left: 1rem; margin-left: 0; color: #94a3b8; }
        /* NEW: Animation for success message */
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in-out {
            animation: fadeInOut 5s ease-in-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">
    <div id="root"></div>

    <!-- Firebase SDK Module -->
    <script type="module">
        // Firebase SDK imports
        import { initializeApp, deleteApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // MODIFIED (STEP 6.C): Added 'collectionGroup'
        // FIX: Removed the typo 'S' after the quotes
        import { getFirestore, collection, onSnapshot, doc, addDoc, updateDoc, deleteDoc, query, where, serverTimestamp, getDocs, writeBatch, enableIndexedDbPersistence, setDoc, orderBy, limit, startAfter, runTransaction, deleteField, collectionGroup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Make Firebase SDK available globally for the Babel script
        window.firebaseSDK = {
            initializeApp, deleteApp, getAuth, getFirestore, collection, onSnapshot,
            doc, addDoc, updateDoc, deleteDoc, query, where, serverTimestamp,
            signInWithEmailAndPassword, onAuthStateChanged, signOut, getDocs, writeBatch,
            enableIndexedDbPersistence, setDoc,
            // MODIFIED (STEP 6.C): Added 'collectionGroup'
            orderBy, limit, startAfter, createUserWithEmailAndPassword, runTransaction, deleteField, collectionGroup
        };
    </script>
    
    <!-- React Application Script -->
    <script type="text/babel">
        // --- START REACT & FIREBASE SETUP ---
        const { useState, useEffect, useMemo, useCallback, createContext, useContext, memo, useRef } = React;

        // ===================================================================================
        // === FIREBASE CONFIGURATION ===
        // To deploy this application for a new company, replace the values in the
        // `firebaseConfig` object below with the new project's configuration details
        // from the Firebase console. This is the ONLY place you need to change it.
        // ===================================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyB7_pnmwHj6aOeZRTykPvNusNFYReaTY6Q",
            authDomain: "hrsm-j.firebaseapp.com",
            projectId: "hrsm-j",
            storageBucket: "hrsm-j.appspot.com",
            messagingSenderId: "45063715478",
            appId: "1:45063715478:web:cc2dd21b83dd195771e0b7",
            measurementId: "G-8HQDG2LTKP"
        };

        // NEW: Dynamic Configuration Loader
        // Checks localStorage for an admin-saved configuration.
        // Falls back to the hardcoded config if nothing is found.
        let activeFirebaseConfig = firebaseConfig;
        try {
            const customConfigStr = localStorage.getItem('customFirebaseConfig');
            if (customConfigStr) {
                const customConfig = JSON.parse(customConfigStr);
                // Basic validation to ensure it's a valid config object
                if (customConfig.apiKey && customConfig.projectId) {
                    activeFirebaseConfig = customConfig;
                    console.log("Using custom Firebase configuration from localStorage.");
                }
            }
        } catch (error) {
            console.error("Failed to parse custom Firebase config, using default.", error);
        }

        // NEW: Connectivity Context for online/offline status
        const ConnectivityContext = createContext(null);
        const useConnectivity = () => useContext(ConnectivityContext);
        const ConnectivityProvider = ({ children }) => {
            const [isOnline, setIsOnline] = useState(navigator.onLine);

            useEffect(() => {
                const updateOnlineStatus = () => {
                    setIsOnline(navigator.onLine);
                };

                window.addEventListener('online', updateOnlineStatus);
                window.addEventListener('offline', updateOnlineStatus);

                // Set up a polling interval as a fallback for iframe environments where
                // the 'online'/'offline' events may not fire reliably. This checks the
                // navigator.onLine property directly every 3 seconds.
                const interval = setInterval(updateOnlineStatus, 3000);

                return () => {
                    window.removeEventListener('online', updateOnlineStatus);
                    window.removeEventListener('offline', updateOnlineStatus);
                    clearInterval(interval); // Cleanup on component unmount
                };
            }, []);

            return (
                <ConnectivityContext.Provider value={{ isOnline }}>
                    {children}
                </ConnectivityContext.Provider>
            );
        };

        // Firebase Configuration - MOVED TO TOP OF SCRIPT

        // Firebase Context for providing db and auth instances throughout the app
        const FirebaseContext = createContext(null);
        const useFirebase = () => useContext(FirebaseContext);

        const FirebaseProvider = ({ children }) => {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [currentUser, setCurrentUser] = useState(null);
            const [userProfile, setUserProfile] = useState(null);
            const [loading, setLoading] = useState(true);

            // Initialize Firebase and Auth state listener
            useEffect(() => {
                try {
                    const { initializeApp, getFirestore, getAuth, onAuthStateChanged, enableIndexedDbPersistence } = window.firebaseSDK;
                    const app = initializeApp(activeFirebaseConfig);
                    const dbInstance = getFirestore(app);
                    
                    // Enable offline persistence
                    enableIndexedDbPersistence(dbInstance).catch((err) => {
                        if (err.code === 'failed-precondition') console.warn("Firestore persistence failed: Multiple tabs open.");
                        else if (err.code === 'unimplemented') console.warn("Firestore persistence failed: Browser does not support it.");
                    });

                    const authInstance = getAuth(app);
                    setAuth(authInstance);
                    setDb(dbInstance);

                    const unsubscribe = onAuthStateChanged(authInstance, (user) => {
                        setCurrentUser(user);
                        if (!user) {
                            setUserProfile(null);
                            setLoading(false);
                        }
                    });
                    return () => unsubscribe();
                } catch (error) { 
                    console.error("Firebase initialization error:", error); 
                    setLoading(false);
                } 
            }, []);

            // Fetch user profile from Firestore when auth state changes
            useEffect(() => {
                if (!db || !currentUser) {
                    if (!currentUser) setLoading(false);
                    setUserProfile(null);
                    return;
                }

                setLoading(true);
                const { collection, query, where, onSnapshot } = window.firebaseSDK;
                const q = query(collection(db, "employees"), where("uid", "==", currentUser.uid));
                
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    if (!snapshot.empty) {
                        const userDoc = snapshot.docs[0];
                        setUserProfile({ id: userDoc.id, ...userDoc.data() });
                    } else {
                        console.warn("Authenticated user has no employee profile in Firestore.");
                        setUserProfile(null);
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching user profile:", error);
                    setLoading(false);
                });

                return () => unsubscribe();
            }, [db, currentUser]);

            const value = { db, auth, currentUser, userProfile, loading };
            return <FirebaseContext.Provider value={value}>{children}</FirebaseContext.Provider>;
        };
        
        // Custom hook for real-time Firestore collection data
        const useCollection = (collectionName, queryConstraints = []) => {
            const { db, currentUser } = useFirebase(); // Get currentUser
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!db || !currentUser) { // Add guard for currentUser
                    // If there's no user yet, we are in a loading state. Don't set loading to false.
                    setLoading(true);
                    return;
                }

                setLoading(true);
                const { collection, onSnapshot, query } = window.firebaseSDK;
                const q = query(collection(db, collectionName), ...queryConstraints);
                const unsubscribe = onSnapshot(q, (querySnapshot) => {
                    const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setData(items);
                    setLoading(false);
                }, (error) => {
                    console.error(`Error fetching collection ${collectionName}:`, error);
                    setLoading(false);
                });
                return () => unsubscribe();
            }, [db, currentUser, collectionName, JSON.stringify(queryConstraints)]); // Add currentUser to dependency array
            return { data, loading };
        };

        // Custom hook for one-time Firestore collection data fetch
        const useStaticCollection = (collectionName) => {
            // FIX: Get currentUser from useFirebase to check authentication status.
            const { db, currentUser } = useFirebase();
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                // FIX: Add a guard clause. Do not attempt to fetch data until both the
                // database connection is ready AND a user is authenticated.
                if (!db || !currentUser) {
                    // If there's no DB, something is wrong. If there's no user yet, we just wait.
                    if (!db) setLoading(false);
                    return;
                }
                
                const fetchData = async () => {
                    setLoading(true);
                    try {
                        const { collection, getDocs } = window.firebaseSDK;
                        const querySnapshot = await getDocs(collection(db, collectionName));
                        const items = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setData(items);
                    } catch (error) {
                        console.error(`Error performing one-time fetch for ${collectionName}:`, error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchData();
            // FIX: Add currentUser to the dependency array. This ensures the hook re-runs
            // once the user has been authenticated.
            }, [db, currentUser, collectionName]);

            return { data, loading };
        };
        
        // NEW: Standalone payroll calculation logic
        // MODIFIED: Added 'savingsWithdrawals' as a new argument
        // MODIFIED (STEP 5): Added 'savingsData' as a new argument
        const calculatePayrollForEmployee = (employee, selectedMonth, allData, manualLoanDeduction, savingsWithdrawals = [], savingsData = null) => {
            if (!employee || !selectedMonth) return { inputs: {}, calculations: {} };

            // NEW (Plan Step 1): Log the incoming withdrawal data to confirm it's being received.
            console.log(`[Payroll Calc] Received ${savingsWithdrawals.length} savings withdrawals for ${employee?.name} in ${selectedMonth}`, savingsWithdrawals);

            const { attendance, leaveRequests, otRequests, staffLoans, employeeStates, salaryRevisions, shops, shifts } = allData;

            // --- FIX: MOVED TIMEZONE LOGIC UP ---
            // We must get the employee's timezone *first* to correctly filter attendance by the local month.
            // 1. Determine the correct "home shop" name. Prioritize the new 'primaryShop' field.
            const employeeShopName = employee.primaryShop 
                ? employee.primaryShop // Use the new field if it exists
                : (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop); // Fallback to old logic
            
            // 2. Find the shop details from the allData.shops list
            const employeeShop = (shops || []).find(s => s.name === employeeShopName);
            
            // 3. Get the timezone. This will now be the timezone of the primary shop.
            const employeeShopTimezone = employeeShop?.timezone; // e.g., 'Asia/Phnom_Penh'

            // --- 1. Filter data for the selected employee and month ---
            
            // FIX: The original filter used .toISOString().startsWith(selectedMonth), which is timezone-unaware
            // and caused the bug. This new filter uses the employee's shop timezone to get the correct
            // set of attendance records for their local month.
            const monthAttendance = (attendance || []).filter(r => {
                if (r.employeeId !== employee.id) return false;
                if (!r.timestamp || !r.timestamp.toDate) return false;
                // Get the record's local date (e.g., '2025-11-12') using the employee's primary shop timezone
                const { localDate } = Utils.formatDateInTimezone(r.timestamp, employeeShopTimezone);
                // Check if that local date's month (e.g., '2025-11') matches the selected month
                return localDate.startsWith(selectedMonth);
            });
            const monthLeave = (leaveRequests || []).filter(r => r.staffId === employee.id && r.status === 'Approved' && r.leaveDate.startsWith(selectedMonth));
            const monthOT = (otRequests || []).filter(r => r.staffId === employee.id && r.status === 'Approved' && r.reqDate.startsWith(selectedMonth));
            const monthStates = (employeeStates || []).filter(r => r.staffId === employee.id && r.date.startsWith(selectedMonth));
            
            // --- FIX: Corrected loan-finding logic ---
            // The previous .find() logic was not deterministic and could grab the wrong loan
            // if an employee had multiple active loans.
            // This new logic finds ALL applicable loans and sorts them to get the one
            // with the most recent effectiveDate that is on or before the selected month.
            const applicableLoans = (staffLoans || [])
                .filter(l => l.staffId === employee.id && 
                             l.status === 'Active' && 
                             (!l.effectiveDate || l.effectiveDate.slice(0, 7) <= selectedMonth)
                )
                .sort((a, b) => (b.effectiveDate || '0000-00').localeCompare(a.effectiveDate || '0000-00'));
            
            const activeLoan = applicableLoans.length > 0 ? applicableLoans[0] : null;
            // --- END FIX ---

            // --- MOVED UP: Calculate Base Salary & Salary Per Day first, as it's needed for penalty calculation ---
            const [year, month] = selectedMonth.split('-').map(Number);
            const daysInMonth = new Date(year, month, 0).getDate();
            const applicableRevisions = (salaryRevisions || [])
                .filter(rev => rev.staffId === employee.id && rev.effectiveDate && rev.effectiveDate <= `${selectedMonth}-31` && rev.status === 'Approved')
                .sort((a, b) => b.effectiveDate.localeCompare(a.effectiveDate));
            
            // --- START FIX: Prevent NaN from employee.salary or updatedSalary ---
            // The (parseFloat(...) || 0) pattern is flawed, as (NaN || 0) results in NaN.
            // We must explicitly check for NaN.
            let parsedBaseSalary;
            if (applicableRevisions.length > 0) {
                parsedBaseSalary = parseFloat(String(applicableRevisions[0].updatedSalary).replace(/[^0-9.-]/g, ''));
            } else {
                parsedBaseSalary = parseFloat(String(employee.salary).replace(/[^0-9.-]/g, ''));
            }
            
            const baseSalary = isNaN(parsedBaseSalary) ? 0 : parsedBaseSalary;
            // --- END FIX ---
            
            const salaryPerDay = baseSalary > 0 && daysInMonth > 0 ? baseSalary / daysInMonth : 0;


            // --- 2. Calculate inputs automatically ---
            const leaveDays = monthLeave.reduce((sum, r) => sum + (parseFloat(r.numberOfDays) || 0), 0);
            const otDays = monthOT.reduce((sum, r) => sum + (parseFloat(r.numberOfOTDays) || 0), 0);
            
            // --- FIX: Separate auto-calculation from manual override ---
            // 1. Calculate the "pure" automatic loan deduction first.
            const autoLoanDeduction = (activeLoan ? parseFloat(activeLoan.agreedMonthlyDeduction) || 0 : 0);
            // 2. Use the manual override if it exists, otherwise use the auto-value.
            const loanDeduction = manualLoanDeduction !== undefined ? parseFloat(manualLoanDeduction) : autoLoanDeduction;
            // --- END FIX ---
            
            const totalLateDays = monthStates.filter(es => es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @')).length;

            // --- NEW (STEP 2): Get the employee's primary shop and their assigned timezone. This is crucial for all date calculations. ---
            // 1. Determine the correct "home shop" name. Prioritize the new 'primaryShop' field.
            // --- THIS BLOCK (lines 2198-2207) IS NOW MOVED to line 2158 ---
            /*
            const employeeShopName = employee.primaryShop 
                ? employee.primaryShop // Use the new field if it exists
                : (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop); // Fallback to old logic

            // 2. Find the shop details from the allData.shops list
            const employeeShop = (shops || []).find(s => s.name === employeeShopName);
            
            // 3. Get the timezone. This will now be the timezone of the primary shop.
            const employeeShopTimezone = employeeShop?.timezone; // e.g., 'Asia/Phnom_Penh'
            */

            const dailyRecords = {};
            monthAttendance.forEach(rec => {
                // FIX: Use the timezone-aware utility to get the date key based on the shop's local timezone.
                const { localDate: dayKey } = Utils.formatDateInTimezone(rec.timestamp, employeeShopTimezone);
                
                if (!dailyRecords[dayKey]) dailyRecords[dayKey] = [];
                // Push the original Javascript Date object for time difference calculations.
                dailyRecords[dayKey].push({ date: rec.timestamp.toDate(), type: rec.type });
            });
            
            let workDays = 0;
            let noCheckOutCount = 0;
            // FIX: Get today's date string formatted in the shop's local timezone to correctly identify past vs. present days.
            const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => new Date() }, employeeShopTimezone);


            Object.entries(dailyRecords).forEach(([dayKey, dayRecs]) => {
                const ins = dayRecs.filter(r => r.type === 'in').sort((a,b) => a.date - b.date);
                const outs = dayRecs.filter(r => r.type === 'out').sort((a,b) => b.date - a.date);
                if (ins.length > 0 && outs.length > 0) {
                    const diffHours = (outs[0].date.getTime() - ins[0].date.getTime()) / 3600000;
                    if (diffHours >= 7) workDays += 1;
                    else if (diffHours >= 4) workDays += 0.5;
                } else if (ins.length > 0 && dayKey < todayStr) {
                    noCheckOutCount += 1;
                }
            });

            // NEW: Calculate Absent days & Penalty for absence on a rejected leave day.
            const attendedDays = new Set(Object.keys(dailyRecords));
            let absentDays = 0;
            let rejectedLeavePenaltyAmount = 0; // Initialize penalty amount

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDay = new Date(year, month - 1, day);
                const loop_year = currentDay.getFullYear();
                const loop_month = String(currentDay.getMonth() + 1).padStart(2, '0');
                const loop_day = String(currentDay.getDate()).padStart(2, '0');
                const dayKey = `${loop_year}-${loop_month}-${loop_day}`;

                // FIX: Compare against the timezone-aware 'today' string instead of a local Date object.
                if (dayKey >= todayStr) break; // Don't count today or future days as absent.

                // An absence is a past day with no attendance record.
                if (!attendedDays.has(dayKey)) {
                    // FIX: Check if the employee was on approved leave for this day before marking as absent.
                    const isOnApprovedLeave = monthLeave.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                    
                    if (!isOnApprovedLeave) {
                        absentDays++; // Only count as absent if not on approved leave.

                        // Check if there was a REJECTED leave request for this absent day.
                        const hadRejectedLeave = (leaveRequests || []).some(
                            lr => lr.staffId === employee.id &&
                                  lr.status === 'Rejected' &&
                                  // Check if the absent day falls within the rejected leave period.
                                  dayKey >= lr.leaveDate && dayKey < lr.returnDate 
                        );
                        
                        if (hadRejectedLeave) {
                            // Apply penalty: Salary per day x 2
                            rejectedLeavePenaltyAmount += (salaryPerDay * 2);
                        }
                    }
                }
            }
            
            const noAttendance = absentDays + noCheckOutCount;

            // NEW: Calculate "Given Off Days" based on the total number of work days.
            const givenOffDays = Math.floor(workDays / 6.5);

            // FIX: Create the autoInputs object to be returned, now including noAttendance.
            // --- MODIFIED: Also add the new autoLoanDeduction field ---
            const autoInputs = { workDays, givenOffDays, otDays, leaveDays, totalLateDays, noCheckOutCount, loanDeduction, noAttendance, autoLoanDeduction: autoLoanDeduction };

            // --- 3. Perform Final Salary Calculations ---
            const engagements = monthStates.filter(es => es.statusState === 'Engagement' && es.status === 'Approved').reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);
            
            const lateDeductionsAmount = monthStates.filter(es => {
                if (!(es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @'))) return false;
                const hasLeave = (leaveRequests || []).some(lr => lr.staffId === es.staffId && lr.status === 'Approved' && es.date >= lr.leaveDate && es.date < lr.returnDate);
                return !hasLeave;
            }).reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);
            
            const otherDeductions = monthStates.filter(es => es.statusState === 'Deduction' && !es.note?.includes('CheckIn Late @')).reduce((sum, item) => sum + (parseFloat(item.amount) || 0), 0);

            // "No-CheckOut" is informational. Any associated monetary deduction is handled via the "Other Deductions" from Employee States.
            const daysToPayFor = (workDays || 0) + (givenOffDays || 0);
            const baseSalaryEarned = salaryPerDay * (daysToPayFor > 0 ? daysToPayFor : 0);
            const otSalary = salaryPerDay * (otDays || 0);
            
            // --- NEW (Plan Step 2, Part B): Calculate total savings withdrawal ---
            // Sum up all withdrawal amounts. This will be added to earnings.
            const totalSavingsWithdrawal = (savingsWithdrawals || []).reduce(
                (sum, tx) => sum + (parseFloat(tx.amountWithdrawn) || 0), 0
            );
            
            // MODIFIED (Plan Step 2, Part B): Add the savings withdrawal to the gross salary.
            const grossSalary = baseSalaryEarned + otSalary + engagements + totalSavingsWithdrawal;

            // --- NEW: Step 3 - Calculate Voluntary Savings Deduction ---
            let savingsDeduction = 0;
            // MODIFIED (STEP 5): This logic is now refactored to use the new 'savingsData' object
            // instead of the deprecated fields on the 'employee' object.
            if (
                savingsData && // Check if savingsData object exists
                savingsData.savingsProgramStatus === 'Active' &&
                parseFloat(savingsData.savingsPercentage) > 0 &&
                savingsData.savingsEffectiveMonth && 
                selectedMonth >= savingsData.savingsEffectiveMonth &&
                totalSavingsWithdrawal === 0 // Only deduct if no withdrawal
            ) {
                const percentage = parseFloat(savingsData.savingsPercentage) / 100;
                // Round the savings deduction
                savingsDeduction = Math.round(grossSalary * percentage);
            }
            // --- END: Step 3 ---
            
            // CORRECTED & UPDATED: Added the new penalty AND savings deduction to total deductions.
            const totalDeductions = loanDeduction + lateDeductionsAmount + otherDeductions + rejectedLeavePenaltyAmount + savingsDeduction;
            
            // FIX (Bug #4): Round the final netSalary to handle potential floating point inaccuracies.
            // Since KHR is the primary currency and has no decimal units, rounding to the nearest
            // whole number ensures a clean, accurate final value.
            const netSalary = Math.round(grossSalary - totalDeductions);

            // CORRECTED & UPDATED: Added new penalty and savings amounts to the returned calculations object.
            // MODIFIED (Plan Step 2): Add 'totalSavingsWithdrawal' to the calculations object.
            const calculations = { baseSalary, salaryPerDay, daysInMonth, baseSalaryEarned, otSalary, engagements, totalSavingsWithdrawal, grossSalary, otherDeductions, totalDeductions, netSalary, lateDeductionsAmount, rejectedLeavePenaltyAmount, savingsDeduction };

            return { inputs: autoInputs, calculations };
        };
        
        // NEW: Centralized Payroll Calculator Hook
        // MODIFIED: Added 'savingsWithdrawals' as a new argument and to the dependency array
        // MODIFIED (STEP 5): Added 'savingsData' as a new argument
        const usePayrollCalculator = (employee, selectedMonth, allData, manualLoanDeduction, savingsWithdrawals, savingsData) => {
            return useMemo(() => {
                // The complex logic is now in a separate function.
                // MODIFIED: Pass 'savingsWithdrawals' to the core function
                // MODIFIED (STEP 5): Pass 'savingsData' to the core function
                return calculatePayrollForEmployee(employee, selectedMonth, allData, manualLoanDeduction, savingsWithdrawals, savingsData);
            }, [employee, selectedMonth, allData, manualLoanDeduction, savingsWithdrawals, savingsData]); // MODIFIED (STEP 5): Added 'savingsData'
        };

        // NEW: Phase 3 - App Data Context for centralizing common data
        const AppDataContext = createContext(null);
        const useAppData = () => useContext(AppDataContext);

        const AppDataProvider = ({ children }) => {
            const { userProfile } = useFirebase();
            const { where } = window.firebaseSDK;
            
            // Create role-based query constraints to prevent permission errors.
            const employeeQueryConstraints = useMemo(() => {
                if (!userProfile) {
                    // While loading or logged out, fetch no employees.
                    return [where("uid", "==", "null")];
                }
                const { role, uid } = userProfile;
                if (role === 'Admin' || role === 'CEO' || role === 'Shop Manager') {
                    // Admins, CEOs, and Managers need the full list for dropdowns and management tasks.
                    // This assumes security rules permit them to read the whole collection.
                    return [];
                }
                // Staff role should only fetch their own document to avoid permission errors.
                return [where("uid", "==", uid)];
            }, [userProfile]);

            // Use one-time static fetches for data that doesn't change often.
            // This is more efficient than real-time listeners for this type of data.
            const { data: employees, loading: employeesLoading } = useCollection('employees', employeeQueryConstraints);
            const { data: shops, loading: shopsLoading } = useStaticCollection('shops');
            const { data: shifts, loading: shiftsLoading } = useStaticCollection('shifts');
            const { data: positions, loading: positionsLoading } = useStaticCollection('positions');

            // Combine all loading states into a single flag.
            const isLoading = employeesLoading || shopsLoading || shiftsLoading || positionsLoading;

            // Memoize the context value to prevent unnecessary re-renders of consumers.
            const value = useMemo(() => ({
                employees,
                shops,
                shifts,
                positions,
                isLoading
            }), [employees, shops, shifts, positions, isLoading]);

            return (
                <AppDataContext.Provider value={value}>
                    {children}
                </AppDataContext.Provider>
            );
        };
        // --- END REACT & FIREBASE SETUP ---

        // --- START UTILITY FUNCTIONS ---
        const Utils = {
            formatCurrency: (value, currency = 'KHR') => {
                if (value === null || value === undefined) return '';
                const num = parseFloat(String(value).replace(/[^0-9.-]/g, ''));
                if (isNaN(num)) return '';
                const options = { style: 'currency', currency: currency, minimumFractionDigits: currency === 'KHR' ? 0 : 2, maximumFractionDigits: currency === 'KHR' ? 0 : 2 };
                const locale = currency === 'KHR' ? 'km-KH' : 'en-US';
                let formatted = new Intl.NumberFormat(locale, options).format(num);
                if (currency === 'KHR') { formatted = formatted.replace('KHR', '៛').trim(); }
                return formatted;
            },
            formatRequestDate: (timestamp) => {
                if (!timestamp || !timestamp.toDate) return 'N/A';
                const date = timestamp.toDate();
                return `${date.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' })} | ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}`;
            },
            formatISOToDisplay: (isoDate) => {
                if (!isoDate || typeof isoDate !== 'string' || !isoDate.includes('-')) return isoDate || '';
                const [year, month, day] = isoDate.split('-');
                return `${day}-${month}-${year}`;
            },
            calculateWorkedDuration: (joinedDate, endDate) => { // Add endDate parameter
                if (!joinedDate) return 'N/A';
                const start = new Date(joinedDate);
                if (isNaN(start.getTime())) return 'N/A';
                const end = endDate ? new Date(endDate) : new Date(); // Use endDate if provided, else use now
                if (isNaN(end.getTime())) return 'N/A'; // Add a check for a valid end date

                let years = end.getFullYear() - start.getFullYear();
                let months = end.getMonth() - start.getMonth();
                let days = end.getDate() - start.getDate();
                if (days < 0) { months--; days += new Date(end.getFullYear(), end.getMonth(), 0).getDate(); }
                if (months < 0) { years--; months += 12; }
                return `${years}Y ${months}M ${days}D`;
            },
            // NEW: Timezone-aware date formatting utility
            formatDateInTimezone: (timestamp, timezone) => {
                // Return defaults if the timestamp is invalid
                if (!timestamp || !timestamp.toDate) {
                    return { localDate: 'N/A', displayDate: 'N/A', localTime: 'N/A' };
                }

                const date = timestamp.toDate();
                // Use the provided timezone, but fall back to the user's browser timezone if it's missing.
                const tz = timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;

                try {
                    // 'sv-SE' (Swedish) locale reliably gives the YYYY-MM-DD format.
                    const localDate = date.toLocaleDateString('sv-SE', { timeZone: tz });
                    
                    // 'en-GB' gives the DD/MM/YYYY format for display purposes.
                    const displayDate = date.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', timeZone: tz });

                    const localTime = date.toLocaleTimeString('en-US', {
                        hour: '2-digit', minute: '2-digit', hour12: true, timeZone: tz
                    });

                    return { localDate, displayDate, localTime };
                } catch (error) {
                    console.error("Invalid timezone provided to formatter:", timezone, error);
                    // If the provided timezone is invalid, fall back to basic UTC conversion to prevent crashes.
                    const localDate = date.toISOString().split('T')[0];
                    return { localDate, displayDate: localDate, localTime: date.toUTCString() };
                }
            },
            // Haversine formula to calculate distance between two lat/lon points
            getDistance: (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; // Earth's radius in metres
                const φ1 = lat1 * Math.PI/180; const φ2 = lat2 * Math.PI/180;
                const Δφ = (lat2-lat1) * Math.PI/180; const Δλ = (lon2-lon1) * Math.PI/180;
                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c; // Distance in metres
            },

            // --- NEW FUNCTION FOR SALARY SAVING PROGRAM (STEP 1) ---
            // This function transactionally processes a savings contribution to ensure data integrity.
            // It updates the employee's total balance and creates an audit log entry simultaneously.
            // MODIFIED (STEP 3): Added 'shop' parameter for denormalization.
            manageSavingsContribution: async (db, employeeId, employeeName, shop, amount, payrollId) => {
                const { doc, collection, serverTimestamp, runTransaction } = window.firebaseSDK;
                const savingsRef = doc(db, 'savingprogram', employeeId);
                const transactionRef = doc(collection(db, 'savingprogram', employeeId, 'transactions'));
        
                try {
                    // NEW: Log the data being passed into the function
                    console.log(`[Savings RUN] manageSavingsContribution called:`, { employeeId, employeeName, shop, amount, payrollId });

                    // Use a transaction to ensure both writes succeed or neither does.
                    await runTransaction(db, async (transaction) => {
                        const savingsDoc = await transaction.get(savingsRef);
                        
                        const parseSafeFloat = (val) => {
                            if (val === null || val === undefined) return 0;
                            const num = parseFloat(val);
                            return isNaN(num) ? 0 : num;
                        };
                        
                        let currentCredit = 0;
                        let currentWithdrawals = 0;
                        // --- NEW: Add currentBalance for the patch ---
                        let currentBalance = 0;

                        if (savingsDoc.exists()) {
                            // --- Doc EXISTS, read values ---
                            currentCredit = parseSafeFloat(savingsDoc.data().mySavingCredit);
                            currentWithdrawals = parseSafeFloat(savingsDoc.data().mySavingWithdrawalTotal);
                            // --- NEW: Read currentBalance ---
                            currentBalance = parseSafeFloat(savingsDoc.data().currentBalance);
                        }

                        // --- NEW: Data-Integrity Patch (as requested) ---
                        // This patch detects and fixes legacy data where mySavingCredit was 0
                        // (or null) but currentBalance was correct.
                        if ((currentCredit === 0 || currentCredit === null) && currentBalance > 0) {
                            console.warn(`[Savings Patch: Contribution] Fixing inconsistent data for ${employeeId}.`);
                            // Back-calculate the correct total credit.
                            // This new 'currentCredit' value will be used in the calculation below.
                            currentCredit = currentBalance + currentWithdrawals;
                        }
                        // --- END: Data-Integrity Patch ---
                        
                        // NEW: Log the values read from the database
                        console.log(`[Savings TX] Read values:`, { currentCredit, currentWithdrawals });

                        // --- Calculate new values ---
                        const newCredit = currentCredit + amount;
                        const newBalance = newCredit - currentWithdrawals;

                        // NEW: Log the values to be written
                        console.log(`[Savings TX] Calculated new values:`, { newCredit, newBalance });

                        if (savingsDoc.exists()) {
                            // --- Operation 1: UPDATE existing document ---
                            // This is the most significant change. We are now using 'update'
                            // instead of 'set with merge' for existing documents.
                            transaction.update(savingsRef, { 
                                currentBalance: newBalance, 
                                mySavingCredit: newCredit,
                                lastUpdated: serverTimestamp() 
                            });
                        } else {
                            // --- Operation 1: SET new document ---
                            // This path should only be hit if handleSaveParticipant failed.
                            // We set all data, knowing that percentage/join date might be missing.
                            // NEW: Log a warning if this path is taken
                            console.warn(`[Savings TX] Savings doc for ${employeeName} did not exist. Creating new doc.`);
                            transaction.set(savingsRef, { 
                                currentBalance: newBalance, 
                                mySavingCredit: newCredit, 
                                mySavingWithdrawalTotal: currentWithdrawals, // which is 0
                                employeeId: employeeId,
                                employeeName: employeeName,
                                shop: shop, 
                                lastUpdated: serverTimestamp()
                                // Note: savingsPercentage etc. will be missing if this path is hit,
                                // which indicates a bug in the 'Add Participant' logic.
                            });
                        }

                        // Operation 2: Create a new transaction log for this specific contribution.
                        const logData = {
                            employeeId: employeeId,
                            staffName: employeeName, // Denormalized field
                            shop: shop || 'N/A', // FIX: Prevent undefined 'shop' from failing the transaction
                            date: serverTimestamp(),
                            amountDeducted: amount,
                            type: 'contribution',
                            payrollId: payrollId
                        };
                        // NEW: Log the data being written to the subcollection
                        console.log(`[Savings TX] Writing log data:`, logData);
                        transaction.set(transactionRef, logData);
                    });
                    console.log(`[Savings SUCCESS] Savings contribution of ${amount} for ${employeeName} processed successfully.`);
                    return { success: true };
                } catch (error) {
                    console.error("Error within manageSavingsContribution transaction: ", error);
                    return { success: false, error: error };
                }
            },
            // --- NEW FUNCTION FOR SALARY SAVING PROGRAM (STEP 2: Payback) ---
            // This function transactionally processes a savings withdrawal.
            // MODIFIED (STEP 3): Added 'employeeName' and 'shop' parameters for denormalization.
            manageSavingsWithdrawal: async (db, employeeId, employeeName, shop, amount, note) => {
                const { doc, collection, serverTimestamp, runTransaction } = window.firebaseSDK;
                // MODIFIED (STEP 3): Path changed to new '/savingprogram' collection.
                const savingsRef = doc(db, 'savingprogram', employeeId);
                // MODIFIED (STEP 3): Path changed to new '/savingprogram/{id}/transactions' subcollection.
                const transactionRef = doc(collection(db, 'savingprogram', employeeId, 'transactions'));
        
                try {
                    await runTransaction(db, async (transaction) => {
                        const savingsDoc = await transaction.get(savingsRef);
        
                        if (!savingsDoc.exists()) {
                            throw new Error("Employee has no savings record to withdraw from.");
                        }
        
                        // --- BUG FIX: Correctly parse floats, handling NaN/undefined/null ---
                        const parseSafeFloat = (val) => {
                            if (val === null || val === undefined) return 0;
                            const num = parseFloat(val);
                            return isNaN(num) ? 0 : num;
                        };

                        const currentBalance = parseSafeFloat(savingsDoc.data().currentBalance);
                        let currentCredit = parseSafeFloat(savingsDoc.data().mySavingCredit);
                        const currentWithdrawals = parseSafeFloat(savingsDoc.data().mySavingWithdrawalTotal);
                        // --- END BUG FIX ---

                        // --- NEW: Data-Integrity Patch (as requested) ---
                        // This patch detects and fixes legacy data where mySavingCredit was 0
                        // (or null) but currentBalance was correct.
                        if ((currentCredit === 0 || currentCredit === null) && currentBalance > 0) {
                            console.warn(`[Savings Patch: Withdrawal] Fixing inconsistent data for ${employeeId}.`);
                            // Back-calculate the correct total credit.
                            currentCredit = currentBalance + currentWithdrawals;
                            
                            // We also update the database field immediately to fix it permanently.
                            // This is safe because we are already in a transaction.
                            transaction.update(savingsRef, { mySavingCredit: currentCredit });
                        }
                        // --- END: Data-Integrity Patch ---
                        
                        if (amount > currentBalance) {
                            throw new Error("Withdrawal amount cannot exceed the current balance.");
                        }
        
                        // MODIFIED: Implement new logic
                        const newWithdrawals = currentWithdrawals + amount;
                        
                        // --- REVERTING PREVIOUS FIX ---
                        // Now that 'currentCredit' is patched and correct, we can
                        // safely use the original "source of truth" formula.
                        const newBalance = currentCredit - newWithdrawals;
        
                        // Operation 1: Update the employee's total savings balance.
                        transaction.update(savingsRef, { 
                            currentBalance: newBalance, 
                            mySavingWithdrawalTotal: newWithdrawals, // NEW: Set the new withdrawal total
                            lastUpdated: serverTimestamp() 
                        });
        
                        // Operation 2: Create a new transaction log for this withdrawal.
                        // MODIFIED (STEP 3): Added 'staffName' and 'shop' for denormalization.
                        transaction.set(transactionRef, {
                            employeeId: employeeId,
                            staffName: employeeName, // Denormalized field
                            shop: shop, // Denormalized field
                            date: serverTimestamp(),
                            amountWithdrawn: amount,
                            type: 'withdrawal',
                            note: note || 'Manual payback'
                        });
                    });
                    console.log(`Savings withdrawal of ${amount} for ${employeeId} processed successfully.`);
                    return { success: true };
                } catch (error) {
                    console.error("Error within manageSavingsWithdrawal transaction: ", error);
                    return { success: false, error: error };
                }
            },
            
            // --- NEW: Function to REVERSE a savings withdrawal transactionally ---
            reverseSavingsWithdrawal: async (db, txToReverse) => {
                const { doc, serverTimestamp, runTransaction } = window.firebaseSDK;
                
                // Ensure we have the necessary IDs to build document references
                if (!txToReverse || !txToReverse.employeeId || !txToReverse.id) {
                    return { success: false, error: new Error("Invalid transaction data provided.") };
                }

                const savingsRef = doc(db, 'savingprogram', txToReverse.employeeId);
                const transactionRef = doc(db, 'savingprogram', txToReverse.employeeId, 'transactions', txToReverse.id);

                try {
                    await runTransaction(db, async (transaction) => {
                        const savingsDoc = await transaction.get(savingsRef);

                        if (!savingsDoc.exists()) {
                            throw new Error("Employee has no savings record. Cannot reverse.");
                        }

                        // Helper to safely parse floats
                        const parseSafeFloat = (val) => {
                            if (val === null || val === undefined) return 0;
                            const num = parseFloat(val);
                            return isNaN(num) ? 0 : num;
                        };

                        const currentBalance = parseSafeFloat(savingsDoc.data().currentBalance);
                        let currentCredit = parseSafeFloat(savingsDoc.data().mySavingCredit);
                        const currentWithdrawals = parseSafeFloat(savingsDoc.data().mySavingWithdrawalTotal);
                        const amountToReverse = parseSafeFloat(txToReverse.amountWithdrawn);

                        // --- Data-Integrity Patch (same as in other functions) ---
                        if ((currentCredit === 0 || currentCredit === null) && (currentBalance > 0 || currentWithdrawals > 0)) {
                            console.warn(`[Savings Patch: Reversal] Fixing inconsistent data for ${txToReverse.employeeId}.`);
                            currentCredit = currentBalance + currentWithdrawals;
                            // Update the main doc immediately since we're in a transaction
                            transaction.update(savingsRef, { mySavingCredit: currentCredit });
                        }
                        // --- END: Data-Integrity Patch ---
                        
                        // Calculate new totals
                        const newWithdrawalTotal = currentWithdrawals - amountToReverse;
                        
                        // Use the "source of truth" formula to recalculate the balance
                        const newBalance = currentCredit - newWithdrawalTotal;

                        // Operation 1: Update the main savings document
                        transaction.update(savingsRef, {
                            currentBalance: newBalance,
                            mySavingWithdrawalTotal: newWithdrawalTotal,
                            lastUpdated: serverTimestamp()
                        });
                        
                        // Operation 2: Delete the withdrawal transaction log
                        transaction.delete(transactionRef);
                    });
                    
                    console.log(`Savings withdrawal ${txToReverse.id} of ${amountToReverse} for ${txToReverse.employeeId} reversed successfully.`);
                    return { success: true };
                } catch (error) {
                    console.error("Error within reverseSavingsWithdrawal transaction: ", error);
                    return { success: false, error: error };
                }
            },
        };
        // --- END UTILITY FUNCTIONS ---

        // --- START REUSABLE UI COMPONENTS ---
        const Card = memo(({ children, className = '' }) => (<div className={`bg-slate-800/50 p-4 sm:p-6 rounded-lg shadow-lg border border-slate-700 ${className}`}>{children}</div>));
        const CardTitle = memo(({ children }) => (<h2 className="text-2xl font-semibold text-slate-100 mb-4 pb-4 border-b border-slate-700">{children}</h2>));
        const UnderConstructionPage = memo(({ title }) => (<Card><div className="text-center p-4 sm:p-8"><i className="fas fa-tools text-5xl text-yellow-400 mb-6"></i><h3 className="text-2xl sm:text-3xl font-bold text-slate-100">{title}</h3><p className="text-slate-400 mt-2">This page is under construction.</p></div></Card>));
        const Modal = ({ isOpen, onClose, children, maxWidth = "max-w-4xl" }) => { if (!isOpen) return null; return (<div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4 overflow-y-auto"><div className={`bg-slate-800 rounded-lg shadow-2xl w-full ${maxWidth} flex flex-col border border-slate-600`}>{children}</div></div>); };
        const ModalHeader = memo(({ title, onClose }) => (<div className="p-5 border-b border-slate-700 flex justify-between items-center flex-shrink-0"><h3 className="text-xl font-semibold text-slate-100">{title}</h3><Button variant="icon-close" onClick={onClose} className="text-2xl p-1">&times;</Button></div>));
        const ModalBody = memo(({ children }) => (<div className="p-6 flex-grow overflow-y-auto max-h-[calc(90vh-140px)]">{children}</div>));
        const ModalFooter = memo(({ children }) => (<div className="p-4 bg-slate-900/50 border-t border-slate-700 flex justify-end gap-4 rounded-b-lg flex-shrink-0">{children}</div>));
        
        // NEW: Reusable Button Component
        const Button = memo(({ children, onClick, variant = 'primary', icon, disabled = false, type = 'button', className = '', title = '' }) => {
            const baseClasses = 'font-medium rounded-lg shadow-sm transition-colors flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800';
            
            const variantStyles = {
                primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 px-4 py-2',
                secondary: 'bg-slate-600 text-slate-200 hover:bg-slate-500 focus:ring-slate-400 px-4 py-2',
                danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 px-4 py-2',
                success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500 px-4 py-2',
                'icon-edit': 'text-blue-400 hover:text-blue-300',
                'icon-delete': 'text-red-500 hover:text-red-400',
                'icon-approve': 'text-green-400 hover:text-green-300',
                'icon-reject': 'text-orange-400 hover:text-orange-300',
                'icon-view': 'text-blue-400 hover:text-blue-300',
                'icon-edit-alt': 'text-indigo-400 hover:text-indigo-300',
                'icon-close': 'text-slate-400 hover:text-white',
                'icon-add-time': 'text-teal-400 hover:text-teal-300', // New variant for the manual check-out icon
            };

            const finalClasses = `${baseClasses} ${variantStyles[variant] || variantStyles.primary} ${className}`;

            return (
                <button type={type} onClick={onClick} disabled={disabled} className={finalClasses} title={title}>
                    {icon && <i className={`fas ${icon}`}></i>}
                    {children}
                </button>
            );
        });

        const ConfirmationModal = ({ isOpen, onClose, onConfirm, title, message }) => { if (!isOpen) return null; return (<div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4"><div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-sm border border-slate-600"><div className="p-6"><h3 className="text-lg font-bold text-slate-100">{title}</h3><p className="mt-2 text-sm text-slate-400">{message}</p></div><div className="p-4 bg-slate-900/50 border-t border-slate-700 flex justify-end gap-4 rounded-b-lg"><Button variant="secondary" onClick={onClose}>Cancel</Button><Button variant="danger" onClick={onConfirm}>Confirm</Button></div></div></div>); };
        const TabbedPage = memo(({ tabs, activeTab, setActiveTab, children }) => {
            const renderContent = () => React.Children.toArray(children).find(child => child.props.id === activeTab) || <UnderConstructionPage title={tabs[activeTab]} />;
            return (<div><div className="mb-6 overflow-x-auto"><nav className="flex space-x-2 sm:space-x-4" aria-label="Tabs">{Object.entries(tabs).map(([key, title]) => (<a href="#" key={key} onClick={(e) => { e.preventDefault(); setActiveTab(key); }} className={`whitespace-nowrap rounded-md px-3 py-2 text-sm font-medium transition-colors ${activeTab === key ? 'bg-blue-600 text-white shadow' : 'text-slate-400 hover:bg-slate-700/50 hover:text-slate-200'}`}>{title}</a>))}</nav></div>{renderContent()}</div>);
        });
        const NotificationBell = ({ pendingLeaves = [], pendingOTs = [], onNotificationClick }) => {
            const [isOpen, setIsOpen] = useState(false);
            const totalCount = pendingLeaves.length + pendingOTs.length;

            const handleLeaveClick = () => {
                onNotificationClick('leaveRequest');
                setIsOpen(false);
            };

            const handleOTClick = () => {
                onNotificationClick('otRequest');
                setIsOpen(false);
            };

            return (
                <div className="relative">
                    <button onClick={() => setIsOpen(!isOpen)} className="relative text-slate-400 hover:text-white focus:outline-none">
                        <i className="fas fa-bell text-xl"></i>
                        {totalCount > 0 && (
                            <span className="absolute -top-2 -right-2 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-bold text-white">
                                {totalCount}
                            </span>
                        )}
                    </button>
                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-80 origin-top-right rounded-md bg-slate-800 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none border border-slate-700">
                            <div className="py-1">
                                <div className="px-4 py-2 text-sm font-semibold text-slate-100 border-b border-slate-700">Notifications</div>
                                {totalCount === 0 ? (
                                    <div className="px-4 py-3 text-sm text-slate-400">No new notifications</div>
                                ) : (
                                    <>
                                        {pendingLeaves.map(req => (
                                            <a href="#" key={req.id} onClick={handleLeaveClick} className="block px-4 py-3 text-sm text-slate-300 hover:bg-slate-700">
                                                <p className="font-medium text-slate-200">New Leave Request</p>
                                                <p className="text-xs text-slate-400">{req.staffName} - {req.numberOfDays} day(s)</p>
                                            </a>
                                        ))}
                                        {pendingOTs.map(req => (
                                            <a href="#" key={req.id} onClick={handleOTClick} className="block px-4 py-3 text-sm text-slate-300 hover:bg-slate-700">
                                                <p className="font-medium text-slate-200">New OT Request</p>
                                                <p className="text-xs text-slate-400">{req.numberOfOTDays} day(s)</p>
                                            </a>
                                        ))}
                                    </>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        // --- END REUSABLE UI COMPONENTS ---

        // --- START AUTHENTICATION PAGE ---
        const LoginPage = () => {
            const { auth, db } = useFirebase();
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [showPassword, setShowPassword] = useState(false);

            const handleLogin = useCallback(async (e) => {
                e.preventDefault();
                if (!auth || !db) { setError("System not ready. Please try again."); return; }
                setLoading(true);
                setError('');
                try {
                    const { signInWithEmailAndPassword, signOut, collection, query, where, getDocs, doc, updateDoc } = window.firebaseSDK;
                    const userCredential = await signInWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    
                    // Verify user has an active employee profile by email
                    const q = query(collection(db, "employees"), where("email", "==", user.email));
                    const querySnapshot = await getDocs(q);

                    if (querySnapshot.empty) {
                        await signOut(auth);
                        setError("No employee record found for this user.");
                    } else {
                        const employeeDoc = querySnapshot.docs[0];
                        const employeeData = employeeDoc.data();

                        if (employeeData.status !== 'Active') {
                            await signOut(auth);
                            setError("Your account is inactive. Please contact HR.");
                        } else {
                            // Automatically link UID if it's missing or incorrect.
                            if (!employeeData.uid || employeeData.uid !== user.uid) {
                                const employeeDocRef = doc(db, 'employees', employeeDoc.id);
                                await updateDoc(employeeDocRef, { uid: user.uid });
                            }
                            // Login is successful; onAuthStateChanged will handle profile loading.
                        }
                    }
                } catch (err) {
                    setError('Failed to login. Please check your credentials.');
                    console.error(err);
                } finally {
                    setLoading(false);
                }
            }, [auth, db, email, password]);

            return (
                <div className="flex items-center justify-center min-h-screen bg-slate-900">
                    <div className="w-full max-w-md p-8 space-y-8 bg-slate-800 rounded-2xl shadow-lg border border-slate-700">
                        <div className="text-center"><i className="fas fa-building-user text-5xl text-blue-500"></i><h2 className="mt-6 text-3xl font-bold text-white">HR Management System</h2><p className="mt-2 text-sm text-slate-400">Sign in to your account</p></div>
                        <form className="mt-8 space-y-6" onSubmit={handleLogin}>
                            <div className="rounded-md shadow-sm -space-y-px">
                                <div><input id="email-address" name="email" type="email" autoComplete="email" required className="appearance-none rounded-none relative block w-full px-3 py-3 border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded-t-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm" placeholder="Email address" value={email} onChange={(e) => setEmail(e.target.value)} /></div>
                                <div className="relative"><input id="password" name="password" type={showPassword ? "text" : "password"} autoComplete="current-password" required className="appearance-none rounded-none relative block w-full px-3 py-3 border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded-b-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} /><button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute inset-y-0 right-0 pr-3 flex items-center text-sm leading-5"><i className={`fas ${showPassword ? 'fa-eye-slash' : 'fa-eye'} text-slate-400 hover:text-slate-200`}></i></button></div>
                            </div>
                            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                            <div>
                                <Button type="submit" variant="primary" disabled={loading} className="w-full py-3">
                                    {loading ? <i className="fas fa-spinner fa-spin"></i> : 'Sign in'}
                                </Button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };
        // --- END AUTHENTICATION PAGE ---

        // --- START EMPLOYEES PAGE COMPONENTS ---

        // NEW: Phase 2 Refactoring - Custom Hook for Employee Fetching Logic
        const useFilteredEmployees = (userProfile, selectedShop) => {
            const { db, auth } = useFirebase();
            const [employees, setEmployees] = useState([]);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                if (!db || !userProfile || !auth?.currentUser) return () => {};
                
                const { collection, query, where, onSnapshot } = window.firebaseSDK;
                setLoading(true);
                let unsub1 = () => {};
                let unsub2 = () => {};

                const mergeResults = (res1, res2) => {
                    const combined = new Map();
                    res1.forEach(item => combined.set(item.id, item));
                    res2.forEach(item => combined.set(item.id, item));
                    setEmployees(Array.from(combined.values()));
                    setLoading(false);
                };

                const role = userProfile.role;
                
                if (role === 'Admin' || role === 'CEO') {
                    let results1 = [], results2 = [];
                    if (selectedShop) {
                        const q1 = query(collection(db, "employees"), where("shop", "==", selectedShop), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { results1 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Admin query 1 failed:", err));
                        const q2 = query(collection(db, "employees"), where("shop", "array-contains", selectedShop), where("status", "==", "Active"));
                        unsub2 = onSnapshot(q2, snap => { results2 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Admin query 2 failed:", err));
                    } else {
                        const q1 = query(collection(db, "employees"), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Admin all employees query failed:", err));
                    }
                } else if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (managedShops.length > 0) {
                        let results1 = [], results2 = [];
                        const q1 = query(collection(db, "employees"), where("shop", "in", managedShops), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { results1 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Manager query 1 failed:", err));
                        const q2 = query(collection(db, "employees"), where("shop", "array-contains-any", managedShops), where("status", "==", "Active"));
                        unsub2 = onSnapshot(q2, snap => { results2 = snap.docs.map(doc => ({ id: doc.id, ...doc.data() })); mergeResults(results1, results2); }, err => console.error("Manager query 2 failed:", err));
                    } else {
                        const q1 = query(collection(db, "employees"), where("uid", "==", userProfile.uid), where("status", "==", "Active"));
                        unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Manager self-query failed:", err));
                    }
                } else { // Staff role
                    const q1 = query(collection(db, "employees"), where("uid", "==", auth.currentUser.uid), where("status", "==", "Active"));
                    unsub1 = onSnapshot(q1, snap => { setEmployees(snap.docs.map(doc => ({ id: doc.id, ...doc.data() }))); setLoading(false); }, err => console.error("Staff query failed:", err));
                }

                return () => { unsub1(); unsub2(); };
            }, [db, userProfile, auth?.currentUser, selectedShop]);

            return { employees, loading };
        };

        // NEW: Phase 1 Refactoring - Employee Table Component
        // This component is now solely responsible for rendering the list of employees.
        // It receives the filtered list and action handlers as props.
        const EmployeeTable = memo(({ employees, userProfile, onView, onDelete }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Position</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Join Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Worked Dur.</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shift</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Tel</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Salary</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {employees.map(emp => (
                                <tr key={emp.id} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{emp.name}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.position}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.joinedDate}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.calculateWorkedDuration(emp.joinedDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.shift}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.tel}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 text-right whitespace-nowrap">{Utils.formatCurrency(emp.salary)}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            <Button variant="icon-view" icon="fa-eye" onClick={() => onView(emp)} />
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(emp)} />
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // Component: Employee Modal (Add/Edit Form)
        const EmployeeModal = ({ isOpen, onClose, onSave, employee, userProfile, isViewOnly = false, onSwitchToEdit }) => {
            const [formData, setFormData] = useState({});
            const [password, setPassword] = useState(''); // NEW: State for new user password
            const [showPassword, setShowPassword] = useState(false); // NEW: State for password visibility
            const [authError, setAuthError] = useState(''); // NEW: State for login creation errors
            
            // REFACTORED: Get global data from the AppDataProvider context.
            // This replaces multiple useCollection/useStaticCollection calls and removes the need for props.
            const { employees: allEmployees, shops, positions, shifts } = useAppData();

            // NEW: Filter the available shops in the dropdown based on the current user's role.
            const availableShopsForModal = useMemo(() => {
                if (!userProfile || !shops) {
                    return [];
                }
                // Admins and CEOs can assign new employees to any shop.
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return shops;
                }
                // Shop Managers can only assign new employees to the shops they manage.
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                // Other roles do not have permission to add employees, so return an empty list.
                return [];
            }, [userProfile, shops]);
            
            const supervisors = useMemo(() => (allEmployees || []).filter(e => e.role === 'Shop Manager' && e.status === 'Active'), [allEmployees]);

            const availablePages = useMemo(() => [
                { key: 'employees', label: 'Employees' },
                { key: 'checkinme', label: 'CheckInMe' },
                // REMOVED: Saving Program permission
                { key: 'attendanceReport', label: 'Attendance Report' },
                { key: 'payroll', label: 'Payroll' },
                { key: 'hrBanking', label: 'HR Banking' },
                { key: 'salaryReport', label: 'Salary Revise Report' },
                { key: 'expenseReport', label: 'Expense Report' },
                { key: 'userActivity', label: 'User Activity' },
                { key: 'policy', label: 'Policy Board' },
                { key: 'settings', label: 'Settings' },
            ], []);

            // Filter shifts based on the employee's assigned shop(s)
            const availableShifts = useMemo(() => {
                const employeeShops = Array.isArray(formData.shop) ? formData.shop : (formData.shop ? [formData.shop] : []);
                if (employeeShops.length === 0) return [];
                return (shifts || []).filter(s => s.shopName && employeeShops.includes(s.shopName));
            }, [shifts, formData.shop]);

            // Initialize form data when modal opens or employee data changes
            useEffect(() => {
                const initialData = employee 
                    ? { ...employee, permissions: employee.permissions || [] } 
                    : { name: '', sex: 'M', dob: '', nationId: '', tel: '', shop: '', joinedDate: '', salary: '', position: '', shift: 'AM', supervisor: '', status: 'Active', email: '', uid: '', role: 'Staff', address: '', permissions: [], statusChangeDate: '', reasonForLeaving: '', savingsProgramStatus: 'Inactive', savingsPercentage: 0, primaryShop: '' }; // Add primaryShop

                // When editing, ensure shop is in the right format based on role
                if (employee) {
                    if (employee.role === 'Shop Manager' || employee.role === 'Admin') {
                        initialData.shop = Array.isArray(employee.shop) ? employee.shop : (employee.shop ? [employee.shop] : []);
                    } else {
                        initialData.shop = Array.isArray(employee.shop) ? employee.shop[0] || '' : employee.shop || '';
                    }

                    // NEW: Set initial primaryShop
                    let defaultPrimary = '';
                    if (employee.primaryShop) {
                        defaultPrimary = employee.primaryShop;
                    } else if (Array.isArray(initialData.shop)) {
                        defaultPrimary = initialData.shop[0] || ''; // Default to first shop in array
                    } else {
                        defaultPrimary = initialData.shop; // Default to the single shop string
                    }
                    initialData.primaryShop = defaultPrimary;

                } else {
                    // For new employee, default based on Staff role
                    initialData.shop = '';
                    initialData.primaryShop = ''; // NEW
                }

                setFormData(initialData);
                setPassword(''); // NEW: Reset password on open
                setAuthError(''); // NEW: Reset error on open
            }, [employee, isOpen]);
            
            // Automatically grant 'checkinme' permission to Staff and Shop Manager roles
            useEffect(() => {
                if ((formData.role === 'Staff' || formData.role === 'Shop Manager') && !formData.permissions?.includes('checkinme')) {
                    setFormData(prev => ({ ...prev, permissions: [...new Set([...(prev.permissions || []), 'checkinme'])] }));
                }
            }, [formData.role]);

            const handleChange = useCallback((e) => {
                const { name, value, type, checked } = e.target;
                
                if (name === 'role') {
                    // When role changes, convert shop data structure accordingly
                    setFormData(prev => {
                        const newRole = value;
                        let newShopValue = prev.shop;
                        let newPermissions = prev.permissions || []; // Get current permissions
                        let newPrimaryShop = prev.primaryShop; // NEW
                        
                        if (newRole === 'Shop Manager' || newRole === 'Admin' || newRole === 'CEO') {
                            // convert to array if it's a string
                            newShopValue = Array.isArray(prev.shop) ? prev.shop : (prev.shop ? [prev.shop] : []);
                        } else {
                            // convert to string (first element) if it's an array
                            newShopValue = Array.isArray(prev.shop) ? prev.shop[0] || '' : prev.shop;
                            // NEW: If changing to single-shop, primaryShop MUST be that shop
                            newPrimaryShop = newShopValue;
                        }

                        // If role is changed to something other than Admin, remove the sysConfig permission.
                        
                        return { ...prev, role: newRole, shop: newShopValue, permissions: newPermissions, primaryShop: newPrimaryShop }; // NEW: return with newPrimaryShop
                    });
                } else if (type === 'checkbox') {
                    if (name === 'shop') { // Handling shop multi-select
                        setFormData(prev => {
                            const shopArray = Array.isArray(prev.shop) ? prev.shop : [];
                            const newShops = checked ? [...shopArray, value] : shopArray.filter(s => s !== value);
                            
                            // NEW: Check if primaryShop is still valid
                            let newPrimaryShop = prev.primaryShop;
                            if (!newShops.includes(newPrimaryShop)) {
                                newPrimaryShop = newShops[0] || ''; // Reset to first available, or empty
                            }
                            
                            return { ...prev, shop: newShops, primaryShop: newPrimaryShop }; // NEW: update primaryShop
                        });
                    } else { // Handling permissions
                        setFormData(prev => ({ ...prev, permissions: checked ? [...(prev.permissions || []), value] : (prev.permissions || []).filter(p => p !== value) }));
                        setFormData(prev => ({ ...prev, permissions: checked ? [...(prev.permissions || []), value] : (prev.permissions || []).filter(p => p !== value) }));
                    }
                } else {
                    // NEW: Handle single-shop change
                    if (name === 'shop') { 
                        // This is for single-shop roles
                        setFormData(prev => ({ ...prev, [name]: value, primaryShop: value })); // Also update primaryShop
                    } else {
                        // This handles 'primaryShop' dropdown change and all others
                        setFormData(prev => ({ ...prev, [name]: value }));
                    }
                }
            }, []);

            // Handlers for salary input to allow typing numbers and format on blur
            const handleSalaryChange = useCallback((e) => { setFormData(prev => ({ ...prev, salary: e.target.value.replace(/[^0-9.]/g, '') })); }, []);
            const handleSalaryBlur = useCallback((e) => { setFormData(prev => ({ ...prev, salary: Utils.formatCurrency(e.target.value) })); }, []);
            const handleSubmit = useCallback(async (e) => { 
                e.preventDefault(); 
                setAuthError(''); // Reset error on each submission attempt
                const dataToSave = { ...formData };
                // Final check to ensure staff have a string for shop, not array
                if (dataToSave.role !== 'Shop Manager' && dataToSave.role !== 'Admin' && dataToSave.role !== 'CEO') {
                    dataToSave.shop = Array.isArray(dataToSave.shop) ? dataToSave.shop[0] || '' : dataToSave.shop;
                }

                // --- MODIFIED: Handle user credential creation without changing global auth state ---
                if (!dataToSave.id && dataToSave.email && password) { // This is a new employee with login details
                    if (password.length < 6) {
                        setAuthError('Password must be at least 6 characters long.');
                        return; // Stop the save process
                    }
                    let tempApp = null;
                    try {
                        const { initializeApp, getAuth, createUserWithEmailAndPassword, deleteApp } = window.firebaseSDK;
                        // Initialize a temporary, secondary Firebase app to create the user.
                        // This prevents the main app's auth state from changing.
                        const tempAppName = `temp-user-creation-${Date.now()}`;
                        tempApp = initializeApp(activeFirebaseConfig, tempAppName);
                        const tempAuth = getAuth(tempApp);

                        // Create the user on the temporary instance.
                        const userCredential = await createUserWithEmailAndPassword(tempAuth, dataToSave.email, password);
                        // Add the new UID to the employee data object that will be saved to Firestore
                        dataToSave.uid = userCredential.user.uid;
                        
                    } catch (error) {
                        console.error("Error creating auth user:", error);
                        if (error.code === 'auth/email-already-in-use') {
                            setAuthError('This email is already in use by another login.');
                        } else {
                            setAuthError('Failed to create user login. Please check the email format.');
                        }
                        return; // Stop the save process if auth creation fails
                    } finally {
                        // Clean up the temporary app instance.
                        if (tempApp) {
                            await window.firebaseSDK.deleteApp(tempApp);
                        }
                    }
                } else if (!dataToSave.id && dataToSave.email && !password) {
                    setAuthError('Password is required when creating a new user with an email address.');
                    return; // Stop the save process
                }
                // --- End modified logic ---

                onSave(dataToSave); 
            }, [onSave, formData, password]);
            const isFormerEmployee = formData.status === 'Terminated' || formData.status === 'Resigned';

            return (
                <Modal isOpen={isOpen} onClose={onClose}>
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={isViewOnly ? 'View Employee Details' : (employee ? 'Edit Employee' : 'Add New Employee')} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {/* Employee Personal & Job Details */}
                                <div><label className="text-sm font-medium text-slate-400">Name</label><input name="name" value={formData.name || ''} onChange={handleChange} className="input" required disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Sex</label><select name="sex" value={formData.sex || 'M'} onChange={handleChange} className="select" disabled={isViewOnly}><option value="M">Male</option><option value="F">Female</option></select></div>
                                <div><label className="text-sm font-medium text-slate-400">Date of Birth</label><input type="date" name="dob" value={formData.dob || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Nation ID</label><input name="nationId" value={formData.nationId || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Tel No</label><input name="tel" value={formData.tel || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                
                                {(formData.role === 'Shop Manager' || formData.role === 'Admin' || formData.role === 'CEO') ? (
                                    <div className="md:col-span-full">
                                        <label className="text-sm font-medium text-slate-400">Shops</label>
                                        <div className="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-4 p-4 border border-slate-600 rounded-lg bg-slate-700/50">
                                            {(availableShopsForModal || []).map(shop => (
                                                <div key={shop.id} className="flex items-center">
                                                    <input id={`shop-${shop.id}`} name="shop" type="checkbox" value={shop.name} checked={(Array.isArray(formData.shop) ? formData.shop : []).includes(shop.name)} onChange={handleChange} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600" disabled={isViewOnly} />
                                                    <label htmlFor={`shop-${shop.id}`} className="ml-3 text-sm text-slate-300">{shop.name}</label>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ) : (
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Shop</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={isViewOnly}>
                                            <option value="">Select Shop</option>
                                            {(availableShopsForModal || []).map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                        </select>
                                    </div>
                                )}

                                {/* --- NEW: Primary Shop Dropdown --- */}
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Primary Shop (for Timezone)</label>
                                    <select 
                                        name="primaryShop" 
                                        value={formData.primaryShop || ''} 
                                        onChange={handleChange} 
                                        className="select"
                                        // Disable if not a multi-shop role OR if no shops are assigned
                                        disabled={isViewOnly || !(formData.role === 'Shop Manager' || formData.role === 'Admin' || formData.role === 'CEO') || !formData.shop || formData.shop.length === 0}
                                    >
                                        <option value="">Select Primary Shop</option>
                                        {/* Populate options based on whether shop is an array (multi-shop) 
                                          or a string (single-shop, in which case it will be disabled anyway
                                          but this makes it robust).
                                        */}
                                        {Array.isArray(formData.shop) ? (
                                            formData.shop.map(shopName => (
                                                <option key={shopName} value={shopName}>{shopName}</option>
                                            ))
                                        ) : (
                                            formData.shop && <option value={formData.shop}>{formData.shop}</option>
                                        )}
                                    </select>
                                </div>
                                {/* --- END: Primary Shop Dropdown --- */}

                                <div><label className="text-sm font-medium text-slate-400">Joined Date</label><input type="date" name="joinedDate" value={formData.joinedDate || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Salary</label><input name="salary" value={formData.salary || ''} onChange={handleSalaryChange} onBlur={handleSalaryBlur} className="input" disabled={isViewOnly || (userProfile?.role === 'Shop Manager' && employee)} /></div>
                                <div><label className="text-sm font-medium text-slate-400">Position</label><select name="position" value={formData.position || ''} onChange={handleChange} className="select" disabled={isViewOnly}><option value="">Select Position</option>{(positions || []).map(p => <option key={p.id} value={p.position}>{p.position}</option>)}</select></div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Shift</label>
                                    <select name="shift" value={formData.shift || ''} onChange={handleChange} className="select" disabled={isViewOnly}>
                                        <option value="">Select Shift</option>
                                        {availableShifts.map(s => <option key={s.id} value={s.name}>{s.name} ({s.shopName})</option>)}
                                    </select>
                                </div>
                                <div><label className="text-sm font-medium text-slate-400">Supervisor</label><select name="supervisor" value={formData.supervisor || ''} onChange={handleChange} className="select" disabled={isViewOnly}><option value="">Select Supervisor</option>{supervisors.map(e => <option key={e.id} value={e.name}>{e.name}</option>)}</select></div>
                                <div><label className="text-sm font-medium text-slate-400">Staff Status</label><select name="status" value={formData.status || 'Active'} onChange={handleChange} className="select" disabled={isViewOnly}><option>Active</option><option>Terminated</option><option>Resigned</option></select></div>
                                {isFormerEmployee && (
                                    <>
                                        <div><label className="text-sm font-medium text-slate-400">Status Change Date</label><input type="date" name="statusChangeDate" value={formData.statusChangeDate || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                        <div className="md:col-span-2"><label className="text-sm font-medium text-slate-400">Reason for Leaving</label><textarea name="reasonForLeaving" value={formData.reasonForLeaving || ''} onChange={handleChange} className="input" rows="2" disabled={isViewOnly}></textarea></div>
                                    </>
                                )}
                                <div className="md:col-span-full"><hr className="border-slate-700 my-2"/></div>
                                {/* System & Permissions */}
                                <div><label className="text-sm font-medium text-slate-400">Email</label><input type="email" name="email" value={formData.email || ''} onChange={handleChange} className="input" disabled={isViewOnly} /></div>
                                
                                {/* NEW: Password field for new employee creation */}
                                {!employee && (
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Password (for new user login)</label>
                                        <div className="relative">
                                            <input
                                                type={showPassword ? "text" : "password"}
                                                value={password}
                                                onChange={(e) => setPassword(e.target.value)}
                                                className="input"
                                                placeholder="Min. 6 characters"
                                                disabled={isViewOnly}
                                            />
                                            <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute inset-y-0 right-0 pr-3 flex items-center text-sm leading-5">
                                                <i className={`fas ${showPassword ? 'fa-eye-slash' : 'fa-eye'} text-slate-400 hover:text-slate-200`}></i>
                                            </button>
                                        </div>
                                    </div>
                                )}
                                
                                <div><label className="text-sm font-medium text-slate-400">Role</label><select name="role" value={formData.role || 'Staff'} onChange={handleChange} className="select" disabled={isViewOnly || userProfile?.role === 'Shop Manager'}><option>Admin</option><option>CEO</option><option>Shop Manager</option><option>Staff</option></select></div>
                                <div className="md:col-span-2 lg:col-span-3"><label className="text-sm font-medium text-slate-400">Address</label><textarea name="address" value={formData.address || ''} onChange={handleChange} className="input" rows="3" disabled={isViewOnly}></textarea></div>

                                {/* --- REMOVED: Salary Saving Program Section from this modal --- */}

                                <div className="md:col-span-2 lg:col-span-3">
                                    <label className="text-sm font-medium text-slate-400">Page Permissions</label>
                                    <div className="mt-2 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 p-4 border border-slate-600 rounded-lg bg-slate-700/50">
                                        {availablePages.map(page => {
                                            // A Shop Manager cannot grant permissions for these specific pages.
                                            const isRestrictedForManager = userProfile?.role === 'Shop Manager' && ['expenseReport', 'userActivity', 'settings'].includes(page.key);
                                            
                                            // The checkbox is only disabled if the modal is view-only or if a Shop Manager is viewing a restricted permission.
                                            const isDisabled = isViewOnly || isRestrictedForManager;

                                            return (
                                                <div key={page.key} className="flex items-center">
                                                    <input id={`perm-${page.key}`} type="checkbox" value={page.key} checked={formData.permissions?.includes(page.key)} onChange={handleChange} disabled={isDisabled} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600" />
                                                    <label htmlFor={`perm-${page.key}`} className={`ml-3 text-sm ${isDisabled ? 'text-slate-500' : 'text-slate-300'}`}>{page.label}</label>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                {/* NEW: Display auth errors here */}
                                {authError && <p className="text-red-400 text-sm md:col-span-full">{authError}</p>}
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            {isViewOnly ? (
                                <>
                                    <Button type="button" variant="secondary" onClick={onClose}>Close</Button>
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                        <Button type="button" variant="primary" icon="fa-edit" onClick={(e) => { e.preventDefault(); onSwitchToEdit(); }}>Edit</Button>
                                    )}
                                </>
                            ) : (
                                <>
                                    <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                                    <Button type="submit" variant="primary" className="px-6">Save</Button>
                                </>
                            )}
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // NEW: ActiveEmployeesTab component to fix the reference error.
        const ActiveEmployeesTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isViewOnly, setIsViewOnly] = useState(false);
            const [editingEmployee, setEditingEmployee] = useState(null);
            const [employeeToDelete, setEmployeeToDelete] = useState(null);
            
            // REFACTORED: Get global shops data from the App Data context provider.
            const { shops } = useAppData();
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState(''); // NEW: State for the search term

            // Set the initial shop filter based on the user's role and assigned shop(s).
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    // Managers with multiple shops default to 'All My Shops' (empty string).
                    // Single-shop users default to their assigned shop.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Use the custom hook to fetch and filter employees based on the selected shop.
            const { employees, loading } = useFilteredEmployees(userProfile, selectedShop);

            // NEW: Further filter the employees based on the search term.
            const searchedEmployees = useMemo(() => {
                if (!searchTerm) {
                    return employees;
                }
                return employees.filter(emp => 
                    emp.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }, [employees, searchTerm]);
            
            // NEW: Function to handle exporting the current employee list to an Excel file.
            const handleExportExcel = useCallback(() => {
                // Format the data to have more readable headers and select specific fields.
                const dataToExport = searchedEmployees.map(emp => ({ 
                    'Name': emp.name,
                    'Email': emp.email,
                    'Position': emp.position,
                    'Shop': Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop,
                    'Join Date': emp.joinedDate,
                    'Worked Duration': Utils.calculateWorkedDuration(emp.joinedDate),
                    'Shift': emp.shift,
                    'Telephone': emp.tel,
                    'Salary (KHR)': parseFloat(String(emp.salary).replace(/[^0-9.-]/g, '')) || 0
                }));

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Active Employees");
                
                // Set column widths for better readability
                worksheet["!cols"] = [ 
                    { wch: 25 }, // Name
                    { wch: 30 }, // Email
                    { wch: 20 }, // Position
                    { wch: 20 }, // Shop
                    { wch: 15 }, // Join Date
                    { wch: 18 }, // Worked Duration
                    { wch: 10 }, // Shift
                    { wch: 15 }, // Telephone
                    { wch: 18 }  // Salary
                ];
                
                XLSX.writeFile(workbook, "Active_Employees_Report.xlsx");
            }, [searchedEmployees]); // Dependency on the filtered list ensures the correct data is exported.
            
            // Determine which shops are available for filtering in the dropdown.
            const availableShopsForFilter = useMemo(() => {
                if (!userProfile || !shops) {
                    return [];
                }
                // Admins and CEOs can filter by any shop.
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return shops;
                }
                // Shop Managers with multiple assigned shops can filter by those shops.
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    // Map the array of shop names to an array of shop objects for the dropdown.
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                // Other roles (or managers with a single shop) do not see the filter dropdown.
                return [];
            }, [userProfile, shops]);
            
            const handleOpenModal = (employee = null, viewOnly = false) => {
                setEditingEmployee(employee);
                setIsViewOnly(viewOnly);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setEditingEmployee(null);
                setIsModalOpen(false);
            };

            // Handler for saving a new or edited employee.
            const handleSaveEmployee = async (formData) => {
                const { addDoc, updateDoc, doc, collection } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                
                try {
                    if (id) {
                        await updateDoc(doc(db, 'employees', id), dataToSave);
                    } else {
                        await addDoc(collection(db, 'employees'), dataToSave);
                    }
                    handleCloseModal();
                } catch (error) {
                    console.error("Error saving employee:", error);
                }
            };
            
            const handleDeleteEmployee = (employee) => {
                setEmployeeToDelete(employee);
            };

            const confirmDelete = async () => {
                if (!employeeToDelete) return;
                const { doc, updateDoc } = window.firebaseSDK;
                try {
                    const employeeRef = doc(db, 'employees', employeeToDelete.id);
                    // Instead of deleting, we change the status to 'Terminated'.
                    await updateDoc(employeeRef, { status: 'Terminated', statusChangeDate: new Date().toISOString().substring(0, 10), reasonForLeaving: 'Deleted from active list' });
                } catch (error) {
                    console.error("Error 'deleting' (terminating) employee:", error);
                } finally {
                    setEmployeeToDelete(null);
                }
            };

            // Render logic for the Active Employees tab.
            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        {/* MODIFIED: The title now includes the total count of displayed employees. */}
                        <h3 className="text-xl font-semibold text-slate-100">
                            Active Employee List - {searchedEmployees.length}
                        </h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            {/* NEW: Search input field added */}
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            {/* NEW: Excel export button added. */}
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel} disabled={loading}>
                                Excel
                            </Button>
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Employee</Button>
                            )}
                        </div>
                    </div>

                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div>
                    ) : (
                        <EmployeeTable
                            employees={searchedEmployees}
                            userProfile={userProfile}
                            onView={(emp) => handleOpenModal(emp, true)}
                            onDelete={handleDeleteEmployee}
                        />
                    )}

                    <EmployeeModal
                        isOpen={isModalOpen}
                        onClose={handleCloseModal}
                        onSave={handleSaveEmployee}
                        employee={editingEmployee}
                        userProfile={userProfile}
                        isViewOnly={isViewOnly}
                        onSwitchToEdit={() => setIsViewOnly(false)}
                    />

                    <ConfirmationModal
                        isOpen={!!employeeToDelete}
                        onClose={() => setEmployeeToDelete(null)}
                        onConfirm={confirmDelete}
                        title="Confirm Deletion"
                        message={`Are you sure you want to remove ${employeeToDelete?.name}? Their status will be set to 'Terminated'.`}
                    />
                </Card>
            );
        };

        // NEW: Modal for adding/editing salary revisions
        const SalaryRevisionModal = ({ isOpen, onClose, onSave, revision, userProfile }) => {
            // Get global data from context
            const { shops, employees } = useAppData();
            const [formData, setFormData] = useState({});

            // Memoized lists for dropdowns
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!formData.shopName) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shopName) && emp.status === 'Active';
                });
            }, [formData.shopName, employees]);

            // Initialize form
            useEffect(() => {
                const initialData = revision 
                    ? { ...revision }
                    : {
                        reqDate: new Date().toISOString().substring(0, 10),
                        effectiveDate: new Date().toISOString().substring(0, 10),
                        shopName: '',
                        staffId: '',
                        reviseAmount: '',
                        baseSalary: 0,
                        updatedSalary: 0,
                        status: 'Pending'
                    };
                setFormData(initialData);
            }, [revision, isOpen]);
            
            // REMOVED: The two separate useEffect hooks for salary calculation have been removed.

            // REVISED: Consolidated all salary calculation logic into a single, more robust handleChange function.
            // This prevents race conditions and ensures data consistency when the form is updated.
            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                
                setFormData(prev => {
                    const newFormData = { ...prev, [name]: value };

                    // When the shop selection changes...
                    if (name === 'shopName') {
                        // ...reset all employee-specific fields.
                        newFormData.staffId = '';
                        newFormData.staffName = '';
                        newFormData.baseSalary = 0;
                        newFormData.reviseAmount = '';
                        newFormData.updatedSalary = 0;
                    }

                    // When the staff selection changes...
                    if (name === 'staffId') {
                        const selectedEmployee = employees.find(emp => emp.id === value);
                        if (selectedEmployee) {
                            // ...update the staff name and recalculate salaries from scratch.
                            newFormData.staffName = selectedEmployee.name;
                            const currentSalary = parseFloat(String(selectedEmployee.salary).replace(/[^0-9.-]/g, '')) || 0;
                            const revisedAmount = parseFloat(newFormData.reviseAmount) || 0;
                            newFormData.baseSalary = currentSalary;
                            newFormData.updatedSalary = currentSalary + revisedAmount;
                        } else {
                            // ...or reset if the staff is deselected.
                            newFormData.staffName = '';
                            newFormData.baseSalary = 0;
                            newFormData.updatedSalary = parseFloat(newFormData.reviseAmount) || 0;
                        }
                    }

                    // When only the revision amount changes...
                    if (name === 'reviseAmount') {
                        // ...recalculate just the final salary.
                        const base = parseFloat(newFormData.baseSalary) || 0;
                        const revise = parseFloat(value) || 0;
                        newFormData.updatedSalary = base + revise;
                    }

                    return newFormData;
                });
            }, [employees]); // Dependency on employees is needed to find staff details.
            
            const handleSubmit = (e) => {
                e.preventDefault();
                onSave(formData);
            };
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-3xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={revision ? "Edit Salary Revision" : "Add New Salary Revision"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div><label className="text-sm">Request Date</label><input type="date" name="reqDate" value={formData.reqDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Effective Date</label><input type="date" name="effectiveDate" value={formData.effectiveDate || ''} onChange={handleChange} className="input" required /></div>
                                
                                <div>
                                    <label className="text-sm">Shop Name</label>
                                    <select name="shopName" value={formData.shopName || ''} onChange={handleChange} className="select" required>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                    </select>
                                </div>
                                
                                <div>
                                    <label className="text-sm">Staff Name</label>
                                    <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shopName}>
                                        <option value="">Select Staff</option>
                                        {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                    </select>
                                </div>

                                <div><label className="text-sm">Base Salary</label><input value={Utils.formatCurrency(formData.baseSalary)} className="input" disabled /></div>
                                <div><label className="text-sm">Revise Amount</label><input type="number" name="reviseAmount" value={formData.reviseAmount || ''} onChange={handleChange} className="input" required /></div>

                                <div className="md:col-span-2">
                                   <label className="text-sm">Updated Salary</label>
                                   <input value={Utils.formatCurrency(formData.updatedSalary)} className="input" disabled />
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button 
                                type="submit" 
                                variant="primary"
                                // FIX: Corrected disabled logic to use this component's state
                                // It should check for staffId and reviseAmount from its own formData.
                                disabled={!formData.staffId || !formData.reviseAmount}
                            >
                                {/* FIX: Corrected button text. */}
                                Save Revision
                            </Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // Component: Salary Revise Report Tab
        const SalaryReviseReportTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { where } = window.firebaseSDK;
            const { shops } = useAppData();
            
            // State for modal and filters
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingRevision, setEditingRevision] = useState(null);
            const [revisionToDelete, setRevisionToDelete] = useState(null);
            const [selectedShop, setSelectedShop] = useState('');
            // REVISED: Removed month filter state
            // const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            // REVISED: Added search term state
            const [searchTerm, setSearchTerm] = useState('');

            // Data fetching
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shopName", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return managedShops.length > 0 ? [where("shopName", "in", managedShops)] : [where("shopName", "==", "null")];
                }
                return [where("staffId", "==", userProfile.id || null)];
            }, [userProfile]);
            
            const { data: revisions, loading } = useCollection('salaryRevisions', queryConstraints);
            
            const filteredRevisions = useMemo(() => {
                return revisions
                    .filter(rev => 
                        (!selectedShop || rev.shopName === selectedShop) &&
                        // REVISED: Replaced month filter with search term filter
                        (!searchTerm || (rev.staffName && rev.staffName.toLowerCase().includes(searchTerm.toLowerCase())))
                    )
                    .sort((a,b) => (b.reqDate || '').localeCompare(a.reqDate || ''));
            // REVISED: Updated dependency array
            }, [revisions, selectedShop, searchTerm]);

            // Handlers
            const handleOpenModal = (revision = null) => { setEditingRevision(revision); setIsModalOpen(true); };
            const handleCloseModal = () => { setEditingRevision(null); setIsModalOpen(false); };
            
            const handleSaveRevision = async (formData) => {
                const { addDoc, updateDoc, doc, collection, serverTimestamp } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                
                try {
                    if (id) {
                        await updateDoc(doc(db, 'salaryRevisions', id), dataToSave);
                    } else {
                        await addDoc(collection(db, 'salaryRevisions'), { ...dataToSave, status: 'Pending', createdAt: serverTimestamp() });
                    }
                    handleCloseModal();
                } catch (error) { console.error("Error saving salary revision:", error); }
            };
            
            const handleUpdateStatus = async (revision, newStatus) => {
                const { updateDoc, doc } = window.firebaseSDK;
                try {
                    const revisionRef = doc(db, 'salaryRevisions', revision.id);
                    await updateDoc(revisionRef, { status: newStatus });
                    
                    // CRITICAL STEP: If approved, update the employee's main salary record.
                    // REMOVED: This line is removed to ensure historical payroll accuracy.
                    // The payroll calculator will now refer to the revision history instead.
                    /*
                    if (newStatus === 'Approved') {
                        const employeeRef = doc(db, 'employees', revision.staffId);
                        await updateDoc(employeeRef, { salary: revision.updatedSalary });
                    }
                    */
                } catch (error) { console.error("Error updating revision status:", error); }
            };
            
            const handleDeleteConfirm = async () => {
                if (!revisionToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'salaryRevisions', revisionToDelete.id));
                } catch (error) { console.error("Error deleting revision:", error); }
                finally { setRevisionToDelete(null); }
            };

            const canManage = userProfile?.role === 'Admin' || userProfile?.role === 'CEO';
            
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Salary Revision Management</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Shops</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                            {/* REVISED: Replaced month input with text search input */}
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {canManage && <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Revision</Button>}
                        </div>
                    </div>
                    {loading ? <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div> : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Req Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Effective Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Base Salary</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Revise Amount</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold uppercase">Updated Salary</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold uppercase">Status</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {filteredRevisions.map(rev => (
                                    <tr key={rev.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm">{Utils.formatISOToDisplay(rev.reqDate)}</td>
                                        <td className="px-4 py-4 text-sm">{Utils.formatISOToDisplay(rev.effectiveDate)}</td>
                                        <td className="px-4 py-4 text-sm">{rev.shopName}</td>
                                        <td className="px-4 py-4 text-sm">{rev.staffName}</td>
                                        <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(rev.baseSalary)}</td>
                                        <td className={`px-4 py-4 text-sm text-right font-semibold ${rev.reviseAmount >= 0 ? 'text-green-400' : 'text-red-400'}`}>{Utils.formatCurrency(rev.reviseAmount)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(rev.updatedSalary)}</td>
                                        <td className="px-4 py-4 text-center text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${ rev.status === 'Approved' ? 'bg-green-100 text-green-800' : rev.status === 'Rejected' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800' }`}>
                                                {rev.status}
                                            </span>
                                        </td>
                                        <td className="px-4 py-4 text-center whitespace-nowrap">
                                            <div className="flex items-center justify-center gap-2">
                                                {canManage && rev.status === 'Pending' && (
                                                    <>
                                                        <Button variant="icon-approve" icon="fa-check-circle" onClick={() => handleUpdateStatus(rev, 'Approved')} title="Approve" />
                                                        <Button variant="icon-reject" icon="fa-times-circle" onClick={() => handleUpdateStatus(rev, 'Rejected')} title="Reject" />
                                                    </>
                                                )}
                                                {canManage && (
                                                    <>
                                                        <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(rev)} title="Edit" />
                                                        <Button variant="icon-delete" icon="fa-trash" onClick={() => setRevisionToDelete(rev)} title="Delete" />
                                                    </>
                                                )}
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    )}
                    <SalaryRevisionModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSaveRevision} revision={editingRevision} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!revisionToDelete} onClose={() => setRevisionToDelete(null)} onConfirm={handleDeleteConfirm} title="Delete Revision" message="Are you sure you want to delete this salary revision record?" />
                </Card>
            );
        };
        
        // NEW: Table component specifically for displaying former employees.
        const FormerEmployeeTable = memo(({ employees, userProfile, onEdit, onDelete }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Worked Dur.</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Status</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Reason</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {employees.map(emp => (
                                <tr key={emp.id} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatISOToDisplay(emp.statusChangeDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{emp.name}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.calculateWorkedDuration(emp.joinedDate, emp.statusChangeDate)}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{emp.status}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300 whitespace-pre-wrap max-w-xs truncate" title={emp.reasonForLeaving}>{emp.reasonForLeaving}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                                <Button variant="icon-edit" icon="fa-edit" onClick={() => onEdit(emp)} title="Edit Record"/>
                                            )}
                                            {/* Permanent delete is restricted to Admin/CEO for data integrity */}
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(emp)} title="Permanently Delete"/>
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // REPLACED: This component now provides the requested report table for former employees.
        const FormerEmployeesTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingEmployee, setEditingEmployee] = useState(null);
            const [employeeToDelete, setEmployeeToDelete] = useState(null);
            
            // Get global shops data from context for the filter dropdown.
            const { shops } = useAppData();
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState('');

            // Set initial shop filter based on user's role.
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Custom hook to fetch former employees based on user role and selected shop.
            const useFormerEmployees = (userProfile, selectedShop) => {
                const { db } = useFirebase();
                const [employees, setEmployees] = useState([]);
                const [loading, setLoading] = useState(true);

                useEffect(() => {
                    if (!db || !userProfile) return () => {};
                    
                    const { collection, query, where, onSnapshot } = window.firebaseSDK;
                    setLoading(true);
                    
                    const statusFilter = where("status", "in", ["Terminated", "Resigned"]);
                    let finalQuery;
                    
                    const baseQuery = query(collection(db, "employees"), statusFilter);
                    const role = userProfile.role;

                    if (role === 'Admin' || role === 'CEO') {
                        finalQuery = selectedShop ? query(baseQuery, where("shop", "==", selectedShop)) : baseQuery;
                    } else if (role === 'Shop Manager') {
                        const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                        if (managedShops.length > 0) {
                            const shopsToQuery = selectedShop ? [selectedShop] : managedShops;
                            finalQuery = query(baseQuery, where("shop", "in", shopsToQuery));
                        } else {
                            setEmployees([]); setLoading(false); return; // Manager with no shops sees nothing
                        }
                    } else {
                        setEmployees([]); setLoading(false); return; // Staff role sees nothing
                    }

                    const unsub = onSnapshot(finalQuery, (snapshot) => {
                        setEmployees(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                        setLoading(false);
                    }, (error) => {
                        console.error("Error fetching former employees:", error);
                        setLoading(false);
                    });

                    return () => unsub();
                }, [db, userProfile, selectedShop]);

                return { employees, loading };
            };

            const { employees, loading } = useFormerEmployees(userProfile, selectedShop);

            // Further filter employees based on search term on the client side.
            const searchedEmployees = useMemo(() => {
                if (!searchTerm) return employees;
                return employees.filter(emp => 
                    emp.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }, [employees, searchTerm]);
            
            // Determine which shops are available for the filter dropdown.
            const availableShopsForFilter = useMemo(() => {
                if (!userProfile || !shops) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                return [];
            }, [userProfile, shops]);
            
            // Handlers for modal operations.
            const handleOpenModal = (employee) => {
                setEditingEmployee(employee);
                setIsModalOpen(true);
            };

            const handleCloseModal = () => {
                setEditingEmployee(null);
                setIsModalOpen(false);
            };

            const handleSaveEmployee = async (formData) => {
                const { updateDoc, doc } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                try {
                    await updateDoc(doc(db, 'employees', id), dataToSave);
                    handleCloseModal();
                } catch (error) {
                    console.error("Error updating former employee:", error);
                }
            };
            
            // Handlers for deletion.
            const handleDeleteEmployee = (employee) => {
                setEmployeeToDelete(employee);
            };

            const confirmDelete = async () => {
                if (!employeeToDelete) return;
                const { doc, deleteDoc } = window.firebaseSDK;
                try {
                    // This is a permanent, hard delete from the database.
                    await deleteDoc(doc(db, 'employees', employeeToDelete.id));
                } catch (error) {
                    console.error("Error permanently deleting employee record:", error);
                } finally {
                    setEmployeeToDelete(null);
                }
            };

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Resigned/Terminated Employee List</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                        </div>
                    </div>

                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div>
                    ) : (
                        <FormerEmployeeTable 
                            employees={searchedEmployees}
                            userProfile={userProfile}
                            onEdit={handleOpenModal}
                            onDelete={handleDeleteEmployee}
                        />
                    )}

                    <EmployeeModal
                        isOpen={isModalOpen}
                        onClose={handleCloseModal}
                        onSave={handleSaveEmployee}
                        employee={editingEmployee}
                        userProfile={userProfile}
                        isViewOnly={false} // Always open in edit mode for this tab
                        onSwitchToEdit={() => {}} // Not applicable here
                    />

                    <ConfirmationModal
                        isOpen={!!employeeToDelete}
                        onClose={() => setEmployeeToDelete(null)}
                        onConfirm={confirmDelete}
                        title="Confirm Permanent Deletion"
                        message={`Are you sure you want to PERMANENTLY delete the record for ${employeeToDelete?.name}? This action cannot be undone and will remove all their historical data.`}
                    />
                </Card>
            );
        };

        // Component: Main Employees Page (Tab Container)
        const EmployeesPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('active');
            return (
                <TabbedPage tabs={{ active: 'Active Employees', salaryReport: 'Salary Revise Report', former: 'Resigned/Terminated' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="active"><ActiveEmployeesTab userProfile={userProfile} /></div>
                    <div id="salaryReport"><SalaryReviseReportTab userProfile={userProfile} /></div>
                    <div id="former"><FormerEmployeesTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };
        // --- END EMPLOYEES PAGE COMPONENTS ---
        
        // --- START SAVINGS PROGRAM PAGE COMPONENTS (NEW) ---
        
        // NEW: Modal to Add/Edit Salary Saving Program Participants
        // MODIFIED (STEP 4): Added 'allSavings' prop
        const AddSalarySavingModal = ({ isOpen, onClose, onSave, participant, userProfile, allEmployees, allSavings }) => {
            const { shops } = useAppData();
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const [savingsPercentage, setSavingsPercentage] = useState(0);
            const [joinDate, setJoinDate] = useState('');
            const [effectiveMonth, setEffectiveMonth] = useState('');
            // --- NEW: State for participant status ---
            const [savingsProgramStatus, setSavingsProgramStatus] = useState('Active');
        
            useEffect(() => {
                if (participant) {
                    // EDIT MODE
                    const participantShop = Array.isArray(participant.shop) ? participant.shop[0] : participant.shop;
                    setSelectedShop(participantShop || '');
                    setSelectedEmployeeId(participant.id);
                    setSavingsPercentage(participant.savingsPercentage || 0);
                    setJoinDate(participant.savingsJoinDate || '');
                    setEffectiveMonth(participant.savingsEffectiveMonth || '');
                    // --- NEW: Load existing status in edit mode ---
                    setSavingsProgramStatus(participant.savingsProgramStatus || 'Active');
                } else {
                    // ADD MODE - Reset form
                    setSelectedShop('');
                    setSelectedEmployeeId('');
                    setSavingsPercentage(0);
                    const today = new Date().toISOString().slice(0, 10);
                    const currentMonth = new Date().toISOString().slice(0, 7);
                    setJoinDate(today);
                    setEffectiveMonth(currentMonth);
                    // --- NEW: Default status for new participants ---
                    setSavingsProgramStatus('Active');
                }
            }, [participant, isOpen]);
        
            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                return shops.filter(s => managedShops.includes(s.name));
            }, [shops, userProfile]);
            
            const availableEmployees = useMemo(() => {
                if (!selectedShop) return [];
                // MODIFIED (STEP 4): Check against the new 'allSavings' prop (from /savingprogram)
                // to see if an employee is already enrolled, instead of checking the deprecated
                // 'savingsProgramStatus' field on the employee document.
                
                // --- START FIX: Only filter out employees who are 'Active' ---
                // The original code created a Set of all IDs, blocking 'Inactive' ones.
                // This new code only adds 'Active' members to the set.
                const enrolledIds = new Set(
                    (allSavings || [])
                        .filter(s => s.savingsProgramStatus === 'Active')
                        .map(s => s.id)
                );
                // --- END FIX ---
                
                return allEmployees.filter(emp => {
                    const isInShop = Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop;
                    // Use the new Set to check for enrollment
                    const isNotEnrolled = !enrolledIds.has(emp.id);
                    return emp.status === 'Active' && isInShop && (isNotEnrolled || emp.id === participant?.id);
                });
            }, [selectedShop, allEmployees, participant, allSavings]); // Added 'allSavings'
        
            const handleSubmit = (e) => {
                e.preventDefault();
                if (!selectedEmployeeId || isNaN(savingsPercentage) || savingsPercentage <= 0 || !joinDate || !effectiveMonth) {
                    alert("Please fill all required fields, including a savings percentage greater than 0.");
                    return;
                }
                // MODIFIED: Pass the new 'savingsProgramStatus' state
                onSave(selectedEmployeeId, savingsPercentage || 0, joinDate, effectiveMonth, !!participant, savingsProgramStatus);
            };
        
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={participant ? "Edit Savings Percentage" : "Add to Savings Program"} onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Shop</label>
                                    <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select" disabled={!!participant}>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select" disabled={!selectedShop || !!participant}>
                                        <option value="">Select Employee</option>
                                        {availableEmployees.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Savings Percentage (%)</label>
                                    <input
                                        type="number"
                                        value={isNaN(savingsPercentage) ? '' : savingsPercentage}
                                        onChange={e => setSavingsPercentage(parseFloat(e.target.value))}
                                        className="input"
                                        min="0"
                                        max="100"
                                        placeholder="e.g., 10"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Join Program Date</label>
                                    <input
                                        type="date"
                                        value={joinDate}
                                        onChange={e => setJoinDate(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Effective Month</label>
                                    <input
                                        type="month"
                                        value={effectiveMonth}
                                        onChange={e => setEffectiveMonth(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                                {/* --- NEW: Status field for Edit Mode --- */}
                                {participant && (
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Status</label>
                                        <select
                                            name="status"
                                            value={savingsProgramStatus}
                                            onChange={e => setSavingsProgramStatus(e.target.value)}
                                            className={`select ${savingsProgramStatus === 'Active' ? 'text-green-400' : 'text-red-400'}`}
                                            required
                                        >
                                            <option value="Active">Active</option>
                                            <option value="Inactive">Inactive</option>
                                        </select>
                                    </div>
                                )}
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button 
                                type="submit" 
                                variant="primary"
                                // FIX: Corrected disabled logic to use this component's state
                                // (savingsPercentage, selectedEmployeeId) instead of 'amount'.
                                // This resolves the "amount is not defined" error.
                                disabled={!selectedEmployeeId || isNaN(savingsPercentage) || savingsPercentage <= 0 || !joinDate || !effectiveMonth}
                            >
                                {/* FIX: Corrected button text. */}
                                {participant ? "Update" : "Save Participant"}
                            </Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // NEW: Modal for processing a savings payback
        const PaybackModal = ({ isOpen, onClose, onSave, participant }) => {
            const [amount, setAmount] = useState(0); // MODIFIED: Initialize to 0
            const [note, setNote] = useState('');
            const [error, setError] = useState('');
            const [selectedPercentage, setSelectedPercentage] = useState(null); // NEW: State for active button

            useEffect(() => {
                if (isOpen) {
                    setAmount(0); // MODIFIED: Reset to 0
                    setNote('');
                    setError('');
                    setSelectedPercentage(null); // NEW: Reset percentage
                }
            }, [isOpen]);
            
            // NEW: Handler for percentage buttons
            const handlePercentageClick = (percentage) => {
                if (!participant) return;
                const paybackAmount = Math.round((participant.savingsBalance || 0) * (percentage / 100));
                setAmount(paybackAmount);
                setSelectedPercentage(percentage);
                setError('');
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const paybackAmount = parseFloat(amount);
                
                // MODIFIED: Check for 0 or NaN
                if (isNaN(paybackAmount) || paybackAmount <= 0) { 
                    setError('Please select a valid payback percentage.');
                    return;
                }
                if (paybackAmount > participant.savingsBalance) {
                    setError('Payback amount cannot exceed the total savings. This should not happen.');
                    return;
                }
                onSave(participant.id, paybackAmount, note);
            };

            if (!participant) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-md">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title="Process Savings Payback" onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <input value={participant.name} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Total Accumulated Savings</label>
                                <input value={Utils.formatCurrency(participant.savingsBalance)} className="input" disabled />
                            </div>
                            
                            {/* --- REVISED: Payback Amount Section --- */}
                            <div>
                                <label className="text-sm font-medium text-slate-400 mb-2 block">Select Payback Percentage</label>
                                <div className="grid grid-cols-4 gap-2">
                                    {[25, 50, 75, 100].map((perc) => {
                                        const isActive = selectedPercentage === perc;
                                        return (
                                            <button
                                                key={perc}
                                                type="button"
                                                onClick={() => handlePercentageClick(perc)}
                                                className={`py-2 px-3 rounded-lg font-medium transition-colors ${
                                                    isActive 
                                                        ? 'bg-blue-600 text-white ring-2 ring-blue-400' 
                                                        : 'bg-slate-600 text-slate-200 hover:bg-slate-500'
                                                }`}
                                            >
                                                {perc}%
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>

                            <div>
                                <label className="text-sm font-medium text-slate-400">Calculated Payback Amount (KHR)</label>
                                <input
                                    type="text"
                                    value={Utils.formatCurrency(amount)}
                                    className="input"
                                    disabled
                                />
                            </div>
                            {/* --- END REVISED SECTION --- */}

                            <div>
                                <label className="text-sm font-medium text-slate-400">Note (Optional)</label>
                                    <input
                                        type="text"
                                        value={note}
                                        onChange={e => setNote(e.target.value)}
                                        className="input"
                                        placeholder="e.g., Cash withdrawal"
                                    />
                                </div>
                                {error && <p className="text-sm text-red-400">{error}</p>}
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button 
                                type="submit" 
                                variant="primary"
                                // FIX: Added disabled logic. Button should be disabled
                                // until a valid percentage is selected.
                                disabled={amount <= 0 || selectedPercentage === null}
                            >
                                Confirm Payback
                            </Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // NEW: Modal to display savings transaction history
        const SavingsHistoryModal = ({ isOpen, onClose, employeeName, transactions }) => {
             const sortedTransactions = useMemo(() => {
                if (!transactions) return [];
                return [...transactions].sort((a, b) => (b.date?.toDate() || 0) - (a.date?.toDate() || 0));
            }, [transactions]);

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-2xl">
                    <ModalHeader title={`Savings History for ${employeeName}`} onClose={onClose} />
                    <ModalBody>
                        <div className="overflow-x-auto max-h-[60vh]">
                            <table className="min-w-full divide-y divide-slate-700">
                                <thead className="bg-slate-900/50 sticky top-0">
                                    <tr>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note / Payroll ID</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-700">
                                    {sortedTransactions.map(tx => (
                                        <tr key={tx.id} className="hover:bg-slate-700/50">
                                            <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatRequestDate(tx.date)}</td>
                                            <td className="px-4 py-4 text-sm font-semibold">
                                                {tx.type === 'contribution' ? (
                                                    <span className="text-green-400">Contribution</span>
                                                ) : (
                                                    <span className="text-red-400">Withdrawal</span>
                                                )}
                                            </td>
                                            <td className={`px-4 py-4 text-sm text-right font-semibold ${tx.type === 'contribution' ? 'text-green-400' : 'text-red-400'}`}>
                                                {Utils.formatCurrency(tx.amountDeducted || tx.amountWithdrawn)}
                                            </td>
                                            <td className="px-4 py-4 text-sm text-slate-400">{tx.payrollId || tx.note || '-'}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </ModalBody>
                    <ModalFooter>
                        <Button variant="secondary" onClick={onClose}>Close</Button>
                    </ModalFooter>
                </Modal>
            );
        };

        // MOVED & RENAMED: from SalarySavingTab to ParticipantsTab
        // MODIFIED (STEP 4): This component is heavily refactored to use the new '/savingprogram' collection.
        const ParticipantsTab = ({ userProfile }) => {
            const { db } = useFirebase();
            // MODIFIED (STEP 4): Added setDoc and deleteField
            const { doc, updateDoc, where, setDoc, deleteField } = window.firebaseSDK;
            const { employees, shops } = useAppData();
            
            // MODIFIED (STEP 4): Data source is now 'savingprogram' collection
            const { data: allSavings } = useCollection('savingprogram');
            
            const [selectedShop, setSelectedShop] = useState('');
            const [searchTerm, setSearchTerm] = useState('');
            const [isSavingModalOpen, setIsSavingModalOpen] = useState(false);
            const [editingParticipant, setEditingParticipant] = useState(null);
            const [participantToRemove, setParticipantToRemove] = useState(null);
            const [paybackParticipant, setPaybackParticipant] = useState(null);
            const [historyParticipant, setHistoryParticipant] = useState(null);
            const [participantForPaybackConfirmation, setParticipantForPaybackConfirmation] = useState(null);

            // MODIFIED (STEP 6.B): Replaced 'useCollection' with a 'useEffect'
            // to listen to the new dynamic subcollection path.
            const [transactionHistory, setTransactionHistory] = useState([]);
            useEffect(() => {
                if (!db || !historyParticipant) {
                    setTransactionHistory([]);
                    return;
                }
                
                const { collection, onSnapshot, orderBy, query } = window.firebaseSDK;
                const collectionRef = collection(db, 'savingprogram', historyParticipant.id, 'transactions');
                const q = query(collectionRef, orderBy('date', 'desc')); // Order by date descending

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const history = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setTransactionHistory(history);
                }, (error) => {
                    console.error("Error fetching transaction history:", error);
                    setTransactionHistory([]);
                });

                // Clean up the listener when the modal is closed or participant changes
                return () => unsubscribe();
            }, [db, historyParticipant]); // Re-run when the selected participant changes

            const handleOpenSavingModal = (participant = null) => {
                setEditingParticipant(participant);
                setIsSavingModalOpen(true);
            };

            const handleCloseSavingModal = () => {
                setEditingParticipant(null);
                setIsSavingModalOpen(false);
            };

            // MODIFIED (STEP 4): This function now writes to '/savingprogram' and cleans up '/employees'.
            // MODIFIED (Bug Fix): Added 'isEdit' flag to correctly initialize balance for new participants.
            // MODIFIED (User Request): Added 'status' parameter
            const handleSaveParticipant = async (employeeId, percentage, joinDate, effectiveMonth, isEdit, status) => {
                if (!employeeId || !db) return;
                
                // Find the employee to get their name and shop for denormalization
                const employee = employees.find(e => e.id === employeeId);
                if (!employee) {
                    alert("Could not find employee data.");
                    return;
                }
                
                try {
                    // 1. Set (or update) the document in the new '/savingprogram' collection
                    const savingsDocRef = doc(db, 'savingprogram', employeeId);
                    const newData = {
                        employeeId: employeeId,
                        employeeName: employee.name,
                        shop: Array.isArray(employee.shop) ? employee.shop[0] : employee.shop,
                        // MODIFIED (User Request): Use the passed-in status
                        savingsProgramStatus: status || 'Active',
                        savingsPercentage: percentage,
                        savingsJoinDate: joinDate,
                        savingsEffectiveMonth: effectiveMonth,
                        // Do not overwrite currentBalance if it's just an edit
                    };

                    // FIX: If this is a NEW participant (not an edit), initialize their balance to 0.
                    if (!isEdit) {
                        newData.currentBalance = 0;
                        newData.mySavingCredit = 0; // NEW: Initialize new credit field
                        newData.mySavingWithdrawalTotal = 0; // NEW: Initialize new withdrawal field
                    }

                    // Use { merge: true } to create or update without overwriting the balance
                    await setDoc(savingsDocRef, newData, { merge: true }); 

                    // 2. Remove the deprecated fields from the '/employees' document
                    const employeeRef = doc(db, 'employees', employeeId);
                    await updateDoc(employeeRef, {
                        savingsProgramStatus: deleteField(),
                        savingsPercentage: deleteField(),
                        savingsJoinDate: deleteField(),
                        savingsEffectiveMonth: deleteField()
                    });
                    
                    handleCloseSavingModal();
                } catch (error) {
                    console.error("Error saving participant:", error);
                    alert("Failed to save participant.");
                }
            };
            
            // MODIFIED (STEP 4): This function now updates the '/savingprogram' collection.
            const handleConfirmRemove = async () => {
                if (!participantToRemove || !db) return;
                try {
                    // Update the '/savingprogram' doc instead of the '/employees' doc
                    const savingsDocRef = doc(db, 'savingprogram', participantToRemove.id);
                    await updateDoc(savingsDocRef, {
                        savingsProgramStatus: 'Inactive',
                        savingsPercentage: 0
                    });
                    setParticipantToRemove(null);
                } catch (error) {
                    console.error("Error removing participant:", error);
                    alert("Failed to remove participant.");
                }
            };
            
            const handleStartPaybackProcess = () => {
                if (!participantForPaybackConfirmation) return;
                setPaybackParticipant(participantForPaybackConfirmation);
                setParticipantForPaybackConfirmation(null);
            };
            
            // MODIFIED (STEP 4): This function now passes the required 'employeeName' and 'shop'
            // to match the new signature of Utils.manageSavingsWithdrawal.
            const handleProcessPayback = async (employeeId, amount, note) => {
                if (!paybackParticipant) {
                    alert("Error: No participant selected for payback.");
                    return;
                }
                
                const participantShop = Array.isArray(paybackParticipant.shop) ? paybackParticipant.shop[0] : paybackParticipant.shop;
                
                const result = await Utils.manageSavingsWithdrawal(
                    db, 
                    employeeId, 
                    paybackParticipant.name, // Pass Employee Name
                    participantShop, // Pass Shop
                    amount, 
                    note
                );
                
                if (result.success) {
                    alert("Payback processed successfully!");
                    setPaybackParticipant(null);
                } else {
                    alert(`Payback failed: ${result.error?.message || 'An unknown error occurred.'}`);
                }
            };

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            const availableShops = useMemo(() => {
                // FIX: Cleaned up logic and added guard for userProfile
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    // Manager with multiple shops can filter by their assigned shops
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                // Manager with one shop, or staff, don't get a filter dropdown.
                return [];
            }, [shops, userProfile]);

            // MODIFIED (STEP 4): This logic is completely rebuilt to use '/savingprogram'
            // as the source of truth for participants.
            const enrolledEmployees = useMemo(() => {
                // 1. Create a map of all employees from context for quick lookup
                const employeeMap = new Map((employees || []).map(e => [e.id, e]));

                // 2. Map over 'allSavings' (from /savingprogram) and merge with employee data
                const enrolled = (allSavings || []).map(savingDoc => {
                    const employeeData = employeeMap.get(savingDoc.id);
                    // Use employeeData if available, but fallback to denormalized data
                    // in savingDoc just in case (e.g., for a resigned employee).
                    return {
                        ...employeeData, // Full employee record (includes 'status', 'position', etc.)
                        ...savingDoc,   // Full savings record (overwrites with fresher savings data)
                        id: savingDoc.id, // Ensure savingDoc.id is primary
                        name: employeeData?.name || savingDoc.employeeName,
                        shop: employeeData?.shop || savingDoc.shop, // Use employee's current shop
                        savingsBalance: savingDoc.currentBalance || 0
                    };
                });

                // 3. Apply role-based filtering
                const roleFiltered = enrolled.filter(emp => {
                    if (!userProfile) return false;
                    
                    // MODIFICATION: Removed this filter. We now want to show *all*
                    // participants (Active and Inactive) and let the new Status
                    // column show their state.
                    // if (emp.savingsProgramStatus !== 'Active') return false; 
                    
                    if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                        return true; // Admins/CEOs see everyone
                    }
                    if (userProfile.role === 'Shop Manager') {
                        const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                        const employeeShops = Array.isArray(emp.shop) ? emp.shop : (emp.shop ? [emp.shop] : []);
                        return employeeShops.some(s => managedShops.includes(s));
                    }
                    if (userProfile.role === 'Staff') {
                        return emp.id === userProfile.id; // Staff only see themselves
                    }
                    return false; // Default deny
                });

                // 4. Apply the UI filters (selectedShop dropdown and search term)
                const filtered = roleFiltered.filter(emp => 
                    (!selectedShop || (Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop)) &&
                    (emp.name.toLowerCase().includes(searchTerm.toLowerCase()))
                );
                
                return filtered.sort((a,b) => a.name.localeCompare(b.name));
            }, [employees, allSavings, selectedShop, searchTerm, userProfile]); // Added userProfile

            const totalSavings = useMemo(() => {
                return enrolledEmployees.reduce((sum, emp) => sum + emp.savingsBalance, 0);
            }, [enrolledEmployees]);

            const handleExportExcel = useCallback(() => {
                const dataToExport = enrolledEmployees.map(emp => ({ 
                    'Name': emp.name,
                    'Shop': Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop,
                    'Savings Percentage (%)': emp.savingsPercentage,
                    'Total Accumulated Savings (KHR)': emp.savingsBalance
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Salary Savings Report");
                worksheet["!cols"] = [ { wch: 25 }, { wch: 20 }, { wch: 25 }, { wch: 30 } ];
                XLSX.writeFile(workbook, "Salary_Savings_Report.xlsx");
            }, [enrolledEmployees]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Salary Saving Program Participants</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text" 
                                placeholder="Search by name..." 
                                value={searchTerm} 
                                onChange={e => setSearchTerm(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                             {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenSavingModal()}>Add Participant</Button>
                            )}
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Join Date</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Savings Percentage</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Effective Month</th>
                                    
                                    {/* NEW: Added Status column header */}
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th>

                                    {/* MODIFIED: Removed 'My Saving Credit' to prevent duplication */}
                                    {/* <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">My Saving Credit</th> */}
                                    
                                    {/* NEW: Added 'Total Withdrawals' for clarity */}
                                    <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Withdrawals</th>
                                    
                                    <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Accumulated Savings</th>
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                        <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                    )}
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {enrolledEmployees.map(emp => (
                                    <tr key={emp.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm text-slate-200">{emp.name}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{Array.isArray(emp.shop) ? emp.shop.join(', ') : emp.shop}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(emp.savingsJoinDate)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-center">{emp.savingsPercentage}%</td>
                                        <td className="px-4 py-4 text-sm text-slate-300 text-center">{emp.savingsEffectiveMonth}</td>
                                        
                                        {/* NEW: Added Status column data cell */}
                                        <td className="px-4 py-4 text-center text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                emp.savingsProgramStatus === 'Active' ? 'bg-green-100 text-green-800' : 'bg-slate-100 text-slate-800'
                                            }`}>
                                                {emp.savingsProgramStatus || 'N/A'}
                                            </span>
                                        </td>
                                        
                                        {/* MODIFIED: Removed 'My Saving Credit' column data */}
                                        {/* <td className="px-4 py-4 text-sm text-green-300 font-semibold text-right">{Utils.formatCurrency(emp.mySavingCredit)}</td> */}
                                        
                                        {/* NEW: Added 'Total Withdrawals' column data */}
                                        <td className="px-4 py-4 text-sm text-red-300 font-semibold text-right">{Utils.formatCurrency(emp.mySavingWithdrawalTotal)}</td>
                                        
                                        <td className="px-4 py-4 text-sm text-blue-300 font-semibold text-right">{Utils.formatCurrency(emp.savingsBalance)}</td>
                                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                                            <td className="px-4 py-4 text-center">
                                                <div className="flex items-center justify-center gap-2">
                                                    <Button variant="icon-view" icon="fa-history" onClick={() => setHistoryParticipant(emp)} title="View History"/>
                                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                        <Button variant="success" icon="fa-hand-holding-usd" onClick={() => setParticipantForPaybackConfirmation(emp)} title="Process Payback" className="px-3 py-1 text-xs">Payback</Button>
                                                    )}
                                                    <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenSavingModal(emp)} title="Edit Percentage"/>
                                                    {/* MODIFIED: Only Admin and CEO can see the delete button */}
                                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (
                                                        <Button variant="icon-delete" icon="fa-user-minus" onClick={() => setParticipantToRemove(emp)} title="Remove from Program"/>
                                                    )}
                                                </div>
                                            </td>
                                        )}
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot className="bg-slate-900/50">
                                <tr>
                                    {/* MODIFIED: 
                                      1. Corrected colSpan from 7 to 6.
                                      2. This colSpan is now dynamic. It's 6 if actions are visible, 5 if not.
                                      3. MODIFIED AGAIN: Increased colSpan by 1 (to 7 or 6) for the new Status column.
                                    */}
                                    <td colSpan={userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager' ? 7 : 6} className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Total Savings of Filtered Employees</td>
                                    <td className="px-4 py-3 text-right font-bold text-blue-300">{Utils.formatCurrency(totalSavings)}</td>
                                    {/* MODIFIED: Changed <em> to <td> for correct column alignment */}
                                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && <td></td>}
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <AddSalarySavingModal
                        isOpen={isSavingModalOpen}
                        onClose={handleCloseSavingModal}
                        onSave={handleSaveParticipant}
                        participant={editingParticipant}
                        userProfile={userProfile}
                        allEmployees={employees}
                        allSavings={allSavings} // MODIFIED (STEP 4): Pass 'allSavings' data
                    />
                    <ConfirmationModal 
                        isOpen={!!participantToRemove}
                        onClose={() => setParticipantToRemove(null)}
                        onConfirm={handleConfirmRemove}
                        title="Remove from Program"
                        message={`Are you sure you want to remove ${participantToRemove?.name} from the Salary Saving Program? This action will set their status to Inactive.`}
                    />
                    <ConfirmationModal
                        isOpen={!!participantForPaybackConfirmation}
                        onClose={() => setParticipantForPaybackConfirmation(null)}
                        onConfirm={handleStartPaybackProcess}
                        title="Confirm Payback"
                        message={`Are you sure you want to start the payback process for ${participantForPaybackConfirmation?.name}?`}
                    />
                    <PaybackModal
                        isOpen={!!paybackParticipant}
                        onClose={() => setPaybackParticipant(null)}
                        onSave={handleProcessPayback}
                        participant={paybackParticipant}
                    />
                    <SavingsHistoryModal
                        isOpen={!!historyParticipant}
                        onClose={() => setHistoryParticipant(null)}
                        employeeName={historyParticipant?.name}
                        transactions={transactionHistory}
                    />
                </Card>
            );
        };

        // MOVED: Savings History Tab
        // MODIFIED (STEP 6.C): This component is completely refactored to use a collectionGroup query.
        const SavingsHistoryTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { shops } = useAppData(); // We only need shops for the filter dropdown
            
            // MODIFIED (STEP 6.C): Replaced 'useCollection' with 'useState'
            const [transactions, setTransactions] = useState([]);
            const [loading, setLoading] = useState(true);

            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [searchTerm, setSearchTerm] = useState('');

            // MODIFIED (STEP 6.C): New data fetching logic using collectionGroup
            useEffect(() => {
                if (!db || !userProfile) return;

                // --- THIS IS THE FIX ---
                // We are replacing the one-time `getDocs` with a real-time `onSnapshot` listener.
                // This will automatically update the history card when new transactions are added.

                setLoading(true);
                const { collectionGroup, query, where, onSnapshot, orderBy } = window.firebaseSDK;
                
                // Query the 'transactions' subcollection across all 'savingprogram' documents
                // FIX: Removed the orderBy('date', 'desc') from the query.
                // This was causing a composite index error when combined with the 'where'
                // filters below. We will sort in JavaScript instead.
                let q = query(collectionGroup(db, 'transactions'));
                
                // Apply role-based filtering at the query level for security and efficiency
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (managedShops.length > 0) {
                        // Filter results to only include transactions from shops they manage
                        q = query(q, where("shop", "in", managedShops));
                    } else {
                        q = query(q, where("shop", "==", "null")); // No shops, no data
                    }
                } else if (userProfile.role === 'Staff') {
                    // Staff can only see their own transactions
                    q = query(q, where("employeeId", "==", userProfile.id));
                }
                // Admin/CEO sees all (no extra 'where' clause)

                // Use onSnapshot to listen for real-time changes
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const txs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    // NEW: Sort the transactions in JavaScript (client-side)
                    // since we removed it from the query.
                    txs.sort((a, b) => (b.date?.toDate() || 0) - (a.date?.toDate() || 0));
                    
                    setTransactions(txs);
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching real-time savings transaction history:", error);
                    setTransactions([]);
                    setLoading(false);
                });

                // Clean up the listener on component unmount
                return () => unsubscribe();
                
            }, [db, userProfile]); // This effect now sets up the listener

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            // MODIFIED (STEP 6.C): This logic is now much simpler and uses the denormalized fields.
            const { processedTransactions, totals } = useMemo(() => {
                // 'transactions' state is already pre-filtered by role (from useEffect).
                // Now, we just apply the UI filters (month, shop, search).
                
                const filtered = transactions.filter(tx => {
                    const txDate = tx.date?.toDate();
                    if (!txDate) return false;

                    // Filter 1: Month
                    const monthMatch = !selectedMonth || txDate.toISOString().startsWith(selectedMonth);
                    
                    // Filter 2: Shop (using denormalized field 'tx.shop')
                    const shopMatch = !selectedShop || tx.shop === selectedShop;
                    
                    // Filter 3: Search Term (using denormalized field 'tx.staffName')
                    const searchMatch = !searchTerm || (tx.staffName && tx.staffName.toLowerCase().includes(searchTerm.toLowerCase()));

                    return monthMatch && shopMatch && searchMatch;
                });
                
                // Data is already sorted by date from the query, so no need to sort again.
                // MODIFIED: This comment is no longer true, but the sort is now
                // handled in the onSnapshot callback, so the data is sorted
                // before it even gets to this useMemo.
                
                // The denormalized fields are already on 'tx', so no 'map' is needed.
                
                const totals = filtered.reduce((acc, tx) => {
                    if (tx.type === 'contribution') {
                        acc.totalContributions += tx.amountDeducted || 0;
                    } else if (tx.type === 'withdrawal') {
                        acc.totalWithdrawals += tx.amountWithdrawn || 0;
                    }
                    return acc;
                }, { totalContributions: 0, totalWithdrawals: 0 });

                return { processedTransactions: filtered, totals };
            }, [transactions, selectedMonth, selectedShop, searchTerm]); // Removed 'employees' dependency

            const handleExportExcel = useCallback(() => {
                const dataToExport = processedTransactions.map(tx => ({ 
                    'Date': Utils.formatRequestDate(tx.date),
                    'Staff Name': tx.staffName,
                    'Shop': tx.shop,
                    'Type': tx.type,
                    'Amount (KHR)': tx.amountDeducted || tx.amountWithdrawn,
                    'Note / Payroll ID': tx.payrollId || tx.note || '-'
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Savings History");
                worksheet["!cols"] = [ { wch: 20 }, { wch: 25 }, { wch: 20 }, { wch: 15 }, { wch: 20 }, { wch: 30 } ];
                XLSX.writeFile(workbook, `Savings_History_${selectedMonth}.xlsx`);
            }, [processedTransactions, selectedMonth]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Savings Transaction History</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input 
                                type="text" 
                                placeholder="Search by name..." 
                                value={searchTerm} 
                                onChange={e => setSearchTerm(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                             {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <input 
                                type="month" 
                                value={selectedMonth} 
                                onChange={e => setSelectedMonth(e.target.value)} 
                                className="input w-full sm:w-auto" 
                            />
                            <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                     {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th>
                                    <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note / Payroll ID</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {processedTransactions.map(tx => (
                                    <tr key={tx.id} className="hover:bg-slate-700/50">
                                        <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{Utils.formatRequestDate(tx.date)}</td>
                                        <td className="px-4 py-4 text-sm text-slate-200">{tx.staffName}</td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{tx.shop}</td>
                                        <td className="px-4 py-4 text-sm font-semibold">
                                            {tx.type === 'contribution' ? (
                                                <span className="text-green-400">Contribution</span>
                                            ) : (
                                                <span className="text-red-400">Withdrawal</span>
                                            )}
                                        </td>
                                        <td className={`px-4 py-4 text-sm text-right font-semibold ${tx.type === 'contribution' ? 'text-green-400' : 'text-red-400'}`}>
                                            {Utils.formatCurrency(tx.amountDeducted || tx.amountWithdrawn)}
                                        </td>
                                        <td className="px-4 py-4 text-sm text-slate-400">{tx.payrollId || tx.note || '-'}</td>
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot className="bg-slate-900/50">
                                <tr>
                                    <td colSpan="4" className="px-4 py-3 text-right font-bold text-green-400 uppercase">Total Contributions</td>
                                    <td className="px-4 py-3 text-right font-bold text-green-400">{Utils.formatCurrency(totals.totalContributions)}</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td colSpan="4" className="px-4 py-3 text-right font-bold text-red-400 uppercase">Total Withdrawals</td>
                                    <td className="px-4 py-3 text-right font-bold text-red-400">{Utils.formatCurrency(totals.totalWithdrawals)}</td>
                                    <td></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    )}
                </Card>
            );
        };
        
        // NEW: Main Savings Program Page (Tab Container)
        const SavingsProgramPage = ({ userProfile }) => {
            // REMOVED: Tab state and TabbedPage wrapper
            return (
                // NEW: Added a div wrapper to stack the two components
                <div className="space-y-6">
                    <ParticipantsTab userProfile={userProfile} />
                    <SavingsHistoryTab userProfile={userProfile} />
                </div>
            );
        };
        // --- END SAVINGS PROGRAM PAGE COMPONENTS ---

        // --- START CHECKINME PAGE COMPONENTS ---

        // Component: Check In / Out Tab
        const CheckInOutTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [currentTime, setCurrentTime] = useState(new Date());
            const [location, setLocation] = useState(null);
            const [accuracy, setAccuracy] = useState(null); // NEW: State for location accuracy
            const [status, setStatus] = useState('សូមចុច "Refresh Location" ដើម្បីចាប់ផ្តើម!');
            const [loading, setLoading] = useState(false);
            const [distance, setDistance] = useState(null);
            const [selectedShopForCheckIn, setSelectedShopForCheckIn] = useState('');
            const [alertModal, setAlertModal] = useState({ isOpen: false, message: '' }); // State for the new alert modal
            // MODIFIED (STEP 5): Replaced 'savingsBalance' state with 'savingsData' state
            // const [savingsBalance, setSavingsBalance] = useState(0); // OLD
            const [savingsData, setSavingsData] = useState(null); // NEW: State for savings data object
            
            // --- NEW: State for savings withdrawals for the preview ---
            const [savingsWithdrawals, setSavingsWithdrawals] = useState([]);
            
            // FIX: Set the month filter to default to the current month, respecting the user's local timezone.
            const [selectedMonth, setSelectedMonth] = useState(() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                return `${year}-${month}`;
            });

            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from AppDataProvider to reduce DB reads.
            const { shops, shifts } = useAppData();

            // PHASE 1 OPTIMIZATION: Queries for the salary preview are now filtered by the current user's ID.
            const staffQueryConstraints = useMemo(() => userProfile?.id ? [where("staffId", "==", userProfile.id)] : [], [userProfile?.id]);
            const attendanceQueryConstraints = useMemo(() => userProfile?.id ? [where("employeeId", "==", userProfile.id)] : [], [userProfile?.id]);

            // Fetch all data needed for the payroll hook
            const allData = {
                shops: shops, // Use data from context
                attendance: useCollection('attendance', attendanceQueryConstraints).data,
                leaveRequests: useCollection('leaveRequests', staffQueryConstraints).data,
                otRequests: useCollection('otRequests', staffQueryConstraints).data,
                staffLoans: useCollection('staffLoans', staffQueryConstraints).data,
                employeeStates: useCollection('employeeStates', staffQueryConstraints).data,
                salaryRevisions: useCollection('salaryRevisions', staffQueryConstraints).data,
                shifts: shifts, // Use data from context
            };
            
            // --- NEW: Step 4/5 - Real-time listener for the employee's savings balance ---
            useEffect(() => {
                // This effect runs only for the logged-in user.
                if (!db || !userProfile?.id) return;
                
                const { doc, onSnapshot } = window.firebaseSDK;
                // MODIFIED (STEP 5): Path changed from 'employeeSavings' to 'savingprogram'
                const savingsDocRef = doc(db, 'savingprogram', userProfile.id);

                const unsubscribe = onSnapshot(savingsDocRef, (doc) => {
                    if (doc.exists()) {
                        // setSavingsBalance(doc.data().currentBalance || 0); // OLD
                        setSavingsData(doc.data()); // NEW: Store the whole object
                    } else {
                        // setSavingsBalance(0); // OLD
                        setSavingsData(null); // NEW: Store null
                    }
                }, (error) => { 
                    console.error("Error fetching savings balance:", error); 
                    setSavingsData(null); // NEW
                });
                return () => unsubscribe(); // Clean up the listener on component unmount.
            }, [db, userProfile?.id]);
            
            // --- NEW: Fetch savings withdrawals for the salary preview ---
            useEffect(() => {
                if (!db || !userProfile?.id || !selectedMonth) {
                    setSavingsWithdrawals([]);
                    return;
                }

                const fetchWithdrawals = async () => {
                    try {
                        const { collection, query, where, getDocs } = window.firebaseSDK;
                        const [year, month] = selectedMonth.split('-').map(Number);
                        const startDate = new Date(year, month - 1, 1);
                        const endDate = new Date(year, month, 0, 23, 59, 59, 999); 

                        const q = query(
                            // MODIFIED (STEP 6.A): Path changed from 'savingsTransactions' to the new subcollection
                            collection(db, 'savingprogram', userProfile.id, 'transactions'),
                            // --- BUG FIX: Removed 'employeeId' and 'type' filters to avoid needing
                            // a complex composite index. We will filter in Javascript.
                            where("date", ">=", startDate),
                            where("date", "<=", endDate)
                        );
                        
                        const querySnapshot = await getDocs(q);
                        // Filter for 'withdrawal' in Javascript
                        const withdrawals = querySnapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(tx => tx.type === 'withdrawal');
                        setSavingsWithdrawals(withdrawals);
                    } catch (error) {
                        console.error("Error fetching savings withdrawals for preview:", error);
                        setSavingsWithdrawals([]);
                    }
                };

                fetchWithdrawals();
            }, [db, userProfile?.id, selectedMonth]);
            
            const isMultiShopManager = userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop);

            // Set the default shop for check-in
            useEffect(() => {
                if (!isMultiShopManager) {
                    setSelectedShopForCheckIn(userProfile.shop);
                }
            }, [userProfile, isMultiShopManager]);

            const userShop = useMemo(() => {
                if (!selectedShopForCheckIn) return null;
                return allData.shops.find(s => s.name === selectedShopForCheckIn);
            }, [selectedShopForCheckIn, allData.shops]);

            // --- START TIMEZONE FIX ---
            // Get today's date string ('YYYY-MM-DD') based on the shop's specific timezone.
            // This is crucial for correctly identifying today's attendance records.
            const todayInShopTimezone = useMemo(() => {
                // Fallback to user's local date if shop isn't selected or has no timezone.
                if (!userShop?.timezone) {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                return Utils.formatDateInTimezone({ toDate: () => new Date() }, userShop.timezone).localDate;
            }, [userShop]);

            const userAttendanceToday = useMemo(() => {
                // Filter attendance records by comparing their date (in shop timezone) with today's date (in shop timezone).
                return (allData.attendance || [])
                    .filter(a => {
                        if (a.employeeId !== userProfile.id) return false;
                        const { localDate: recordDate } = Utils.formatDateInTimezone(a.timestamp, userShop?.timezone);
                        return recordDate === todayInShopTimezone;
                    })
                    .sort((a, b) => (b.timestamp?.toDate() || 0) - (a.timestamp?.toDate() || 0));
            }, [userProfile, allData.attendance, userShop, todayInShopTimezone]);
            // --- END TIMEZONE FIX ---
            
            const lastAction = userAttendanceToday[0] || null;

            // Update time every second
            useEffect(() => { const timerId = setInterval(() => setCurrentTime(new Date()), 1000); return () => clearInterval(timerId); }, []);
            
            // Get user's location and check distance from shop
            const getLocation = useCallback((isCheckAction = false) => {
                if (!userShop) { 
                    setStatus(isMultiShopManager ? "Please select a shop to enable check-in." : "Your assigned shop could not be found."); 
                    setLoading(false);
                    return Promise.reject("No user shop selected"); 
                }
                
                setStatus("Getting your current location...");
                setLoading(true);

                return new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude, accuracy: posAccuracy } = position.coords;
                            const newLocation = { latitude, longitude };
                            setLocation(newLocation);
                            setAccuracy(posAccuracy);
                            
                            const dist = Utils.getDistance(latitude, longitude, parseFloat(userShop.latitude), parseFloat(userShop.longitude));
                            setDistance(dist);
                            
                            const radius = parseFloat(userShop.radius) || 500;
                            const isInRange = dist <= radius;
                            
                            setStatus(isInRange 
                                ? `You are ${Math.round(dist)}m from the shop. Check-in is enabled.`
                                : `You are ${Math.round(dist)}m from the shop. Check-in is disabled.`
                            );
                            setLoading(false);
                            // Resolve with location data for the check-in handler to use
                            resolve({ location: newLocation, distance: dist, shop: userShop });
                        },
                        (error) => {
                            setStatus(error.code === 1 ? "Location permission denied." : "Could not get your location."); 
                            setLoading(false);
                            reject(error);
                        }, 
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Optimized options
                    );
                });
            }, [userShop, isMultiShopManager]);

            const handleCheckAction = useCallback(async () => {
                setLoading(true);
                setStatus("Getting fresh location for check action...");
                
                try {
                    // Step 1: Get a fresh location reading.
                    const { location: freshLocation, distance: freshDistance, shop } = await getLocation(true);

                    // Step 2: Verify the user is still in range.
                    if (freshDistance > (parseFloat(shop.radius) || 500)) {
                        setStatus(`Cannot check-in. You are ${Math.round(freshDistance)}m away.`);
                        setLoading(false);
                        return;
                    }
                    
                    // Step 3: Proceed with saving the attendance record.
                    const { addDoc, collection, serverTimestamp, getDocs, query, where } = window.firebaseSDK;
                    const nextActionType = lastAction?.type === 'in' ? 'out' : 'in';
                    const checkInTimestamp = new Date();
                    
                    await addDoc(collection(db, 'attendance'), { employeeId: userProfile.id, employeeName: userProfile.name, shop: selectedShopForCheckIn, timestamp: serverTimestamp(), type: nextActionType, location: freshLocation });
                    
                    // Step 4: Handle late check-in logic if applicable.
                    if (nextActionType === 'in') {
                        const employeeShiftName = userProfile.shift;
                        const shiftDetails = (allData.shifts || []).find(s => s.name === employeeShiftName && s.shopName === selectedShopForCheckIn);
                        let isLate = false;

                        // FIX: Use the shop's timezone for late detection.
                        if (shiftDetails && shiftDetails.lateThreshold && shop.timezone) {
                            const [lateHour, lateMinute] = shiftDetails.lateThreshold.split(':').map(Number);
                            
                            // Get the current hour and minute in the shop's specific timezone.
                            // 'en-GB' is used to get a reliable 24-hour format (HH:mm).
                            const timeInZoneString = checkInTimestamp.toLocaleTimeString('en-GB', { timeZone: shop.timezone, hour: '2-digit', minute: '2-digit' });
                            const [checkInHour, checkInMinute] = timeInZoneString.split(':').map(Number);
                            
                            // Check if check-in time is strictly greater than the late threshold
                            if (checkInHour > lateHour || (checkInHour === lateHour && checkInMinute > lateMinute)) {
                                isLate = true;
                            }
                        }
                        
                        if (isLate) {
                            // --- START TIMEZONE FIX ---
                            // Get the date string for the late check-in based on the shop's timezone.
                            // This ensures the deduction is recorded on the correct calendar day for the employee.
                            const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => checkInTimestamp }, shop.timezone);
                            // --- END TIMEZONE FIX ---
                            const approvedLeaveToday = (allData.leaveRequests || []).find(lr => lr.staffId === userProfile.id && lr.status === 'Approved' && todayStr >= lr.leaveDate && todayStr < lr.returnDate);
                            if (!approvedLeaveToday) {
                                // FIX: Check if a late deduction already exists for this user today
                                const q = query(collection(db, "employeeStates"), where("staffId", "==", userProfile.id), where("date", "==", todayStr));
                                const existingDeductionsSnap = await getDocs(q);
                                
                                // REVISED: Use a more specific startsWith check and add console logging for easier debugging.
                                const hasLateDeductionToday = existingDeductionsSnap.docs.some(doc => doc.data().note?.startsWith('CheckIn Late @'));

                                if (hasLateDeductionToday) {
                                    console.log(`Late deduction for ${userProfile.name} on ${todayStr} already exists. Skipping creation.`);
                                } else {
                                    console.log(`No existing late deduction found for ${userProfile.name} on ${todayStr}. Creating new record.`);
                                    const pendingLeaveToday = (allData.leaveRequests || []).find(lr => lr.staffId === userProfile.id && lr.status === 'Pending' && lr.leaveDate === todayStr);
                                    if (pendingLeaveToday) { setAlertModal({ isOpen: true, message: 'Your leave request for today is pending. A late deduction has been applied.' }); }
                                
                                    // FIX: Format the alert time using the shop's timezone as well.
                                    const formattedTime = checkInTimestamp.toLocaleTimeString('en-US', { timeZone: shop.timezone, hour: '2-digit', minute: '2-digit', hour12: true });

                                    // FIX: Use a more specific note for late check-ins to be consistent with reports
                                    await addDoc(collection(db, 'employeeStates'), { staffId: userProfile.id, staffName: userProfile.name, shop: selectedShopForCheckIn, date: todayStr, statusState: 'Deduction', amount: 5000, note: `CheckIn Late @${formattedTime}` });
                                }
                            } // FIX: Added missing closing brace for the 'if (!approvedLeaveToday)' block.
                        }
                    }
                    // REVISED: Show a success alert modal instead of just updating the status text.
                    setAlertModal({ isOpen: true, message: `Successfully checked ${nextActionType} at ${checkInTimestamp.toLocaleTimeString()}.` });
                    setStatus(`Last action: Checked ${nextActionType}.`); // Keep a simple status for the main display
                } catch (error) {
                    // Error is already set by getLocation, but we can add a fallback.
                    if (!status.includes('permission') && !status.includes('Could not get')) {
                        setStatus("Failed to record attendance.");
                    }
                    console.error("Error during check action:", error);
                } finally {
                    setLoading(false);
                }
            }, [db, lastAction, userProfile, selectedShopForCheckIn, allData.leaveRequests, getLocation]);

            const canCheck = distance !== null && userShop && distance <= (parseFloat(userShop.radius) || 500);

            // Use the new centralized hook with the selected month
            // --- MODIFIED: Pass savingsWithdrawals to the hook ---
            // MODIFIED (STEP 5): Pass 'savingsData' to the hook
            const { inputs, calculations } = usePayrollCalculator(userProfile, selectedMonth, allData, undefined, savingsWithdrawals, savingsData);

            return (
                <Card className="max-w-2xl mx-auto"><div className="flex flex-col items-center justify-center p-4 sm:p-8 space-y-8">
                    <div className="text-center">
                        <p className="text-4xl sm:text-7xl font-bold text-slate-100 tracking-wider">
                            {/* FIX: Display time based on the selected shop's timezone. Fallback to user's local timezone if not set. */}
                            {currentTime.toLocaleTimeString('en-US', { timeZone: userShop?.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone, hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })}
                        </p>
                        <p className="text-xl text-slate-400 mt-2">
                            {/* FIX: Display date based on the selected shop's timezone. */}
                            {currentTime.toLocaleDateString('en-US', { timeZone: userShop?.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone, weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}
                        </p>
                    </div>
                    {isMultiShopManager && (
                        <div className="w-full max-w-md">
                            <label className="text-sm font-medium text-slate-400">Select Shop for Check-in</label>
                            <select value={selectedShopForCheckIn} onChange={e => setSelectedShopForCheckIn(e.target.value)} className="select">
                                <option value="">-- Select Your Shop --</option>
                                {userProfile.shop.map(shopName => <option key={shopName} value={shopName}>{shopName}</option>)}
                            </select>
                        </div>
                    )}
                    <div className="flex gap-4">
                        <button onClick={handleCheckAction} disabled={lastAction?.type === 'in' || loading} className={`px-8 py-3 text-lg font-semibold rounded-lg shadow-md transition-colors transform hover:scale-105 ${lastAction?.type === 'in' || loading ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-green-600 text-white hover:bg-green-700'}`}>{loading && lastAction?.type !== 'in' ? <i className="fas fa-spinner fa-spin"></i> : 'Check In'}</button>
                        <button onClick={handleCheckAction} disabled={lastAction?.type !== 'in' || loading} className={`px-8 py-3 text-lg font-semibold rounded-lg shadow-md transition-colors transform hover:scale-105 ${lastAction?.type !== 'in' || loading ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-slate-600 text-white hover:bg-slate-500'}`}>{loading && lastAction?.type === 'in' ? <i className="fas fa-spinner fa-spin"></i> : 'Check Out'}</button>
                    </div>
                    <div className="w-full max-w-md">
                        <Button onClick={() => getLocation(false)} disabled={loading || !userShop} variant="secondary" className="w-full">
                            {loading ? 'Refreshing...' : 'Refresh Location'}
                        </Button>
                    </div>
                    <div className={`p-4 rounded-lg text-center w-full max-w-md ${canCheck ? 'bg-green-900/50 border-green-700' : 'bg-red-900/50 border-red-700'} border`}>
                        <p className="font-medium text-lg text-slate-100">{status}</p>
                        {accuracy && <p className="text-xs text-slate-400 mt-1">Accuracy: {Math.round(accuracy)}m</p>}
                    </div>

                    {/* --- NEW: Step 4/5 - Savings Program Balance Display --- */}
                    {/* MODIFIED (STEP 5): Logic updated to use 'savingsData' object */}
                    {savingsData && savingsData.savingsProgramStatus === 'Active' && (
                        <div className="w-full max-w-md mt-8 p-4 bg-indigo-900/50 border border-indigo-700 rounded-lg text-center">
                            {/* TRANSLATED: "My Savings Program" to Khmer */}
                            <h4 className="text-lg font-semibold text-indigo-200">កម្មវិធីសន្សំរបស់ខ្ញុំ</h4>
                            {/* TRANSLATED: "Total Accumulated Savings" to Khmer */}
                            <p className="text-sm text-slate-400">សមតុល្យសរុប</p>
                            <p className="text-4xl font-bold text-white mt-2">
                                {Utils.formatCurrency(savingsData?.currentBalance || 0)}
                            </p>
                        </div>
                    )}

                    <div className="text-center text-sm text-slate-400"><p>Welcome, <span className="font-bold text-slate-200">{userProfile?.name}</span></p><p>Your selected shop is <span className="font-bold text-slate-200">{selectedShopForCheckIn || 'N/A'}</span></p>{lastAction && (<p className="mt-2">Last action: Checked <span className="font-semibold text-slate-200">{
                        /* FIX: Format the last action timestamp using the shop's timezone for consistency. */
                        Utils.formatDateInTimezone(lastAction.timestamp, userShop?.timezone).localTime
                    }</span></p>)}</div>
                    {/* New Salary Preview Section */}
                    <div className="w-full max-w-md mt-8 p-4 bg-slate-700/50 border border-slate-600 rounded-lg">
                        <div className="flex justify-between items-center mb-4">
                             <h4 className="text-lg font-semibold text-slate-100">ប្រាក់ខែរកបាន</h4>
                             <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input !mt-0 w-auto" />
                        </div>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            {/* Earnings Column */}
                            <div className="space-y-2">
                                <h5 className="font-semibold text-slate-200 border-b border-slate-600 pb-1 mb-2">ប្រាក់ចំណូល :</h5>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ថ្ងៃធ្វើការ :</span><span className="font-semibold text-slate-200">{inputs.workDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ផ្តល់ជូន :</span><span className="font-semibold text-slate-200">{inputs.givenOffDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ថែមម៉ោង :</span><span className="font-semibold text-slate-200">{inputs.otDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ប្រាក់បន្ថែម :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(calculations.engagements)}</span></div>
                                
                                {/* --- NEW: Add Savings Payback line --- */}
                                {calculations.totalSavingsWithdrawal > 0 && (
                                    <div className="flex justify-between items-center text-sm" title="Savings Program Payback">
                                        <span className="text-slate-400">ការទូទាត់សងប្រាក់សន្សំ :</span>
                                        <span className="font-semibold text-indigo-400">{Utils.formatCurrency(calculations.totalSavingsWithdrawal)}</span>
                                    </div>
                                )}
                                
                                <div className="pt-2 border-t border-slate-600 flex justify-between items-center text-sm"><span className="font-bold text-green-400">ប្រាក់ចំណូលសរុប :</span><span className="font-bold text-green-400">{Utils.formatCurrency(calculations.grossSalary)}</span></div>
                            </div>
                            {/* Deductions Column */}
                            <div className="space-y-2">
                                <h5 className="font-semibold text-slate-200 border-b border-slate-600 pb-1 mb-2">ការកាត់ប្រាក់ :</h5>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ច្បាប់សម្រាក :</span><span className="font-semibold text-slate-200">{inputs.leaveDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">មកយឺតសរុប :</span><span className="font-semibold text-slate-200">{inputs.totalLateDays || 0}</span></div>
                                <div className="flex justify-between items-center text-sm" title="អវត្តមាន + ភ្លេចចុចចេញ"><span className="text-slate-400">អវត្តមាន :</span><span className="font-semibold text-slate-200">{inputs.noAttendance || 0}</span></div>
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">បំណុលរំលួស :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(inputs.loanDeduction)}</span></div>
                                {calculations.savingsDeduction > 0 && (
                                    <div className="flex justify-between items-center text-sm">
                                        <span className="text-slate-400">ការកាត់សន្សំ :</span>
                                        <span className="font-semibold text-blue-400">{Utils.formatCurrency(calculations.savingsDeduction)}</span>
                                    </div>
                                )}
                                {calculations.rejectedLeavePenaltyAmount > 0 && (
                                    <div className="flex justify-between items-center text-sm" title="Penalty for absence on a day with a rejected leave request">
                                        <span className="text-slate-400">ច្បាប់សម្រាកបដិសេធ :</span>
                                        <span className="font-semibold text-red-400">{Utils.formatCurrency(calculations.rejectedLeavePenaltyAmount)}</span>
                                    </div>
                                )}
                                <div className="flex justify-between items-center text-sm"><span className="text-slate-400">ការកាត់ផ្សេងៗ :</span><span className="font-semibold text-slate-200">{Utils.formatCurrency(calculations.otherDeductions)}</span></div>
                                <div className="pt-2 border-t border-slate-600 flex justify-between items-center text-sm"><span className="font-bold text-red-400">ការកាត់ប្រាក់សរុប :</span><span className="font-bold text-red-400">{Utils.formatCurrency(calculations.totalDeductions)}</span></div>
                            </div>
                        </div>
                        <div className="mt-4 pt-4 border-t border-slate-600 flex justify-between items-center">
                            <span className="font-bold text-slate-200">ប្រាក់ខែសុទ្ធទទួលបាន :</span>
                            <span className="text-xl font-bold text-blue-400">{Utils.formatCurrency(calculations.netSalary)}</span>
                        </div>
                    </div>
                </div>
                {/* Alert Modal for Pending Leave */}
                <Modal isOpen={alertModal.isOpen} onClose={() => setAlertModal({ isOpen: false, message: '' })} maxWidth="max-w-sm">
                    <ModalHeader title="Notification" onClose={() => setAlertModal({ isOpen: false, message: '' })} />
                    <ModalBody><p className="text-slate-300">{alertModal.message}</p></ModalBody>
                    <ModalFooter><Button variant="primary" onClick={() => setAlertModal({ isOpen: false, message: '' })}>OK</Button></ModalFooter>
                </Modal>
                </Card>
            );
        };
        
        // Component: Leave Request Modal
        const LeaveRequestModal = ({ isOpen, onClose, onSave, request, userProfile }) => {
            const [formData, setFormData] = useState({});
            
            // Get global data from context
            const { shops, employees } = useAppData();

            const isManagerial = useMemo(() => userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager', [userProfile]);

            // Filter employees for the dropdown based on the selected shop in the modal
            const employeesInShop = useMemo(() => {
                if (!formData.shop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shop) && emp.status === 'Active';
                });
            }, [formData.shop, employees]);
            
            // Determine which shops should be available in the dropdown
            const availableShopsForModal = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return []; // Staff don't get a shop dropdown
            }, [userProfile, shops]);

            useEffect(() => {
                if (request) { // EDIT mode: Populate with existing request data
                    setFormData(request);
                } else if (userProfile) { // NEW request mode
                    const initialData = {
                        leaveDate: new Date().toISOString().substring(0, 10),
                        returnDate: new Date().toISOString().substring(0, 10),
                        numberOfDays: 1,
                        leaveSession: 'Full Day',
                        leaveType: 'Relaxing Leave',
                        reason: '',
                        // Conditionally pre-fill based on role
                        shop: isManagerial ? '' : (Array.isArray(userProfile.shop) ? userProfile.shop[0] : userProfile.shop || ''),
                        staffId: isManagerial ? '' : (userProfile.id || ''),
                        staffName: isManagerial ? '' : (userProfile.name || ''),
                        supervisor: isManagerial ? '' : (userProfile.supervisor || ''),
                    };
                    setFormData(initialData);
                }
            }, [request, userProfile, isOpen, isManagerial]);

            const dateDiffInDays = useMemo(() => {
                if (formData.leaveDate && formData.returnDate) {
                    const start = new Date(formData.leaveDate);
                    const end = new Date(formData.returnDate);
                    if (end <= start) return 0;
                    const diffTime = end.getTime() - start.getTime();
                    return Math.round(diffTime / (1000 * 60 * 60 * 24));
                }
                return 0;
            }, [formData.leaveDate, formData.returnDate]);

            const isMultiDayLeave = dateDiffInDays > 1;

            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                let newFormData = { ...formData, [name]: value };

                // When a manager selects a shop, reset the staff selection
                if (name === 'shop') {
                    newFormData.staffId = '';
                    newFormData.staffName = '';
                    newFormData.supervisor = '';
                }

                // When a manager selects a staff member, populate their details
                if (name === 'staffId') {
                    const selectedEmployee = employees.find(emp => emp.id === value);
                    if (selectedEmployee) {
                        newFormData.staffName = selectedEmployee.name;
                        newFormData.supervisor = selectedEmployee.supervisor || '';
                    } else {
                        newFormData.staffName = '';
                        newFormData.supervisor = '';
                    }
                }

                // Recalculate days based on dates and session.
                const { leaveDate, returnDate, leaveSession } = newFormData;

                if (leaveDate && returnDate) {
                    const start = new Date(leaveDate);
                    const end = new Date(returnDate);
                    start.setHours(0, 0, 0, 0); // Normalize to avoid timezone issues
                    end.setHours(0, 0, 0, 0);

                    if (end < start) {
                        newFormData.numberOfDays = 0;
                    } else {
                        const diffTime = end.getTime() - start.getTime();
                        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

                        // Case: User selects same leave and return date. We interpret this as a single-day event.
                        if (diffDays === 0) {
                            if (leaveSession === 'Full Day') { newFormData.numberOfDays = 1; } 
                            else { newFormData.numberOfDays = 0.5; }
                        } 
                        // Case: Standard single day leave (e.g., leave Mon, return Tue)
                        else if (diffDays === 1) {
                            if (leaveSession === 'Full Day') { newFormData.numberOfDays = 1; } 
                            else { newFormData.numberOfDays = 0.5; }
                        } 
                        // Case: Multi-day leave
                        else {
                            newFormData.numberOfDays = diffDays;
                            newFormData.leaveSession = 'Full Day'; // Force full day for multi-day leaves
                        }
                    }
                } else {
                    newFormData.numberOfDays = 0;
                }
                
                setFormData(newFormData);
            }, [formData, employees]);
            
            const handleSubmit = useCallback((e) => { 
                e.preventDefault(); 
                if ((isManagerial || Array.isArray(userProfile.shop)) && !formData.shop) {
                    alert("Please select a shop for the leave request.");
                    return;
                }
                const dataToSave = { ...formData };
                if (dataToSave.leaveDate && dataToSave.leaveDate === dataToSave.returnDate) {
                    const returnDate = new Date(dataToSave.returnDate);
                    returnDate.setDate(returnDate.getDate() + 1);
                    dataToSave.returnDate = returnDate.toISOString().substring(0, 10);
                }
                onSave(dataToSave); 
            }, [onSave, formData, isManagerial, userProfile]);
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={request ? "Edit Leave Request" : "New Leave Request"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div><label className="text-sm">Leave Date</label><input type="date" name="leaveDate" value={formData.leaveDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Return Date</label><input type="date" name="returnDate" value={formData.returnDate || ''} onChange={handleChange} className="input" required /></div>
                                
                                <div>
                                    <label className="text-sm">Session</label>
                                    <select name="leaveSession" value={formData.leaveSession || 'Full Day'} onChange={handleChange} className="select" disabled={isMultiDayLeave}>
                                        <option value="Full Day">Full Day</option>
                                        <option value="AM">AM (Morning)</option>
                                        <option value="PM">PM (Afternoon)</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-sm">No. Day(s)</label>
                                    <input 
                                        type="number"
                                        name="numberOfDays" 
                                        value={formData.numberOfDays || ''} 
                                        className="input" required 
                                        disabled
                                    />
                                </div>
                                
                                {isManagerial ? (
                                    <div>
                                        <label className="text-sm">Shop Name</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" required>
                                            <option value="">Select Shop</option>
                                            {availableShopsForModal.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Shop Name</label><input value={formData.shop || ''} className="input" disabled /></div>
                                )}
                                
                                {isManagerial && !request ? (
                                    <div>
                                        <label className="text-sm">Staff Name</label>
                                        <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shop}>
                                            <option value="">Select Staff</option>
                                            {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Staff Name</label><input value={formData.staffName || ''} className="input" disabled /></div>
                                )}
                                
                                <div><label className="text-sm">Supervisor</label><input value={formData.supervisor || ''} className="input" disabled /></div>

                                <div className="lg:col-span-3"><label className="text-sm">Leave Type</label>
                                    <select name="leaveType" value={formData.leaveType || 'Relaxing Leave'} onChange={handleChange} className="select" required>
                                        <option>Relaxing Leave</option>
                                        <option>Sick Leave</option>
                                        <option>Emergency Leave</option>
                
                                    </select>
                                </div>
                                <div className="lg:col-span-3"><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3" required></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Submit Request</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        // Component: OT Request Modal
        const OTRequestModal = ({ isOpen, onClose, onSave, request, userProfile }) => {
            const [formData, setFormData] = useState({});
            
            // Get global data from context
            const { shops, employees } = useAppData();

            const isManagerial = useMemo(() => userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager', [userProfile]);
            
            // Filter employees for dropdown based on selected shop
            const employeesInShop = useMemo(() => {
                if (!formData.shop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(formData.shop) && emp.status === 'Active';
                });
            }, [formData.shop, employees]);

            // Determine available shops for dropdown
            const availableShopsForModal = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return shops;
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [userProfile, shops]);

            // Initialize form data
            useEffect(() => {
                if (request) { // EDIT mode
                    setFormData(request);
                } else if (userProfile) { // NEW request mode
                    const initialData = {
                        reqDate: new Date().toISOString().substring(0, 10),
                        startTime: '', endTime: '', numberOfOTDays: 0, reason: '',
                        shop: isManagerial ? '' : (Array.isArray(userProfile.shop) ? userProfile.shop[0] : userProfile.shop || ''),
                        staffId: isManagerial ? '' : (userProfile.id || ''),
                        staffName: isManagerial ? '' : (userProfile.name || ''),
                        supervisor: isManagerial ? '' : (userProfile.supervisor || ''),
                    };
                    setFormData(initialData);
                }
            }, [request, userProfile, isOpen, isManagerial]);

            // Calculate OT days from start and end times
            useEffect(() => {
                if (formData.startTime && formData.endTime && formData.staffId && employees) {
                    const selectedEmployee = employees.find(e => e.id === formData.staffId);
                    const employeeShift = selectedEmployee ? selectedEmployee.shift : null;

                    if (employeeShift && (employeeShift === 'AM' || employeeShift === 'PM')) {
                        if (formData.startTime === '07:30' && formData.endTime === '17:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1 })); return; }
                        if (formData.startTime === '07:30' && formData.endTime === '21:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1.5 })); return; }
                    }
                    if (employeeShift && employeeShift === 'APM') {
                         if (formData.startTime === '07:30' && formData.endTime === '21:00') { setFormData(prev => ({ ...prev, numberOfOTDays: 1 })); return; }
                    }

                    const [startHour, startMinute] = formData.startTime.split(':').map(Number);
                    const [endHour, endMinute] = formData.endTime.split(':').map(Number);

                    if (!isNaN(startHour) && !isNaN(startMinute) && !isNaN(endHour) && !isNaN(endMinute)) {
                        const startDate = new Date(0, 0, 0, startHour, startMinute, 0);
                        let endDate = new Date(0, 0, 0, endHour, endMinute, 0);
                        if (endDate < startDate) { endDate.setDate(endDate.getDate() + 1); }
                        const diffMillis = endDate - startDate;
                        const diffHours = diffMillis / (1000 * 60 * 60);
                        let otDays = 0;
                        const OT_HOURS_PER_DAY = 8;
                        if (diffHours < 4) { otDays = 0; } 
                        else if (diffHours >= 4 && diffHours <= 5) { otDays = 0.5; } 
                        else { otDays = diffHours / OT_HOURS_PER_DAY; }
                        setFormData(prev => ({ ...prev, numberOfOTDays: otDays > 0 ? otDays.toFixed(2) : 0 }));
                    }
                }
            }, [formData.startTime, formData.endTime, formData.staffId, employees]);

            const handleChange = useCallback((e) => { 
                const { name, value } = e.target;
                let newFormData = { ...formData, [name]: value };

                if (name === 'shop') {
                    newFormData.staffId = '';
                    newFormData.staffName = '';
                    newFormData.supervisor = '';
                }
                if (name === 'staffId') {
                    const selectedEmployee = employees.find(emp => emp.id === value);
                    if (selectedEmployee) {
                        newFormData.staffName = selectedEmployee.name;
                        newFormData.supervisor = selectedEmployee.supervisor || '';
                    } else {
                        newFormData.staffName = '';
                        newFormData.supervisor = '';
                    }
                }
                setFormData(newFormData);
            }, [formData, employees]);
            
            const handleSubmit = useCallback((e) => { 
                e.preventDefault(); 
                if ((isManagerial || Array.isArray(userProfile.shop)) && !formData.shop) {
                    alert("Please select a shop for the OT request.");
                    return;
                }
                onSave(formData); 
            }, [onSave, formData, isManagerial, userProfile]);
            
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={request ? "Edit OT Request" : "New OT Request"} onClose={onClose} />
                        <ModalBody>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div><label className="text-sm">OT Date</label><input type="date" name="reqDate" value={formData.reqDate || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">Start Hour</label><input type="time" name="startTime" value={formData.startTime || ''} onChange={handleChange} className="input" required /></div>
                                <div><label className="text-sm">End Hour</label><input type="time" name="endTime" value={formData.endTime || ''} onChange={handleChange} className="input" required /></div>
                                
                                {isManagerial ? (
                                    <div>
                                        <label className="text-sm">Shop Name</label>
                                        <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" required>
                                            <option value="">Select Shop</option>
                                            {availableShopsForModal.map(shop => <option key={shop.id} value={shop.name}>{shop.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Shop Name</label><input value={formData.shop || ''} className="input" disabled /></div>
                                )}
                                
                                {isManagerial && !request ? (
                                    <div>
                                        <label className="text-sm">Staff Name</label>
                                        <select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" required disabled={!formData.shop}>
                                            <option value="">Select Staff</option>
                                            {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                        </select>
                                    </div>
                                ) : (
                                    <div><label className="text-sm">Staff Name</label><input value={formData.staffName || ''} className="input" disabled /></div>
                                )}
                                
                                <div><label className="text-sm">Supervisor</label><input value={formData.supervisor || ''} className="input" disabled /></div>
                                
                                <div className="lg:col-span-3"><label className="text-sm">No. OT Day(s)</label><input type="number" name="numberOfOTDays" value={formData.numberOfOTDays || ''} className="input" disabled /></div>
                                <div className="lg:col-span-3"><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3" required></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Submit Request</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // Component: A single card for displaying a request in the mobile view
        const RequestCard = memo(({ request, userProfile, config, onUpdateStatus, onEdit, onDelete }) => {
            const { cardFields } = config;

            return (
                <div className="bg-slate-700/50 rounded-lg p-4 space-y-3 flex flex-col">
                    <div className="flex justify-between items-start">
                        <div>
                            <p className="font-bold text-lg text-slate-100">{request.staffName}</p>
                            <p className="text-sm text-slate-300">{request.shop}</p>
                        </div>
                        <span className="px-2 py-1 text-xs font-semibold rounded-full bg-yellow-200 text-yellow-900">{request.status}</span>
                    </div>
                    <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-2 border-t border-slate-600 flex-grow">
                        {cardFields.map(field => (
                            <div key={field.label}>
                                <p className="text-slate-400">{field.label}</p>
                                <p className="text-slate-200 font-medium">{field.value(request)}</p>
                            </div>
                        ))}
                        <div className="col-span-2">
                            <p className="text-slate-400">Reason</p>
                            <p className="text-slate-200 font-medium whitespace-pre-wrap">{request.reason}</p>
                        </div>
                    </div>
                    <div className="flex justify-end space-x-3 pt-2">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && userProfile.id !== request.staffId)) && request.status === 'Pending' && (
                            <>
                                <Button variant="icon-approve" icon="fa-check-circle" onClick={() => onUpdateStatus(request.id, 'Approved')} title="Approve" className="text-xl" />
                                <Button variant="icon-reject" icon="fa-times-circle" onClick={() => onUpdateStatus(request.id, 'Rejected')} title="Reject" className="text-xl" />
                            </>
                        )}
                        <Button variant="icon-edit-alt" icon="fa-edit" onClick={() => onEdit(request)} title="Edit" className="text-xl" />
                        <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(request.id)} title="Delete" className="text-xl" />
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Request Filters Component
        const RequestFilters = memo(({
            title, userProfile, shops, employeesInShop,
            selectedShop, setSelectedShop, selectedEmployeeId, setSelectedEmployeeId,
            filterPeriod, setFilterPeriod, customDate, setCustomDate,
            onNewRequest
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <h3 className="text-xl font-semibold text-slate-100">{title}s</h3>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile.role === 'Admin' || (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile.role === 'Admin' ? 'All Shops' : 'All My Shops'}</option>
                                {(userProfile.role === 'Admin' ? shops : (userProfile.shop || []).map(name => ({ id: name, name: name }))).map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                        {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && selectedShop && (
                            <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">All Staff</option>
                                {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                            </select>
                        )}
                        {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && (
                            <select value={filterPeriod} onChange={e => setFilterPeriod(e.target.value)} className="select w-full sm:w-auto">
                                <option value="thisWeek">This Week</option><option value="thisMonth">This Month</option>
                                <option value="lastMonth">Last Month</option><option value="thisYear">This Year</option>
                                <option value="custom">Custom Date</option>
                            </select>
                        )}
                        {filterPeriod === 'custom' && (<input type="date" value={customDate} onChange={e => setCustomDate(e.target.value)} className="input w-full sm:w-auto" />)}
                        <Button variant="primary" icon="fa-plus" onClick={onNewRequest}>New Request</Button>
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Pending Requests Grid
        const PendingRequestsGrid = memo(({ requests, userProfile, config, onUpdateStatus, onEdit, onDelete }) => {
            if (requests.length === 0) return null;
            return (
                <div className="mb-8">
                    <h4 className="text-lg font-semibold text-slate-200 mb-4">Pending Requests</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        {requests.map(req => (
                            <RequestCard
                                key={req.id}
                                request={req}
                                userProfile={userProfile}
                                config={config}
                                onUpdateStatus={onUpdateStatus}
                                onEdit={onEdit}
                                onDelete={onDelete}
                            />
                        ))}
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Request History Table
        const RequestHistoryTable = memo(({ requests, title, config, onEdit, onDelete, onViewReason }) => {
            const { tableColumns } = config;
            return (
                <div>
                    <h4 className="text-lg font-semibold text-slate-200 mb-4">{title} History</h4>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-slate-700">
                            <thead className="bg-slate-900/50">
                                <tr>
                                    {tableColumns.map(col => <th key={col.header} className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">{col.header}</th>)}
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Reason</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th>
                                    <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Approval Time</th>
                                    <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-700">
                                {requests.map(req => (
                                    <tr key={req.id} className="hover:bg-slate-700/50">
                                        {tableColumns.map(col => <td key={col.header} className="px-4 py-4 text-sm text-slate-300">{typeof col.accessor === 'function' ? col.accessor(req) : req[col.accessor]}</td>)}
                                        <td className="px-4 py-4 text-center text-sm"><Button variant="icon-view" icon="fa-eye" onClick={() => onViewReason(req.reason)} /></td>
                                        <td className="px-4 py-4 text-center text-sm"><span className={`px-2 py-1 text-xs font-semibold rounded-full ${req.status === 'Approved' ? 'bg-green-200 text-green-900' : 'bg-red-200 text-red-900'}`}>{req.status}</span></td>
                                        <td className="px-4 py-4 text-sm text-slate-300">{req.status === 'Approved' ? req.approvalTimestamp || '' : ''}</td>
                                        <td className="px-4 py-4 text-center whitespace-nowrap">
                                            <div className="flex items-center justify-center gap-4">
                                                <Button variant="icon-edit-alt" icon="fa-edit" onClick={() => onEdit(req)} title="Edit" />
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDelete(req.id)} title="Delete" />
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        });

        // Component: Generic Tab for managing requests (Leave, OT, etc.)
        const RequestManagementTab = ({ userProfile, config }) => {
            const { collectionName, title, ModalComponent, dateField, submissionDateField } = config;
            const { db } = useFirebase();
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingRequest, setEditingRequest] = useState(null);
            const [requestToDelete, setRequestToDelete] = useState(null);
            const [reasonToView, setReasonToView] = useState(null);
            const { where } = window.firebaseSDK;
            // REFACTORED: Get global data from context instead of separate collection calls.
            const { shops, employees } = useAppData();
            const [selectedShop, setSelectedShop] = useState('');
            const [filterPeriod, setFilterPeriod] = useState('thisMonth');
            const [customDate, setCustomDate] = useState(new Date().toISOString().slice(0, 10));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');

            // Set initial shop filter based on user role
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            // Define query constraints to fetch requests based on user role
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("staffId", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) return [where("shop", "in", shops)];
                    return [where("staffId", "==", "null")];
                }
                return [where("staffId", "==", userProfile.id)];
            }, [userProfile]);

            const { data: requests } = useCollection(collectionName, queryConstraints);

            // Get employees for the filter dropdown based on selected shop
            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            // Filter and sort requests for display
            const { pendingRequests, historyRequests } = useMemo(() => {
                const filtered = requests.filter(req => {
                    if (!req[dateField]) return false;
                    const now = new Date();
                    let dateMatch = false;
                    switch (filterPeriod) {
                        case 'thisWeek':
                            const startOfWeek = new Date(now);
                            startOfWeek.setDate(now.getDate() - now.getDay());
                            startOfWeek.setHours(0, 0, 0, 0);
                            const endOfWeek = new Date(startOfWeek);
                            endOfWeek.setDate(startOfWeek.getDate() + 6);
                            endOfWeek.setHours(23, 59, 59, 999);
                            const reqDate = new Date(req[dateField]);
                            dateMatch = reqDate >= startOfWeek && reqDate <= endOfWeek;
                            break;
                        // FIX: The following cases now use local date components to avoid timezone errors.
                        case 'thisMonth':
                            const year_tm = now.getFullYear();
                            const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                            dateMatch = req[dateField].startsWith(`${year_tm}-${month_tm}`);
                            break;
                        case 'lastMonth':
                            const lastMonthDate = new Date();
                            lastMonthDate.setMonth(lastMonthDate.getMonth() - 1);
                            const year_lm = lastMonthDate.getFullYear();
                            const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                            dateMatch = req[dateField].startsWith(`${year_lm}-${month_lm}`);
                            break;
                        case 'thisYear':
                            dateMatch = req[dateField].startsWith(now.getFullYear().toString());
                            break;
                        case 'custom':
                            dateMatch = req[dateField] === customDate;
                            break;
                        default:
                            dateMatch = true;
                    }
                    return dateMatch && (!selectedShop || req.shop === selectedShop) && (!selectedEmployeeId || req.staffId === selectedEmployeeId);
                });

                const pending = filtered.filter(req => req.status === 'Pending').sort((a, b) => (b[submissionDateField]?.toDate() || 0) - (a[submissionDateField]?.toDate() || 0));
                const history = filtered.filter(req => req.status !== 'Pending').sort((a, b) => (b[submissionDateField]?.toDate() || 0) - (a[submissionDateField]?.toDate() || 0));
                
                return { pendingRequests: pending, historyRequests: history };
            }, [requests, selectedShop, selectedEmployeeId, filterPeriod, customDate, dateField, submissionDateField]);

            const handleOpenModal = useCallback((request = null) => { setEditingRequest(request); setModalOpen(true); }, []);
            const handleCloseModal = useCallback(() => { setEditingRequest(null); setModalOpen(false); }, []);
            
            const handleSaveRequest = useCallback(async (formData) => {
                const { doc, addDoc, updateDoc, collection, serverTimestamp } = window.firebaseSDK;
                const staffName = employees.find(e => e.id === formData.staffId)?.name || '';
                try {
                    if (formData.id) { 
                        const { id, ...dataToUpdate } = formData; 
                        await updateDoc(doc(db, collectionName, id), { ...dataToUpdate, staffName }); 
                    } else { 
                        const dataToAdd = { ...formData, staffName, status: 'Pending' };
                        dataToAdd[submissionDateField] = serverTimestamp();
                        await addDoc(collection(db, collectionName), dataToAdd); 
                    }
                    handleCloseModal();
                } catch (error) { console.error(`Error saving ${title}:`, error); }
            }, [db, employees, handleCloseModal, collectionName, title, submissionDateField]);

            const handleUpdateRequestStatus = useCallback(async (id, status) => {
                const { doc, updateDoc } = window.firebaseSDK;
                const dataToUpdate = { status };
                if (status === 'Approved') {
                    const now = new Date();
                    const formattedTimestamp = `${String(now.getDate()).padStart(2, '0')}/${String(now.getMonth() + 1).padStart(2, '0')} | ${now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}`;
                    dataToUpdate.approvalTimestamp = formattedTimestamp;
                }
                try { await updateDoc(doc(db, collectionName, id), dataToUpdate); } 
                catch (error) { console.error(`Error updating status for ${title} ${id}:`, error); }
            }, [db, collectionName, title]);

            const confirmDelete = useCallback(async () => {
                if (!requestToDelete) return;
                try { await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, collectionName, requestToDelete)); } 
                catch (error) { console.error(`Error deleting ${title} ${requestToDelete}:`, error); } 
                finally { setRequestToDelete(null); }
            }, [db, requestToDelete, collectionName, title]);

            return (
                <Card>
                    <RequestFilters
                        title={title}
                        userProfile={userProfile}
                        shops={shops}
                        employeesInShop={employeesInShop}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        selectedEmployeeId={selectedEmployeeId}
                        setSelectedEmployeeId={setSelectedEmployeeId}
                        filterPeriod={filterPeriod}
                        setFilterPeriod={setFilterPeriod}
                        customDate={customDate}
                        setCustomDate={setCustomDate}
                        onNewRequest={() => handleOpenModal()}
                    />
                    <PendingRequestsGrid
                        requests={pendingRequests}
                        userProfile={userProfile}
                        config={config}
                        onUpdateStatus={handleUpdateRequestStatus}
                        onEdit={handleOpenModal}
                        onDelete={setRequestToDelete}
                    />
                    <RequestHistoryTable
                        requests={historyRequests}
                        title={title}
                        config={config}
                        onEdit={handleOpenModal}
                        onDelete={setRequestToDelete}
                        onViewReason={setReasonToView}
                    />
                    {/* REFACTORED: Removed shops and employees props as the modal now gets them from context */}
                    <ModalComponent isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSaveRequest} request={editingRequest} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!requestToDelete} onClose={() => setRequestToDelete(null)} onConfirm={confirmDelete} title={`Delete ${title}`} message={`Are you sure you want to permanently delete this ${title.toLowerCase()}?`} />
                    <Modal isOpen={!!reasonToView} onClose={() => setReasonToView(null)} maxWidth="max-w-md">
                        <ModalHeader title={`${title} Reason`} onClose={() => setReasonToView(null)} />
                        <ModalBody><p className="text-slate-300">{reasonToView}</p></ModalBody>
                        <ModalFooter><Button variant="secondary" onClick={() => setReasonToView(null)}>Close</Button></ModalFooter>
                    </Modal>
                </Card>
            );
        };
        
        // Component: Main CheckInMe Page (Tab Container)
        const CheckInMePage = ({ userProfile, initialTab = 'checkInOut' }) => {
            const [activeTab, setActiveTab] = useState(initialTab);

            useEffect(() => {
                setActiveTab(initialTab);
            }, [initialTab]);
            
            // Define configurations for our generic request management tab
            const leaveRequestConfig = {
                collectionName: 'leaveRequests',
                title: 'Leave Request',
                ModalComponent: LeaveRequestModal,
                dateField: 'leaveDate',
                submissionDateField: 'requestDate',
                cardFields: [
                    { label: 'Leave Date', value: (req) => Utils.formatISOToDisplay(req.leaveDate) },
                    { label: 'Return Date', value: (req) => Utils.formatISOToDisplay(req.returnDate) },
                    { label: 'Days', value: (req) => req.numberOfDays },
                    { label: 'Session', value: (req) => req.leaveSession || '-' },
                    { label: 'Supervisor', value: (req) => req.supervisor },
                    { label: 'Submitted', value: (req) => Utils.formatRequestDate(req.requestDate) },
                    // FIX: Ensured this value directly displays the saved req.leaveType
                    { label: 'Type', value: (req) => req.leaveType },
                ],
                tableColumns: [
                    { header: 'Request Date', accessor: (req) => Utils.formatRequestDate(req.requestDate) },
                    { header: 'Shop', accessor: 'shop' },
                    { header: 'Name', accessor: 'staffName' },
                    { header: 'Leave Date', accessor: (req) => Utils.formatISOToDisplay(req.leaveDate) },
                    { header: 'Return Date', accessor: (req) => Utils.formatISOToDisplay(req.returnDate) },
                    { header: 'No. Days', accessor: 'numberOfDays' },
                    { header: 'Session', accessor: 'leaveSession' },
                    { header: 'Leave Type', accessor: 'leaveType' },
                    { header: 'Supervisor', accessor: 'supervisor' },
                ]
            };
            
            const otRequestConfig = {
                collectionName: 'otRequests',
                title: 'OT Request',
                ModalComponent: OTRequestModal,
                dateField: 'reqDate',
                submissionDateField: 'submissionDate',
                cardFields: [
                    { label: 'OT Date', value: (req) => Utils.formatISOToDisplay(req.reqDate) },
                    { label: 'Days', value: (req) => req.numberOfOTDays },
                    { label: 'Start Time', value: (req) => req.startTime || 'N/A' },
                    { label: 'End Time', value: (req) => req.endTime || 'N/A' },
                    { label: 'Supervisor', value: (req) => req.supervisor },
                    { label: 'Submitted', value: (req) => Utils.formatRequestDate(req.submissionDate) },
                ],
                tableColumns: [
                    { header: 'Request Date', accessor: (req) => Utils.formatRequestDate(req.submissionDate) },
                    { header: 'Shop', accessor: 'shop' },
                    { header: 'Name', accessor: 'staffName' },
                    { header: 'OT Date', accessor: (req) => Utils.formatISOToDisplay(req.reqDate) },
                    { header: 'Start Time', accessor: 'startTime' },
                    { header: 'End Time', accessor: 'endTime' },
                    { header: 'No. OT Days', accessor: 'numberOfOTDays' },
                    { header: 'Supervisor', accessor: 'supervisor' },
                ]
            };

            return (
                <TabbedPage tabs={{ checkInOut: 'Check In/Out', leaveRequest: 'Leave Request', otRequest: 'OT Request', employeeState: 'Engagements / Deductions' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="checkInOut"><CheckInOutTab userProfile={userProfile} /></div>
                    <div id="leaveRequest"><RequestManagementTab userProfile={userProfile} config={leaveRequestConfig} /></div>
                    <div id="otRequest"><RequestManagementTab userProfile={userProfile} config={otRequestConfig} /></div>
                    <div id="employeeState"><EmployeeStateTab userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };
        // --- END CHECKINME PAGE COMPONENTS ---

        // --- START ATTENDANCE REPORT PAGE ---

        // NEW: Phase 1 Refactoring - Daily Report Filters Component
        const DailyReportFilters = memo(({
            userProfile, selectedShop, setSelectedShop, searchTerm, setSearchTerm, availableShops, // MODIFIED: Replaced employeeId props with searchTerm
            filterType, setFilterType, customMonth, setCustomMonth, // MODIFIED: Removed employeesInShop
            selectedShift, setSelectedShift, uniqueShiftNames, onExportExcel
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <CardTitle>Daily Attendance Report</CardTitle>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSearchTerm(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                        {/* MODIFIED: Removed '&& selectedShop' condition to make search always visible */}
                        {userProfile?.role !== 'Staff' && (
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                        )}
                        <select value={filterType} onChange={e => setFilterType(e.target.value)} className="select w-full sm:w-auto">
                            <option value="today">Today</option>
                            <option value="yesterday">Yesterday</option>
                            <option value="thisMonth">This Month</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="custom">Custom Month</option>
                        </select>
                        {filterType === 'custom' && (
                            <input type="month" value={customMonth} onChange={e => setCustomMonth(e.target.value)} className="input w-full sm:w-auto" />
                        )}
                        <select value={selectedShift} onChange={e => setSelectedShift(e.target.value)} className="select w-full sm:w-auto">
                            <option value="">All Shifts</option>
                            {uniqueShiftNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                            <Button variant="success" icon="fa-file-excel" onClick={onExportExcel}>Excel</Button>
                    </div>
                </div>
            );
        });
        
        // NEW: Phase 1 Refactoring - Daily Report Table Component
        const DailyReportTable = memo(({ attendanceReport, userProfile, onAddCheckOut, onDeleteRecord }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shift</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Check In</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Check Out</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Leave Status</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">OT Status</th>
                                <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {attendanceReport.map((report) => (
                                <tr key={`${report.employeeId}-${report.date}`} className="transition-colors hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.date}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shop}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.employeeName}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shift}</td>
                                    <td className={`px-4 py-4 text-sm ${report.isLate ? 'bg-red-900/60 text-red-300 font-semibold' : 'text-slate-300'}`}>{report.checkIn}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.checkOut}</td>
                                    <td className={`px-4 py-4 text-sm text-center ${report.isOnLeave === 'Absent' ? 'text-red-400 font-semibold' : 'text-slate-300'}`}>{report.isOnLeave}</td>
                                    <td className="px-4 py-4 text-sm text-center text-slate-300">{report.otStatus}</td>
                                    <td className="px-4 py-4 text-center whitespace-nowrap">
                                        <div className="flex items-center justify-center gap-4">
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && report.checkIn && !report.checkOut && (
                                                <Button variant="icon-add-time" icon="fa-clock" onClick={() => onAddCheckOut(report)} title="Add Check-Out"/>
                                            )}
                                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && report.docIds.length > 0 && (
                                                <Button variant="icon-delete" icon="fa-trash" onClick={() => onDeleteRecord(report)} title="Delete" />
                                            )}
                                        </div>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Work Day Report Filters Component
        const WorkDayReportFilters = memo(({
            userProfile, selectedShop, setSelectedShop, searchTerm, setSearchTerm, availableShops, // MODIFIED: Replaced employeeId props with searchTerm
            filterType, setFilterType, selectedMonth, setSelectedMonth, // MODIFIED: Removed employeesInShop
            selectedShift, setSelectedShift, uniqueShiftNames, onExportExcel
        }) => {
            return (
                <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                    <CardTitle>Monthly Work Day Report</CardTitle>
                    <div className="flex flex-wrap gap-4 items-center">
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSearchTerm(''); }} className="select w-full sm:w-auto">
                                <option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                         {/* MODIFIED: Removed '&& selectedShop' condition to make search always visible */}
                         {userProfile?.role !== 'Staff' && (
                            <input 
                                type="text"
                                placeholder="Search by name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                        )}
                        <select value={filterType} onChange={e => setFilterType(e.target.value)} className="select w-full sm:w-auto">
                            <option value="thisMonth">This Month</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="custom">Custom Month</option>
                        </select>
                        {filterType === 'custom' && (
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm-w-auto" />
                        )}
                        <select value={selectedShift} onChange={e => setSelectedShift(e.target.value)} className="select w-full sm:w-auto">
                            <option value="">All Shifts</option>
                            {uniqueShiftNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                        <Button variant="success" icon="fa-file-excel" onClick={onExportExcel}>Excel</Button>
                    </div>
                </div>
            );
        });

        // NEW: Phase 1 Refactoring - Work Day Report Table Component
        const WorkDayReportTable = memo(({ workDayReport }) => {
            return (
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-slate-700">
                        <thead className="bg-slate-900/50">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No. Work Day</th>
                                {/* BUG FIX: Re-add the Given Off Day column header */}
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Given Off Day</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total OT</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total Leave No</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Total LATE</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No-CheckOut</th>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">No-Absent</th>
                                {/* NEW: Add Salary Day header */}
                                <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Salary Day</th>
                                {/* REMOVED: "Total-Day" header */}
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700">
                            {workDayReport.map((report, index) => (
                                <tr key={`${report.staffName}-${report.dueTime}-${index}`} className="hover:bg-slate-700/50">
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.dueTime}</td>
                                    <td className="px-4 py-4 text-sm text-slate-300">{report.shopName}</td>
                                    <td className="px-4 py-4 text-sm text-slate-200">{report.staffName}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-blue-400">{report.workDays}</td>
                                    {/* BUG FIX: Re-add the Given Off Day data cell */}
                                    <td className="px-4 py-4 text-sm font-semibold text-cyan-400">{report.givenOffDays}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-green-400">{report.totalOT > 0 ? report.totalOT.toFixed(2) : 0}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-yellow-400">{report.totalLeave}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-red-400">{report.totalLate}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-orange-400">{report.noCheckOutCount}</td>
                                    <td className="px-4 py-4 text-sm font-semibold text-red-500">{report.noAbsentCount}</td>
                                    {/* NEW: Add Salary Day data cell, formatted to 2 decimal places */}
                                    <td className="px-4 py-4 text-sm font-semibold text-indigo-400">{report.salaryDay.toFixed(2)}</td>
                                    {/* REMOVED: "Total-Day" data cell */}
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        });

         const AttendanceReportPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('daily');
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;
            const [reportData, setReportData] = useState({ leaveRequests: [], otRequests: [] });
            const [loading, setLoading] = useState(false);

            // PHASE 3 OPTIMIZATION: For Admins/CEOs, we now fetch this data on-demand in the child components.
            // For other roles, we maintain the real-time listener for a better experience on their smaller datasets.
            const isRealTime = userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO';
            
            const staffQueryConstraints = useMemo(() => {
                const { role, id, shop } = userProfile || {};
                if (role === 'Staff' && id) {
                    return [where("staffId", "==", id)];
                }
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        return [where("shop", "in", managedShops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops assigned, so return no results.
                }
                return []; // Admin query is built on-demand.
            }, [userProfile]);
            
            // Real-time data for Staff/Managers
            const { data: realTimeLeaveRequests } = useCollection('leaveRequests', isRealTime ? staffQueryConstraints : []);
            const { data: realTimeOtRequests } = useCollection('otRequests', isRealTime ? staffQueryConstraints : []);
            
            // On-demand data for Admins (passed down)
            const leaveRequests = isRealTime ? realTimeLeaveRequests : reportData.leaveRequests;
            const otRequests = isRealTime ? realTimeOtRequests : reportData.otRequests;

            return (
                <TabbedPage tabs={{ daily: 'Daily Report', monthly: 'No. Work Day' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="daily"><DailyReportTab userProfile={userProfile} leaveRequests={leaveRequests} otRequests={otRequests} setAdminReportData={setReportData} setLoadingAdminReport={setLoading} isAdminLoading={loading} /></div>
                    <div id="monthly"><WorkDayReportTab userProfile={userProfile} leaveRequests={leaveRequests} otRequests={otRequests} setAdminReportData={setReportData} setLoadingAdminReport={setLoading} isAdminLoading={loading} /></div>
                </TabbedPage>
            );
        };

        // NEW: Modal for manually adding a check-out time
        const ManualCheckOutModal = ({ isOpen, onClose, onSave, record }) => {
            const [checkOutTime, setCheckOutTime] = useState('');

            useEffect(() => {
                // Reset time when modal opens for a new record
                if (isOpen) {
                    setCheckOutTime('');
                }
            }, [isOpen]);
            
            const handleSubmit = (e) => {
                e.preventDefault();
                if (record && checkOutTime) {
                    onSave(record, checkOutTime);
                }
            };

            if (!record) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-md">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title="Add Manual Check-Out" onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Employee</label>
                                    <input value={record.employeeName} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Date</label>
                                    <input value={record.date} className="input" disabled />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Check-Out Time</label>
                                    <input
                                        type="time"
                                        value={checkOutTime}
                                        onChange={(e) => setCheckOutTime(e.target.value)}
                                        className="input"
                                        required
                                    />
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Save Check-Out</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };

        const DailyReportTab = ({ userProfile, leaveRequests, otRequests, setAdminReportData, setLoadingAdminReport, isAdminLoading }) => {
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;
            const [recordToDelete, setRecordToDelete] = useState(null);
            const [recordToCorrect, setRecordToCorrect] = useState(null);
            const [isCorrectionModalOpen, setCorrectionModalOpen] = useState(false);

            // Filters State
            const [selectedShop, setSelectedShop] = useState('');
            const [filterType, setFilterType] = useState('today');
            const [customMonth, setCustomMonth] = useState(new Date().toISOString().slice(0, 7));
            // MODIFIED: Renamed state from selectedEmployeeId to searchTerm
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedShift, setSelectedShift] = useState('');

            // Data State
            const { data: shops } = useCollection('shops');
            const { data: employees } = useCollection('employees');
            const { data: shifts } = useCollection('shifts');
            
            // NEW: Create a unique list of shift names for the filter dropdown to avoid duplicates.
            const uniqueShiftNames = useMemo(() => {
                if (!shifts) return [];
                const shiftNames = shifts.map(s => s.name);
                // Use a Set to get unique names, then spread it back into an array and sort it.
                return [...new Set(shiftNames)].sort();
            }, [shifts]);
            
            // PHASE 3: Data state for Admin's one-time fetches
            const [adminAttendance, setAdminAttendance] = useState([]);
            
            // PHASE 2 & 3: Combined logic for fetching attendance data.
            const isRealTime = userProfile?.role !== 'Admin';
            const attendanceQueryConstraints = useMemo(() => {
                // This is ONLY for real-time listeners (Staff/Manager)
                if (!isRealTime) return []; 
                
                const { role, id, shop } = userProfile || {};
                if (role === 'Staff' && id) return [where("employeeId", "==", id)];
                
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) return [where("shop", "in", managedShops)];
                    return [where("employeeId", "==", "null")];
                }
                return []; // Should not happen for real-time
            }, [userProfile, isRealTime]);
            
            const { data: realTimeAttendance, loading: attendanceLoading } = useCollection('attendance', attendanceQueryConstraints);
            const attendance = isRealTime ? realTimeAttendance : adminAttendance;
            const isReportLoading = isRealTime ? attendanceLoading : isAdminLoading;
            
            // PHASE 3: ON-DEMAND DATA FETCHING FOR ADMIN (OPTIMIZED) ---
            useEffect(() => {
                // This effect now runs whenever the main filters change.
                if (userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO') return;

                const fetchAdminData = async () => {
                    setLoadingAdminReport(true);
                    
                    const startDate = new Date();
                    const endDate = new Date();
                    
                    // Logic to determine date range based on filterType
                    switch (filterType) {
                        case 'today': startDate.setHours(0, 0, 0, 0); endDate.setHours(23, 59, 59, 999); break;
                        case 'yesterday': startDate.setDate(startDate.getDate() - 1); startDate.setHours(0, 0, 0, 0); endDate.setDate(endDate.getDate() - 1); endDate.setHours(23, 59, 59, 999); break;
                        case 'thisMonth': startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setMonth(endDate.getMonth() + 1); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                        case 'lastMonth': startDate.setMonth(startDate.getMonth() - 1); startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                        case 'custom': const [year, month] = customMonth.split('-').map(Number); if (year && month) { startDate.setFullYear(year, month - 1, 1); startDate.setHours(0, 0, 0, 0); endDate.setFullYear(year, month, 0); endDate.setHours(23, 59, 59, 999); } break;
                    }
                    
                    // --- Build Queries with Filters ---
                    // Start with base date-range queries.
                    let attendanceQuery = query(collection(db, 'attendance'), where('timestamp', '>=', startDate), where('timestamp', '<=', endDate));
                    let leaveQuery = query(collection(db, 'leaveRequests'), where('leaveDate', '<=', endDate.toISOString().slice(0, 10)));
                    let otQuery = query(collection(db, 'otRequests'), where('reqDate', '>=', startDate.toISOString().slice(0, 10)), where('reqDate', '<=', endDate.toISOString().slice(0, 10)));
                    
                    try {
                        const [attSnap, leaveSnap, otSnap] = await Promise.all([
                            getDocs(attendanceQuery),
                            getDocs(leaveQuery),
                            getDocs(otQuery)
                        ]);
                        
                        // FIX: Apply shop/employee filters on the client-side to prevent index errors
                        const attendanceData = attSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (rec.employeeName && rec.employeeName.toLowerCase().includes(searchTerm.toLowerCase()));
                                return shopMatch && empMatch;
                            });
                        setAdminAttendance(attendanceData);
                        
                        const leaveData = leaveSnap.docs.map(d => ({ id: d.id, ...d.data() }))
                            .filter(lr => {
                                const shopMatch = !selectedShop || lr.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (lr.staffName && lr.staffName.toLowerCase().includes(searchTerm.toLowerCase()));
                                const dateMatch = lr.returnDate >= startDate.toISOString().slice(0, 10);
                                return shopMatch && empMatch && dateMatch;
                            });

                        const otData = otSnap.docs.map(d => ({id: d.id, ...d.data()}))
                             .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (rec.staffName && rec.staffName.toLowerCase().includes(searchTerm.toLowerCase()));
                                return shopMatch && empMatch;
                            });
                        
                        setAdminReportData({
                            leaveRequests: leaveData,
                            otRequests: otData
                        });

                    } catch (error) {
                        console.error("Error fetching admin report data:", error);
                    } finally {
                        setLoadingAdminReport(false);
                    }
                };
                
                fetchAdminData();

            }, [userProfile, filterType, customMonth, selectedShop, searchTerm, db, setLoadingAdminReport, setAdminReportData]);

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    // For managers with multiple shops, default to showing all their shops.
                    // For single-shop users, their shop is pre-selected.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);
            
            // Admins see all shops, Managers see their assigned shops for filtering.
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return []; // Not used for other roles in the UI dropdown
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const attendanceReport = useMemo(() => {
                // --- START PERFORMANCE FIX ---
                // This entire block is refactored for efficiency.
                const startDate = new Date();
                const endDate = new Date();

                // 1. Determine Date Range from Filters
                switch (filterType) {
                    case 'today': startDate.setHours(0, 0, 0, 0); endDate.setHours(23, 59, 59, 999); break;
                    case 'yesterday': startDate.setDate(startDate.getDate() - 1); startDate.setHours(0, 0, 0, 0); endDate.setDate(endDate.getDate() - 1); endDate.setHours(23, 59, 59, 999); break;
                    case 'thisMonth': startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setMonth(endDate.getMonth() + 1); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                    case 'lastMonth': startDate.setMonth(startDate.getMonth() - 1); startDate.setDate(1); startDate.setHours(0, 0, 0, 0); endDate.setDate(0); endDate.setHours(23, 59, 59, 999); break;
                    case 'custom': const [year, month] = customMonth.split('-').map(Number); if (year && month) { startDate.setFullYear(year, month - 1, 1); startDate.setHours(0, 0, 0, 0); endDate.setFullYear(year, month, 0); endDate.setHours(23, 59, 59, 999); } break;
                }

                // 2. Get a list of employees to report on, based on user role and filters.
                const relevantEmployees = employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : (emp.shop ? [emp.shop] : []);
                    const userManagedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);

                    let roleMatch = false;
                    if (userProfile.role === 'Admin' || userProfile.role === 'CEO') roleMatch = true;
                    else if (userProfile.role === 'Shop Manager') roleMatch = employeeShops.some(s => userManagedShops.includes(s));
                    else roleMatch = emp.id === userProfile.id;

                    const shopMatch = !selectedShop || employeeShops.includes(selectedShop);
                    const shiftMatch = !selectedShift || emp.shift === selectedShift;
                    // MODIFIED: Use searchTerm for name matching and remove selectedEmployeeId
                    const searchMatch = !searchTerm || emp.name.toLowerCase().includes(searchTerm.toLowerCase());
                    return emp.status === 'Active' && roleMatch && shopMatch && searchMatch && shiftMatch && emp.role !== 'Admin' && emp.role !== 'CEO';
                });
                
                // --- START BUG FIX ---
                // Create a Set of relevant employee IDs for efficient lookup.
                const relevantEmployeeIds = new Set(relevantEmployees.map(e => e.id));

                // 3. Process ONLY the available attendance data.
                const reportMap = new Map();
                attendance.forEach(record => {
                    // Only process records for employees who match the current filters (including shift).
                    if (!relevantEmployeeIds.has(record.employeeId)) return;
                    
                    if (!record.timestamp) return;
                    const recordDate = record.timestamp.toDate();
                    if (!(recordDate >= startDate && recordDate <= endDate)) return;

                    const recordShop = shops.find(s => s.name === record.shop);
                    const { localDate: dateKey } = Utils.formatDateInTimezone(record.timestamp, recordShop?.timezone);
                    const reportKey = `${record.employeeId}_${dateKey}`;

                    if (!reportMap.has(reportKey)) {
                        reportMap.set(reportKey, {
                            date: dateKey,
                            employeeId: record.employeeId,
                            checkInRecords: [],
                            checkOutRecords: [],
                            docIds: []
                        });
                    }
                    
                    const entry = reportMap.get(reportKey);
                    // FIX: Store the full record object (date and shop) instead of just the date.
                    // This allows us to track where check-ins and check-outs happened.
                    const recordData = { date: record.timestamp.toDate(), shop: record.shop };
                    if (record.type === 'in') entry.checkInRecords.push(recordData);
                    if (record.type === 'out') entry.checkOutRecords.push(recordData);
                    entry.docIds.push(record.id);
                });
                // --- END BUG FIX ---

                // 4. Intelligently add absent days for past and present dates.
                const today = new Date();
                today.setHours(0,0,0,0);
                const currentDate = new Date(startDate);
                // FIX: Changed condition from `< today` to `<= today` to include the current day
                // when checking for absent employees. This ensures the "Today" filter shows everyone.
                while(currentDate <= endDate && currentDate <= today) {
                    const dateKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(currentDate.getDate()).padStart(2, '0')}`;
                    for (const employee of relevantEmployees) {
                         const reportKey = `${employee.id}_${dateKey}`;
                         if (!reportMap.has(reportKey)) {
                            // FIX: Always add an entry for an employee who has no attendance record on a past day.
                            // The finalization step (step 5) will correctly determine if they were on approved leave or were absent.
                            // The previous logic incorrectly filtered out employees on approved leave at this stage.
                            reportMap.set(reportKey, {
                                date: dateKey, employeeId: employee.id,
                                checkInRecords: [], checkOutRecords: [], docIds: []
                            });
                         }
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                // 5. Finalize calculations for each entry.
                const reportArray = Array.from(reportMap.values()).map(entry => {
                    const employee = employees.find(e => e.id === entry.employeeId);
                    if (!employee) return null; // Skip if employee not found

                    // FIX: Find the earliest check-in and latest check-out record objects
                    // to get both their time and their specific shop location.
                    const firstCheckInRecord = entry.checkInRecords.length > 0
                        ? entry.checkInRecords.reduce((earliest, current) => current.date < earliest.date ? current : earliest)
                        : null;
                    const lastCheckOutRecord = entry.checkOutRecords.length > 0
                        ? entry.checkOutRecords.reduce((latest, current) => current.date > latest.date ? current : latest)
                        : null;

                    const checkIn = firstCheckInRecord ? firstCheckInRecord.date : null;
                    const checkOut = lastCheckOutRecord ? lastCheckOutRecord.date : null;
                    
                    const shopDetails = shops.find(s => s.name === (firstCheckInRecord?.shop || (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop)));
                    const shopTimezone = shopDetails?.timezone;

                    let isLate = false;
                    if (checkIn && employee) {
                        const shiftDetails = (shifts || []).find(s => s.name === employee.shift && s.shopName === firstCheckInRecord.shop);
                        if (shiftDetails?.lateThreshold) {
                            const [lateHour, lateMinute] = shiftDetails.lateThreshold.split(':').map(Number);
                            const timeInZoneString = checkIn.toLocaleTimeString('en-GB', { timeZone: shopTimezone, hour: '2-digit', minute: '2-digit' });
                            const [checkInHour, checkInMinute] = timeInZoneString.split(':').map(Number);
                            if (checkInHour > lateHour || (checkInHour === lateHour && checkInMinute > lateMinute)) {
                                isLate = true;
                            }
                        }
                    }

                    const approvedLeave = leaveRequests.find(lr => lr.staffId === employee.id && lr.status === 'Approved' && entry.date >= lr.leaveDate && entry.date < lr.returnDate);
                    let isOnLeave; // Start undefined

                    if (approvedLeave) {
                        // Case 1: Employee is on approved leave.
                        isOnLeave = approvedLeave.leaveSession === 'Full Day' ? 'Y-Full Day' : `Y-${approvedLeave.leaveSession}`;
                    } else if (checkIn || checkOut) {
                        // Case 2: Employee has check-in/out records, so they are not on leave.
                        isOnLeave = 'N';
                    } else {
                        // Case 3: No approved leave and no attendance.
                        // Check if we are still loading data before declaring them absent.
                        if (isReportLoading) {
                            isOnLeave = '-'; // Neutral state during load
                        } else {
                            isOnLeave = 'Absent'; // Confirmed absence after load
                        }
                    }

                    const isOnOT = otRequests.some(ot => ot.staffId === employee.id && ot.status === 'Approved' && ot.reqDate === entry.date);
                    const otStatus = isOnOT ? 'Y' : 'N';
                    
                    const { localTime: checkInTimeStr } = checkIn ? Utils.formatDateInTimezone({ toDate: () => checkIn }, shopTimezone) : { localTime: '' };
                    const { localTime: checkOutTimeStr } = checkOut ? Utils.formatDateInTimezone({ toDate: () => checkOut }, shopTimezone) : { localTime: '' };
                    
                    // FIX: Create a more informative shop display for multi-shop activity.
                    let shopDisplay = Array.isArray(employee.shop) ? employee.shop.join(', ') : employee.shop;
                    if (firstCheckInRecord && lastCheckOutRecord) {
                        if (firstCheckInRecord.shop === lastCheckOutRecord.shop) {
                            shopDisplay = firstCheckInRecord.shop;
                        } else {
                            shopDisplay = `${firstCheckInRecord.shop} (In) → ${lastCheckOutRecord.shop} (Out)`;
                        }
                    } else if (firstCheckInRecord) {
                        shopDisplay = firstCheckInRecord.shop;
                    } else if (lastCheckOutRecord) {
                        shopDisplay = lastCheckOutRecord.shop; // For a checkout-only record
                    }

                    return {
                        date: entry.date,
                        employeeId: employee.id,
                        employeeName: employee.name,
                        shop: shopDisplay,
                        shift: employee.shift,
                        checkIn: checkInTimeStr,
                        checkOut: checkOutTimeStr,
                        isLate, isOnLeave, otStatus, docIds: entry.docIds
                    };
                }).filter(Boolean);
                
                    // 6. Sort and return.
                return reportArray.sort((a, b) => (a.shop || '').localeCompare(b.shop || '') || b.date.localeCompare(a.date) || a.employeeName.localeCompare(b.employeeName));
                // --- END PERFORMANCE FIX ---
            }, [attendance, selectedShop, filterType, customMonth, searchTerm, employees, leaveRequests, otRequests, selectedShift, shops, shifts, userProfile, isReportLoading]); // MODIFIED: selectedEmployeeId -> searchTerm

            const handleDelete = async () => {
                if (!recordToDelete?.docIds) return;
                const { doc, writeBatch } = window.firebaseSDK;
                const batch = writeBatch(db);
                // Delete all attendance docs for that employee on that day
                recordToDelete.docIds.forEach(id => batch.delete(doc(db, 'attendance', id)));
                try { await batch.commit(); } catch (error) { console.error("Error deleting attendance records: ", error); } 
                finally { setRecordToDelete(null); }
            };

            const handleOpenCorrectionModal = useCallback((record) => {
                setRecordToCorrect(record);
                setCorrectionModalOpen(true);
            }, []);

            const handleCloseCorrectionModal = useCallback(() => {
                setRecordToCorrect(null);
                setCorrectionModalOpen(false);
            }, []);
            
            const handleSaveCheckOut = useCallback(async (record, time) => {
                const { addDoc, collection } = window.firebaseSDK;
                const [hour, minute] = time.split(':');
                
                // Important: Use the date from the record and combine it with the new time.
                // The record.date is a string 'YYYY-MM-DD'.
                const checkOutDateTime = new Date(`${record.date}T${time}:00`);

                try {
                    const newDocRef = await addDoc(collection(db, 'attendance'), {
                        employeeId: record.employeeId,
                        employeeName: record.employeeName,
                        shop: record.shop,
                        timestamp: checkOutDateTime, // Use the combined date-time object
                        type: 'out',
                        location: { manualEntry: true, note: 'Added by Admin' }
                    });

                    // --- START FIX: Update local state to reflect the new check-out record ---
                    // This ensures the UI updates instantly without needing a full refetch.
                    if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') {
                        const newRecordForState = {
                            id: newDocRef.id,
                            employeeId: record.employeeId,
                            employeeName: record.employeeName,
                            shop: record.shop,
                            timestamp: {
                                toDate: () => checkOutDateTime
                            },
                            type: 'out',
                            location: { manualEntry: true, note: 'Added by Admin' }
                        };
                        // Add the new record to the locally managed attendance state for Admins.
                        setAdminAttendance(prev => [...prev, newRecordForState]);
                    }
                    // For other roles (Managers), the real-time `useCollection` hook will automatically
                    // detect the new record and update the UI, so no manual state update is needed here.
                    // --- END FIX ---
                    
                    handleCloseCorrectionModal();
                } catch (error) {
                    console.error("Error saving manual check-out:", error);
                    alert("Failed to save the manual check-out time.");
                }
            }, [db, handleCloseCorrectionModal, userProfile]);

            const handleExportExcel = useCallback(() => {
                const dataToExport = attendanceReport.map(report => ({
                    'Date': report.date,
                    'Shop Name': report.shop,
                    'Staff Name': report.employeeName,
                    'Shift': report.shift,
                    'Check In': report.checkIn,
                    'Check Out': report.checkOut,
                    'On Leave': report.isOnLeave,
                    'OT Status': report.otStatus,
                    'Late Check-In': report.isLate ? 'Yes' : 'No'
                }));

                const getReportFilename = () => {
                    const todayStr = new Date().toISOString().slice(0, 10);
                    switch (filterType) {
                        case 'today': return `Daily_Attendance_Report_Today_${todayStr}.xlsx`;
                        case 'yesterday': 
                            const yesterday = new Date();
                            yesterday.setDate(yesterday.getDate() - 1);
                            return `Daily_Attendance_Report_Yesterday_${yesterday.toISOString().slice(0, 10)}.xlsx`;
                        case 'thisMonth': return `Daily_Attendance_Report_ThisMonth_${new Date().toISOString().slice(0, 7)}.xlsx`;
                        case 'lastMonth': 
                            const lastMonth = new Date();
                            lastMonth.setMonth(lastMonth.getMonth() - 1);
                            return `Daily_Attendance_Report_LastMonth_${lastMonth.toISOString().slice(0, 7)}.xlsx`;
                        case 'custom': return `Daily_Attendance_Report_${customMonth}.xlsx`;
                        default: return 'Daily_Attendance_Report.xlsx';
                    }
                };

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Daily Attendance");

                worksheet["!cols"] = [ { wch: 12 }, { wch: 15 }, { wch: 25 }, { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 15 } ];
                
                XLSX.writeFile(workbook, getReportFilename());
            }, [attendanceReport, filterType, customMonth]);

            return (
                <Card>
                    <DailyReportFilters
                        userProfile={userProfile}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        // MODIFIED: Pass searchTerm and setSearchTerm
                        searchTerm={searchTerm}
                        setSearchTerm={setSearchTerm}
                        availableShops={availableShops}
                        // employeesInShop={employeesInShop} // MODIFIED: Removed unused prop
                        filterType={filterType}
                        setFilterType={setFilterType}
                        customMonth={customMonth}
                        setCustomMonth={setCustomMonth}
                        selectedShift={selectedShift}
                        setSelectedShift={setSelectedShift}
                        uniqueShiftNames={uniqueShiftNames}
                        onExportExcel={handleExportExcel}
                    />
                    <DailyReportTable
                        attendanceReport={attendanceReport}
                        userProfile={userProfile}
                        onAddCheckOut={handleOpenCorrectionModal}
                        onDeleteRecord={setRecordToDelete}
                    />
                    <ConfirmationModal isOpen={!!recordToDelete} onClose={() => setRecordToDelete(null)} onConfirm={handleDelete} title="Delete Attendance Record" message={`Are you sure you want to delete all attendance records for ${recordToDelete?.employeeName} on ${recordToDelete?.date}? This action cannot be undone.`} />
                    <ManualCheckOutModal isOpen={isCorrectionModalOpen} onClose={handleCloseCorrectionModal} onSave={handleSaveCheckOut} record={recordToCorrect} />
                </Card>
            );
        };
        
        const WorkDayReportTab = ({ userProfile, leaveRequests, otRequests, setAdminReportData, setLoadingAdminReport, isAdminLoading }) => {
            const { db } = useFirebase();
            const { where, query, collection, getDocs } = window.firebaseSDK;

            // Filter States
            const [selectedShop, setSelectedShop] = useState('');
            const [filterType, setFilterType] = useState('thisMonth');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            // MODIFIED: Renamed state from selectedEmployeeId to searchTerm
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedShift, setSelectedShift] = useState(''); // NEW: State for shift filter

            // Data States
            const { data: shops } = useCollection('shops');
            const { data: employees } = useCollection('employees');
            const { data: shifts } = useCollection('shifts'); // NEW: Get shifts data

            // NEW: Get unique shift names for the filter dropdown
            const uniqueShiftNames = useMemo(() => {
                if (!shifts) return [];
                const shiftNames = shifts.map(s => s.name);
                return [...new Set(shiftNames)].sort();
            }, [shifts]);
            
            // PHASE 3: Data states for Admin's one-time fetches
            const [adminAttendance, setAdminAttendance] = useState([]);
            const [adminEmployeeStates, setAdminEmployeeStates] = useState([]);

            // PHASE 2 & 3: Combined logic for fetching data.
            const isRealTime = userProfile?.role !== 'Admin';
            
            const realTimeQueryConstraints = useMemo(() => {
                if (!isRealTime) return { attendance: [], employeeStates: [] };
                const { role, id, shop } = userProfile || {};
                
                let attendanceCons = [], statesCons = [];

                if (role === 'Staff' && id) {
                    attendanceCons = [where("employeeId", "==", id)];
                    statesCons = [where("staffId", "==", id)];
                } else if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        attendanceCons = [where("shop", "in", managedShops)];
                        statesCons = [where("shop", "in", managedShops)];
                    } else {
                        attendanceCons = [where("employeeId", "==", "null")];
                        statesCons = [where("staffId", "==", "null")];
                    }
                }
                return { attendance: attendanceCons, employeeStates: statesCons };
            }, [userProfile, isRealTime]);

            const { data: realTimeAttendance } = useCollection('attendance', realTimeQueryConstraints.attendance);
            const { data: realTimeEmployeeStates } = useCollection('employeeStates', realTimeQueryConstraints.employeeStates);
            
            const attendance = isRealTime ? realTimeAttendance : adminAttendance;
            const employeeStates = isRealTime ? realTimeEmployeeStates : adminEmployeeStates;

             // --- PHASE 3: ON-DEMAND DATA FETCHING FOR ADMIN ---
            useEffect(() => {
                if (userProfile?.role !== 'Admin' && userProfile?.role !== 'CEO') return;

                const fetchAdminData = async () => {
                    setLoadingAdminReport(true);
                    
                    let targetMonth;
                    const now = new Date();
                    switch (filterType) {
                        case 'lastMonth': const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1); targetMonth = `${lastMonthDate.getFullYear()}-${String(lastMonthDate.getMonth() + 1).padStart(2, '0')}`; break;
                        case 'custom': targetMonth = selectedMonth; break;
                        default: targetMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`; break;
                    }

                    const startDate = `${targetMonth}-01`;
                    const endDate = `${targetMonth}-31`; // Firestore handles date strings correctly

                    // --- Build Queries with Filters ---
                    // Start with base date-range queries.
                    let attendanceQuery = query(collection(db, 'attendance'), where('timestamp', '>=', new Date(startDate)), where('timestamp', '<=', new Date(endDate + "T23:59:59")));
                    let statesQuery = query(collection(db, 'employeeStates'), where('date', '>=', startDate), where('date', '<=', endDate));
                    let leaveQuery = query(collection(db, 'leaveRequests'), where('leaveDate', '<=', endDate));
                    let otQuery = query(collection(db, 'otRequests'), where('reqDate', '>=', startDate), where('reqDate', '<=', endDate));
                    
                    try {
                        const [attSnap, statesSnap, leaveSnap, otSnap] = await Promise.all([ getDocs(attendanceQuery), getDocs(statesQuery), getDocs(leaveQuery), getDocs(otQuery) ]);
                        
                        // FIX: Apply shop/employee filters on the client-side to prevent index errors
                        const attendanceData = attSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (rec.employeeName && rec.employeeName.toLowerCase().includes(searchTerm.toLowerCase()));
                                return shopMatch && empMatch;
                            });
                        setAdminAttendance(attendanceData);

                        const statesData = statesSnap.docs.map(d => ({id: d.id, ...d.data()}))
                            .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (rec.staffName && rec.staffName.toLowerCase().includes(searchTerm.toLowerCase()));
                                return shopMatch && empMatch;
                            });
                        setAdminEmployeeStates(statesData);
                        
                        const leaveData = leaveSnap.docs.map(d => ({ id: d.id, ...d.data() }))
                            .filter(lr => {
                                const shopMatch = !selectedShop || lr.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (lr.staffName && lr.staffName.toLowerCase().includes(searchTerm.toLowerCase()));
                                const dateMatch = lr.returnDate >= startDate;
                                return shopMatch && empMatch && dateMatch;
                            });
                        
                        const otData = otSnap.docs.map(d => ({id: d.id, ...d.data()}))
                             .filter(rec => {
                                const shopMatch = !selectedShop || rec.shop === selectedShop;
                                // MODIFIED: Changed from selectedEmployeeId to searchTerm for name matching
                                const empMatch = !searchTerm || (rec.staffName && rec.staffName.toLowerCase().includes(searchTerm.toLowerCase()));
                                return shopMatch && empMatch;
                            });

                        setAdminReportData({
                            leaveRequests: leaveData,
                            otRequests: otData
                        });

                    } catch (error) {
                        console.error("Error fetching admin work day report data:", error);
                    } finally {
                        setLoadingAdminReport(false);
                    }
                };
                
                fetchAdminData();

            }, [userProfile, filterType, selectedMonth, selectedShop, searchTerm, db, setLoadingAdminReport, setAdminReportData]);

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                     // For managers with multiple shops, default to showing all their shops.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            // Admins see all shops, Managers see their assigned shops for filtering.
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return []; // Not used for other roles in the UI dropdown
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const workDayReport = useMemo(() => {
                let targetMonth;
                const now = new Date();
                switch (filterType) {
                    case 'lastMonth':
                        const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                        const year_lm = lastMonthDate.getFullYear();
                        const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                        targetMonth = `${year_lm}-${month_lm}`;
                        break;
                    case 'custom':
                        targetMonth = selectedMonth;
                        break;
                    case 'thisMonth':
                    default:
                        const year_tm = now.getFullYear();
                        const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                        targetMonth = `${year_tm}-${month_tm}`;
                        break;
                }

                // 1. Determine which employees to generate a report for based on filters
                const employeesToReportOn = employees.filter(emp => {
                    if (emp.status !== 'Active') return false;

                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : (emp.shop ? [emp.shop] : []);
                    const userManagedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);

                    let roleMatch = false;
                    if (userProfile.role === 'Admin' || userProfile.role === 'CEO') roleMatch = true;
                    else if (userProfile.role === 'Shop Manager') roleMatch = employeeShops.some(s => userManagedShops.includes(s));
                    else roleMatch = emp.id === userProfile.id; // Staff see only themselves
                    
                    const shopFilterMatch = !selectedShop || employeeShops.includes(selectedShop);
                    // MODIFIED: Use searchTerm for name matching
                    const employeeFilterMatch = !searchTerm || emp.name.toLowerCase().includes(searchTerm.toLowerCase());
                    const shiftFilterMatch = !selectedShift || emp.shift === selectedShift; // NEW: Add shift filter condition

                    return roleMatch && shopFilterMatch && employeeFilterMatch && shiftFilterMatch && emp.role !== 'Admin' && emp.role !== 'CEO'; // NEW: Apply shift filter
                });
                
                // 2. Generate a report row for each of those employees
                const report = employeesToReportOn.map(employee => {
                    // --- NEW (STEP 3): Use primaryShop for timezone. Logic must match Payroll Calculator. ---
                    // 1. Determine the correct "home shop" name. Prioritize the new 'primaryShop' field.
                    const employeeShopName = employee.primaryShop 
                        ? employee.primaryShop // Use the new field if it exists
                        : (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop); // Fallback to old logic

                    // 2. Find the shop details from the 'shops' data
                    const employeeShop = shops.find(s => s.name === employeeShopName);
                    
                    // 3. Get the timezone. This will now be the timezone of the primary shop.
                    const employeeShopTimezone = employeeShop?.timezone; // e.g., 'Asia/Phnom_Penh'

                    // FIX: Replaced the old timezone-unaware filter with the correct timezone-aware filter
                    // from the Payroll Calculator to ensure consistency.
                    const monthAttendance = (attendance || []).filter(r => {
                        if (r.employeeId !== employee.id) return false;
                        if (!r.timestamp || !r.timestamp.toDate) return false;
                        // Get the record's local date (e.g., '2025-11-12') using the employee's primary shop timezone
                        const { localDate } = Utils.formatDateInTimezone(r.timestamp, employeeShopTimezone);
                        // Check if that local date's month (e.g., '2025-11') matches the targetMonth
                        return localDate.startsWith(targetMonth);
                    });
                    const monthLeave = leaveRequests.filter(r => r.staffId === employee.id && r.status === 'Approved' && r.leaveDate.startsWith(targetMonth));
                    const monthOT = otRequests.filter(r => r.staffId === employee.id && r.status === 'Approved' && r.reqDate.startsWith(targetMonth));
                    const monthStates = employeeStates.filter(r => r.staffId === employee.id && r.date.startsWith(targetMonth));

                    const totalLeave = monthLeave.reduce((sum, r) => sum + (parseFloat(r.numberOfDays) || 0), 0);
                    const totalOT = monthOT.reduce((sum, r) => sum + (parseFloat(r.numberOfOTDays) || 0), 0);
                    // FIX: Use the more specific 'CheckIn Late @' to be consistent with the payroll calculation.
                    const totalLate = monthStates.filter(es => es.statusState === 'Deduction' && es.note?.includes('CheckIn Late @')).length;
                    
                    const dailyRecords = {};
                    monthAttendance.forEach(rec => {
                        const { localDate: dayKey } = Utils.formatDateInTimezone(rec.timestamp, employeeShopTimezone);
                        if (!dailyRecords[dayKey]) dailyRecords[dayKey] = [];
                        dailyRecords[dayKey].push({ date: rec.timestamp.toDate(), type: rec.type });
                    });
                    
                    let workDays = 0;
                    let noCheckOutCount = 0;
                    const { localDate: todayStr } = Utils.formatDateInTimezone({ toDate: () => new Date() }, employeeShopTimezone);

                    Object.entries(dailyRecords).forEach(([dayKey, dayRecs]) => {
                        const ins = dayRecs.filter(r => r.type === 'in').sort((a,b) => a.date - b.date);
                        const outs = dayRecs.filter(r => r.type === 'out').sort((a,b) => b.date - a.date);
                        if (ins.length > 0 && outs.length > 0) {
                            const diffHours = (outs[0].date.getTime() - ins[0].date.getTime()) / 3600000;
                            if (diffHours >= 7) workDays += 1;
                            else if (diffHours >= 4) workDays += 0.5;
                        } else if (ins.length > 0 && dayKey < todayStr) {
                            noCheckOutCount += 1;
                        }
                    });

                    const [year, month] = targetMonth.split('-').map(Number);
                    const daysInMonth = new Date(year, month, 0).getDate();
                    const attendedDays = new Set(Object.keys(dailyRecords));
                    let noAbsentCount = 0;

                    for (let day = 1; day <= daysInMonth; day++) {
                        const dayKey = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        if (dayKey >= todayStr) break;
                        if (!attendedDays.has(dayKey)) {
                            const isOnLeave = monthLeave.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                            if (!isOnLeave) noAbsentCount++;
                        }
                    }

                    // BUG FIX: Re-add the "Given Off Day" calculation
                    const givenOffDays = Math.floor(workDays / 6.5);
                    // BUG FIX: Correct the "Total-Day" calculation to include given off days
                    // REMOVED: const totalDay = workDays + givenOffDays + totalLeave;
                    const [reportYear, reportMonth] = targetMonth.split('-');

                    // NEW: Calculate Salary Day
                    const salaryDay = workDays + givenOffDays + totalOT;

                    return { 
                        dueTime: `${reportMonth}-${reportYear.substring(2)}`, 
                        shopName: employeeShopName, 
                        staffName: employee.name, 
                        workDays, 
                        givenOffDays, // Re-add to the returned object
                        totalOT, 
                        totalLeave, 
                        totalLate, 
                        noCheckOutCount, 
                        noAbsentCount, 
                        salaryDay, // Add new property here
                        // REMOVED: totalDay
                    };
                });
                
                return report.sort((a, b) => (a.shopName || '').localeCompare(b.shopName || '') || (a.staffName || '').localeCompare(b.staffName || ''));

            }, [attendance, leaveRequests, otRequests, employeeStates, employees, shops, filterType, selectedMonth, selectedShop, searchTerm, userProfile, selectedShift]); // MODIFIED: selectedEmployeeId -> searchTerm

            const handleExportExcel = useCallback(() => {
                const dataToExport = workDayReport.map(rec => ({
                    'Due Time (MM-YY)': rec.dueTime,
                    'Shop Name': rec.shopName,
                    'Staff Name': rec.staffName,
                    'No. Work Day': rec.workDays,
                    'Given Off Day': rec.givenOffDays, // BUG FIX: Re-add to Excel export
                    'Total OT': rec.totalOT,
                    'Total Leave No': rec.totalLeave,
                    'Total LATE': rec.totalLate,
                    'No-CheckOut': rec.noCheckOutCount,
                    'No-Absent': rec.noAbsentCount,
                    'Salary Day': rec.salaryDay, // NEW: Add Salary Day
                    // REMOVED: 'Total-Day': rec.totalDay,
                }));

                const getReportFilename = () => {
                    const now = new Date();
                    switch (filterType) {
                        case 'thisMonth':
                            const year_tm = now.getFullYear();
                            const month_tm = String(now.getMonth() + 1).padStart(2, '0');
                            return `Monthly_Work_Day_Report_${year_tm}-${month_tm}.xlsx`;
                        case 'lastMonth': 
                            const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                            const year_lm = lastMonthDate.getFullYear();
                            const month_lm = String(lastMonthDate.getMonth() + 1).padStart(2, '0');
                            return `Monthly_Work_Day_Report_${year_lm}-${month_lm}.xlsx`;
                        case 'custom': return `Monthly_Work_Day_Report_${selectedMonth}.xlsx`;
                        default: return 'Monthly_Work_Day_Report.xlsx';
                    }
                };

                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Monthly Work Day Report");
                
                // Add column width for the new "Salary Day" column
                worksheet["!cols"] = [ { wch: 18 }, { wch: 20 }, { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 } ]; // Adjust column widths (removed one)
                
                XLSX.writeFile(workbook, getReportFilename());
            }, [workDayReport, filterType, selectedMonth]);

            return (
                <Card>
                    <WorkDayReportFilters
                        userProfile={userProfile}
                        selectedShop={selectedShop}
                        setSelectedShop={setSelectedShop}
                        // MODIFIED: Pass searchTerm and setSearchTerm
                        searchTerm={searchTerm}
                        setSearchTerm={setSearchTerm}
                        availableShops={availableShops}
                        // employeesInShop={employeesInShop} // MODIFIED: Removed unused prop
                        filterType={filterType}
                        setFilterType={setFilterType}
                        selectedMonth={selectedMonth}
                        setSelectedMonth={setSelectedMonth}
                        selectedShift={selectedShift}
                        setSelectedShift={setSelectedShift}
                        uniqueShiftNames={uniqueShiftNames}
                        onExportExcel={handleExportExcel}
                    />
                    <WorkDayReportTable workDayReport={workDayReport} />
                </Card>
            );
        };
        // --- END ATTENDANCE REPORT PAGE ---

        // --- START LOAN MANAGER PAGE ---
        const LoanManagerPage = ({ userProfile }) => {
            // REMOVED: Tab state and TabbedPage wrapper
            return (
                // NEW: Added a div wrapper to stack the two components
                <div className="space-y-6">
                    <LoanManagementTab userProfile={userProfile} />
                    <LoanHistoryTab userProfile={userProfile} />
                </div>
            );
        };

        const LoanManagementTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingLoan, setEditingLoan] = useState(null);
            const [loanToDelete, setLoanToDelete] = useState(null);
            const { where } = window.firebaseSDK;
            
            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) {
                        return [where("shop", "in", shops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops, no data
                }
                return [where("shop", "==", userProfile.shop || null)];
            }, [userProfile]);

            const { data: loans } = useCollection('staffLoans', queryConstraints);
            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();
            const [selectedShop, setSelectedShop] = useState(''); // For the modal's employee list
            const [formData, setFormData] = useState({});
            const [filterShop, setFilterShop] = useState(''); // For filtering the main list
            const [searchTerm, setSearchTerm] = useState(''); // State for the search input

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setFilterShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShopsForFilter = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const filteredLoans = useMemo(() => {
                return loans.filter(loan =>
                    (!filterShop || loan.shop === filterShop) &&
                    (loan.staffName.toLowerCase().includes(searchTerm.toLowerCase()))
                );
            }, [loans, filterShop, searchTerm]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);
            
            const availableShopsForModal = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const canSelectShopInModal = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager';

            const handleOpenModal = (loan = null) => {
                setEditingLoan(loan);
                let initialShop = '';
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
                    if (managedShops.length === 1) initialShop = managedShops[0];
                } else if (userProfile.role !== 'Admin') {
                    initialShop = userProfile.shop || '';
                }

                const initialData = loan ? { ...loan } : { loanDate: new Date().toISOString().substring(0, 10), effectiveDate: new Date().toISOString().substring(0, 10), shop: initialShop, staffId: '', loanAmount: '', agreedMonthlyDeduction: '', reason: '', totalPaid: 0, status: 'Active' };
                setFormData(initialData);
                setSelectedShop(initialData.shop || '');
                setModalOpen(true);
            };

            const handleCloseModal = () => { setModalOpen(false); setEditingLoan(null); };
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
                if (name === 'shop') { setSelectedShop(value); setFormData(prev => ({...prev, staffId: ''})); }
            };
            const handleSave = async () => {
                const { addDoc, updateDoc, doc, collection } = window.firebaseSDK;
                const dataToSave = { ...formData, loanAmount: parseFloat(formData.loanAmount) || 0, agreedMonthlyDeduction: parseFloat(formData.agreedMonthlyDeduction) || 0, staffName: employees.find(e => e.id === formData.staffId)?.name || '' };
                try {
                    if (editingLoan) { await updateDoc(doc(db, 'staffLoans', editingLoan.id), dataToSave); } 
                    else { await addDoc(collection(db, 'staffLoans'), dataToSave); }
                    handleCloseModal();
                } catch (error) { console.error("Error saving loan:", error); }
            };
            const confirmDelete = async () => {
                if (!loanToDelete) return;
                
                // FIX (Bug #3): Use a batched write to delete the loan and all its associated payments.
                const { writeBatch, collection, query, where, getDocs, doc } = window.firebaseSDK;
                const batch = writeBatch(db);

                try {
                    // 1. Find all payment records associated with this loan.
                    const paymentsQuery = query(collection(db, 'loanPayments'), where("loanId", "==", loanToDelete.id));
                    const paymentsSnapshot = await getDocs(paymentsQuery);

                    // 2. Add each payment record to the delete batch.
                    paymentsSnapshot.forEach((paymentDoc) => {
                        batch.delete(paymentDoc.ref);
                    });

                    // 3. Add the main loan record to the delete batch.
                    const loanRef = doc(db, 'staffLoans', loanToDelete.id);
                    batch.delete(loanRef);

                    // 4. Commit the batch to delete everything atomically.
                    await batch.commit();
                    
                } catch (error) {
                    console.error("Error deleting loan and its payments:", error);
                    // Provide feedback to the user in case of failure.
                    alert("Failed to delete the loan and its history. Please try again.");
                } finally {
                    setLoanToDelete(null);
                }
            };
            
            return (
                 <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Loan Management</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                            <input
                                type="text"
                                placeholder="Search by staff name..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="input w-full sm:w-auto"
                            />
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={filterShop} onChange={e => setFilterShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add New Loan</Button>
                        </div>
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Loan Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Effective Date</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Loan Amount</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Agreed Amount</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Paid</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Balance</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{filteredLoans.map(loan => { const balance = loan.loanAmount - loan.totalPaid; return (<tr key={loan.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{loan.staffName}</td><td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(loan.loanDate)}</td><td className="px-4 py-4 text-sm text-slate-300">{Utils.formatISOToDisplay(loan.effectiveDate)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.loanAmount)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.agreedMonthlyDeduction)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(loan.totalPaid)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(balance)}</td><td className="px-4 py-4 text-center text-sm"><span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${balance <= 0 ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}`}>{balance <= 0 ? 'Paid Off' : 'Active'}</span></td><td className="px-4 py-4 text-center whitespace-nowrap"><div className="flex items-center justify-center gap-4"><Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(loan)} title="Edit" /><Button variant="icon-delete" icon="fa-trash" onClick={() => setLoanToDelete(loan)} title="Delete" /></div></td></tr>); })}</tbody></table></div>
                    <Modal isOpen={isModalOpen} onClose={handleCloseModal}><ModalHeader title={editingLoan ? "Edit Loan" : "Add New Loan"} onClose={handleCloseModal} /><ModalBody><div className="space-y-4"><div><label className="text-sm">Shop</label><select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={!canSelectShopInModal}><option value="">Select Shop</option>{availableShopsForModal.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}</select></div><div><label className="text-sm">Staff</label><select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" disabled={!selectedShop}><option value="">Select Staff</option>{employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}</select></div><div><label className="text-sm">Loan Date</label><input type="date" name="loanDate" value={formData.loanDate || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Effective Date</label><input type="date" name="effectiveDate" value={formData.effectiveDate || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Loan Amount</label><input type="number" name="loanAmount" value={formData.loanAmount || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Agreed Monthly Deduction</label><input type="number" name="agreedMonthlyDeduction" value={formData.agreedMonthlyDeduction || ''} onChange={handleChange} className="input"/></div><div><label className="text-sm">Reason</label><textarea name="reason" value={formData.reason || ''} onChange={handleChange} className="input" rows="3"></textarea></div></div></ModalBody><ModalFooter><Button variant="secondary" onClick={handleCloseModal}>Cancel</Button><Button variant="primary" onClick={handleSave} className="px-6">Save Loan</Button></ModalFooter></Modal>
                    <ConfirmationModal isOpen={!!loanToDelete} onClose={() => setLoanToDelete(null)} onConfirm={confirmDelete} title="Delete Loan" message="Are you sure you want to delete this loan record?" />
                </Card>
            );
        };
        
        const LoanHistoryTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const { where } = window.firebaseSDK;
            const [selectedShop, setSelectedShop] = useState('');
            // REFACTORED: Get global data from App Data Context.
            const { shops } = useAppData();

            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') {
                    return selectedShop ? [where("shop", "==", selectedShop)] : [];
                }
                if (userProfile.role === 'Shop Manager') {
                    const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (managedShops.length === 0) return [where("shop", "==", "null")];
                    if (selectedShop) {
                        return [where("shop", "==", selectedShop)];
                    }
                    return [where("shop", "in", managedShops)];
                }
                return [where("shop", "==", userProfile.shop || null)];
            }, [userProfile, selectedShop]);
            
            const { data: loanPayments } = useCollection('loanPayments', queryConstraints);
            const { data: staffLoans } = useCollection('staffLoans');
            const [paymentToDelete, setPaymentToDelete] = useState(null);

            const confirmDelete = async () => {
                if (!paymentToDelete) return;
                const { doc, updateDoc, deleteDoc } = window.firebaseSDK;
                try {
                    // Revert the loan's totalPaid amount
                    const loan = staffLoans.find(l => l.id === paymentToDelete.loanId);
                    if (loan) {
                        const newTotalPaid = (loan.totalPaid || 0) - paymentToDelete.amountPaid;
                        const newStatus = newTotalPaid >= loan.loanAmount ? 'Paid Off' : 'Active';
                        await updateDoc(doc(db, 'staffLoans', loan.id), { totalPaid: newTotalPaid, status: newStatus });
                    }
                    await deleteDoc(doc(db, 'loanPayments', paymentToDelete.id));
                } catch (error) { console.error("Error deleting loan payment:", error); alert("Failed to delete loan payment."); } 
                finally { setPaymentToDelete(null); }
            };
            
            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            return (
                 <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Loan Payment History</h3>
                        {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        )}
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Payment Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff Name</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount Paid</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Remaining Balance</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Note</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{loanPayments.map(payment => (<tr key={payment.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{payment.paymentDate}</td><td className="px-4 py-4 text-sm text-slate-300">{payment.staffName}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(payment.amountPaid)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(payment.remainingBalance)}</td><td className="px-4 py-4 text-sm text-slate-300">{payment.note}</td><td className="px-4 py-4 text-center whitespace-nowrap"><Button variant="icon-delete" icon="fa-trash" onClick={() => setPaymentToDelete(payment)} title="Delete" /></td></tr>))}</tbody></table></div>
                    <ConfirmationModal isOpen={!!paymentToDelete} onClose={() => setPaymentToDelete(null)} onConfirm={confirmDelete} title="Delete Loan Payment" message="Are you sure you want to delete this payment record? This will also update the loan's total paid amount." />
                </Card>
            );
        };
        // --- END LOAN MANAGER PAGE ---

        // NEW: HR Banking Page (Tab Container)
        const HRBankingPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('loanManagement');
            
            // MODIFIED: Define tabs for the HR Banking section
            const bankingTabs = {
                loanManagement: 'Loan Management',
                savingProgram: 'Saving Program', // NEW: Added Saving Program tab
            };

            return (
                <TabbedPage tabs={bankingTabs} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="loanManagement">
                        <LoanManagerPage userProfile={userProfile} />
                    </div>
                    {/* NEW: Added content for the Saving Program tab */}
                    <div id="savingProgram">
                        <SavingsProgramPage userProfile={userProfile} />
                    </div>
                </TabbedPage>
            );
        };

        // --- START PAYROLL PAGE ---
        const PayrollPage = ({ userProfile }) => {
            const [activeTab, setActiveTab] = useState('calculator');
            const [editingRecord, setEditingRecord] = useState(null);
            
            // NEW: Get employee data from the app context.
            const { employees } = useAppData();
            
            // Function to switch to calculator tab and load record for editing
            const handleEdit = (record) => { 
                setEditingRecord(record); 
                setActiveTab('calculator'); 
            };

            // Function to handle successful save, switch to history tab
            const handleSaveSuccess = () => { 
                setEditingRecord(null); 
                setActiveTab('history'); 
            };

            return (
                <TabbedPage tabs={{ calculator: 'Payroll Calculator', history: 'Payroll History' }} activeTab={activeTab} setActiveTab={setActiveTab}>
                   <div id="calculator"><PayrollCalculatorTab userProfile={userProfile} editingRecord={editingRecord} onSaveSuccess={handleSaveSuccess} /></div>
                    {/* MODIFIED (STEP 6.D): Removed the 'employees' prop */}
                    <div id="history"><PayrollHistoryTab onEdit={handleEdit} userProfile={userProfile} /></div>
                </TabbedPage>
            );
        };

        // A dedicated component for rendering the payslip. It only displays data it receives.
        const PayslipPreview = memo(({ selectedEmployee, selectedMonth, manualInputs, calculations, isRecalculated, originalRecord }) => {
            // NEW (Step 4): Helper function to add visual indicators for changed data.
            const getChangeIndicatorClass = (newValue, oldValue) => {
                if (!isRecalculated || oldValue === undefined || newValue === oldValue) return ''; // No change
                if (typeof newValue === 'number' && typeof oldValue === 'number') {
                    if (newValue > oldValue) return 'text-green-600 font-bold'; // Increase
                    if (newValue < oldValue) return 'text-red-600 font-bold';   // Decrease
                }
                return 'text-yellow-600 font-bold'; // Non-numeric or other changes
            };

            const oldCalcs = originalRecord?.calculations || {};
            const oldInputs = originalRecord?.manualInputs || {};

            return (
                <div id="payslip-preview" className="bg-white text-slate-800 p-6 rounded-lg shadow-2xl font-sans">
                    <div className="text-center mb-6">
                        <h2 className="text-2xl font-bold">PAYSLIP</h2>
                        <p className="text-slate-500">For the month of {selectedMonth}</p>
                    </div>
                    {selectedEmployee ? (
                    <>
                        <div className="grid grid-cols-2 gap-4 mb-6 text-sm">
                            <div>
                                <p className="font-bold">{selectedEmployee.name}</p>
                                <p>{selectedEmployee.position}</p>
                                <p>Shift: {selectedEmployee.shift}</p>
                            </div>
                            <div className="text-right">
                                <p>Shop: {Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop.join(', ') : selectedEmployee.shop}</p>
                                <p>Base Salary: {Utils.formatCurrency(calculations.baseSalary)}</p>
                                <p>Worked Dur.: {Utils.calculateWorkedDuration(selectedEmployee.joinedDate)}</p>
                            </div>
                        </div>
                        <div className="grid grid-cols-2 gap-6">
                            <div className="space-y-2 p-4 border-t-4 border-green-500 bg-green-50 rounded-b-lg">
                                <h3 className="text-lg font-semibold text-slate-900">Earnings</h3>
                                <div className="flex justify-between text-sm"><p>Work Days</p><p className={getChangeIndicatorClass(manualInputs.workDays, oldInputs.workDays)}>{manualInputs.workDays || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Given Off Days</p><p className={getChangeIndicatorClass(manualInputs.givenOffDays, oldInputs.givenOffDays)}>{manualInputs.givenOffDays || 0}</p></div>
                                <div className="flex justify-between text-sm pt-2 border-t border-slate-200"><p>Salary Earned</p><p className={getChangeIndicatorClass(calculations.baseSalaryEarned, oldCalcs.baseSalaryEarned)}>{Utils.formatCurrency(calculations.baseSalaryEarned)}</p></div>
                                <div className="flex justify-between text-sm"><p>OT Salary ({manualInputs.otDays || 0})</p><p className={getChangeIndicatorClass(calculations.otSalary, oldCalcs.otSalary)}>{Utils.formatCurrency(calculations.otSalary)}</p></div>
                                <div className="flex justify-between text-sm"><p>Engagements</p><p className={getChangeIndicatorClass(calculations.engagements, oldCalcs.engagements)}>{Utils.formatCurrency(calculations.engagements)}</p></div>
                                
                                {/* --- NEW (Plan Step 3): Display Savings Payback on Payslip --- */}
                                {/* This line will only appear if there was a withdrawal during the month. */}
                                {calculations.totalSavingsWithdrawal > 0 && (
                                    <div className="flex justify-between text-sm text-indigo-700 font-semibold" title="Savings Program Payback">
                                        <p>Savings Payback</p>
                                        <p className={getChangeIndicatorClass(calculations.totalSavingsWithdrawal, oldCalcs.totalSavingsWithdrawal)}>{Utils.formatCurrency(calculations.totalSavingsWithdrawal)}</p>
                                    </div>
                                )}
                                {/* --- END (Plan Step 3) --- */}

                                <div className="flex justify-between font-bold pt-2 border-t border-slate-300"><p>Gross Salary</p><p className={getChangeIndicatorClass(calculations.grossSalary, oldCalcs.grossSalary)}>{Utils.formatCurrency(calculations.grossSalary)}</p></div>
                            </div>
                            <div className="space-y-2 p-4 border-t-4 border-red-500 bg-red-50 rounded-b-lg">
                                <h3 className="text-lg font-semibold text-slate-900">Deductions</h3>
                                <div className="flex justify-between text-sm"><p>Leave Days</p><p className={`text-red-600 ${getChangeIndicatorClass(manualInputs.leaveDays, oldInputs.leaveDays)}`}>-{manualInputs.leaveDays || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Late ({manualInputs.totalLateDays || 0})</p><p className={getChangeIndicatorClass(calculations.lateDeductionsAmount, oldCalcs.lateDeductionsAmount)}>{Utils.formatCurrency(calculations.lateDeductionsAmount)}</p></div>
                                {/* REVISED: Changed No-CheckOut to No-Attendance */}
                                <div className="flex justify-between text-sm" title="Absent + No-CheckOut"><p>No-Attendance</p><p className={getChangeIndicatorClass(manualInputs.noAttendance, oldInputs.noAttendance)}>{manualInputs.noAttendance || 0}</p></div>
                                <div className="flex justify-between text-sm"><p>Loan Deduction</p><p className={getChangeIndicatorClass(manualInputs.loanDeduction, oldInputs.loanDeduction)}>{Utils.formatCurrency(manualInputs.loanDeduction)}</p></div>
                                <div className="flex justify-between text-sm"><p>Other Deductions</p><p className={getChangeIndicatorClass(calculations.otherDeductions, oldCalcs.otherDeductions)}>{Utils.formatCurrency(calculations.otherDeductions)}</p></div>
                                {/* NEW: Display the rejected leave penalty if it exists */}
                                {calculations.rejectedLeavePenaltyAmount > 0 && (
                                    <div className="flex justify-between text-sm text-red-700 font-semibold" title="Penalty: Absence on a day with a rejected leave request. (Salary Per Day x 2)">
                                        <p>Penalty Leave Rejected</p>
                                        <p className={getChangeIndicatorClass(calculations.rejectedLeavePenaltyAmount, oldCalcs.rejectedLeavePenaltyAmount)}>{Utils.formatCurrency(calculations.rejectedLeavePenaltyAmount)}</p>
                                    </div>
                                )}
                                {/* --- MODIFIED: Step 3 - Display Savings Deduction on Payslip --- */}
                                {/* This will now correctly show $0.00 if a payback occurred, thanks to Step 2's logic. */}
                                {calculations.savingsDeduction > 0 && (
                                    <div className="flex justify-between text-sm text-blue-700 font-semibold" title="Voluntary Savings Program">
                                        <p>Savings Deduction</p>
                                        <p className={getChangeIndicatorClass(calculations.savingsDeduction, oldCalcs.savingsDeduction)}>{Utils.formatCurrency(calculations.savingsDeduction)}</p>
                                    </div>
                                )}
                                <div className="flex justify-between font-bold pt-2 border-t border-slate-300"><p>Total Deductions</p><p className={`text-red-600 ${getChangeIndicatorClass(calculations.totalDeductions, oldCalcs.totalDeductions)}`}>{Utils.formatCurrency(calculations.totalDeductions)}</p></div>
                            </div>
                        </div>
                        <div className="mt-6 p-4 bg-blue-100 border border-blue-300 rounded-lg text-center">
                            <p className="text-sm font-semibold text-blue-800">NET SALARY</p>
                            <p className={`text-3xl font-bold text-blue-900 ${getChangeIndicatorClass(calculations.netSalary, oldCalcs.netSalary)}`}>{Utils.formatCurrency(calculations.netSalary)}</p>
                        </div>
                    </>
                    ) : (
                        <div className="text-center py-20 text-slate-500"><i className="fas fa-file-invoice-dollar text-4xl mb-4"></i><p>Please select an employee to view the payslip.</p></div>
                    )}
                </div>
            );
        });

        const PayrollCalculatorTab = ({ userProfile, editingRecord, onSaveSuccess }) => {
            const { db } = useFirebase();
            const currentMonth = new Date().toISOString().slice(0, 7);
            const [selectedMonth, setSelectedMonth] = useState(currentMonth);
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');
            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from the App Data context provider
            const { shops, employees, shifts } = useAppData();

            // PHASE 2 OPTIMIZATION: Add query constraints for Shop Managers to only load data for their shops.
            const payrollQueryConstraints = useMemo(() => {
                const { role, shop, id } = userProfile || {};
                
                // 1. Logic for Admin/CEO
                if (role === 'Admin' || role === 'CEO') {
                    // *** THE CORRECT FIX ***
                    // If no shop is selected ("............"), return queries
                    // that find NOTHING to prevent downloading the entire database.
                    if (!selectedShop) {
                        return {
                            attendance: [where("shop", "==", "null")],
                            leave: [where("shop", "==", "null")],
                            ot: [where("shop", "==", "null")],
                            loan: [where("shop", "==", "null")],
                            state: [where("shop", "==", "null")],
                            salary: [where("shopName", "==", "null")]
                        };
                    }
                    // A shop IS selected, fetch data ONLY for that shop.
                    return {
                        attendance: [where("shop", "==", selectedShop)],
                        leave: [where("shop", "==", selectedShop)],
                        ot: [where("shop", "==", selectedShop)],
                        loan: [where("shop", "==", selectedShop)],
                        state: [where("shop", "==", selectedShop)],
                        salary: [where("shopName", "==", selectedShop)]
                    };
                }

                // 2. Logic for Shop Manager
                if (role === 'Shop Manager') {
                    const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                    if (managedShops.length > 0) {
                        return {
                            attendance: [where("shop", "in", managedShops)],
                            leave: [where("shop", "in", managedShops)],
                            ot: [where("shop", "in", managedShops)],
                            loan: [where("shop", "in", managedShops)],
                            state: [where("shop", "in", managedShops)],
                            salary: [where("shopName", "in", managedShops)]
                        };
                    }
                }

                // 2. Logic for Shop Manager
                
                // 3. Logic for Staff
                if (role === 'Staff' && id) {
                    // Staff only fetch their own data.
                    return {
                        attendance: [where("employeeId", "==", id)], // Uses employeeId
                        leave: [where("staffId", "==", id)],      // Uses staffId
                        ot: [where("staffId", "==", id)],         // Uses staffId
                        loan: [where("staffId", "==", id)],       // Uses staffId
                        state: [where("staffId", "==", id)],      // Uses staffId
                        salary: [where("staffId", "==", id)]      // Uses staffId
                    };
                }

                // Default: return nothing
                return { attendance: [where("shop", "==", "null")], leave: [where("shop", "==", "null")], ot: [where("shop", "==", "null")], loan: [where("shop", "==", "null")], state: [where("shop", "==", "null")], salary: [where("shopName", "==", "null")] };

            }, [userProfile, selectedShop]); // *** ADDED selectedShop to the dependency array ***
            
            // --- START FIX FOR "Maximum update depth exceeded" ---
            // 1. Extract data fetching from the allData object definition to stabilize its reference.
            // REVISED: Use the new specific query constraints
            const { data: attendanceData } = useCollection('attendance', payrollQueryConstraints.attendance);
            const { data: leaveRequestsData } = useCollection('leaveRequests', payrollQueryConstraints.leave);
            const { data: otRequestsData } = useCollection('otRequests', payrollQueryConstraints.ot);
            const { data: staffLoansData } = useCollection('staffLoans', payrollQueryConstraints.loan);
            const { data: employeeStatesData } = useCollection('employeeStates', payrollQueryConstraints.state);
            const { data: salaryRevisionsData } = useCollection('salaryRevisions', payrollQueryConstraints.salary);

            // 2. Memoize the allData object to prevent it from being recreated on every render.
            // This is the key to fixing the error, as it prevents the usePayrollCalculator hook
            // from re-running unnecessarily and triggering an infinite loop.
            const allData = useMemo(() => ({
                shops,
                employees,
                shifts,
                attendance: attendanceData,
                leaveRequests: leaveRequestsData,
                otRequests: otRequestsData,
                staffLoans: staffLoansData,
                employeeStates: employeeStatesData,
                salaryRevisions: salaryRevisionsData,
            }), [
                shops, employees, shifts, attendanceData, leaveRequestsData, 
                otRequestsData, staffLoansData, employeeStatesData, salaryRevisionsData
            ]);
            // --- END FIX ---
            
            const [manualLoanDeduction, setManualLoanDeduction] = useState(undefined);
            const [isProcessing, setIsProcessing] = useState(false);
        
            // NEW (Step 2): State to manage the recalculation workflow when editing.
            const [isRecalculated, setIsRecalculated] = useState(false);

            // NEW (Step 1): State to hold the data being displayed. This decouples the live
            // calculation from the view, allowing us to load historical data without it
            // being immediately overwritten.
            const [displayInputs, setDisplayInputs] = useState({});
            const [displayCalculations, setDisplayCalculations] = useState({});

            // MODIFIED (STEP 5): Added 'savingsData' state
            const [savingsData, setSavingsData] = useState(null);

            // NEW (Plan Step 1): Add state to hold savings withdrawal data for the selected employee/month.
            const [savingsWithdrawals, setSavingsWithdrawals] = useState([]);

            const isMultiShopManager = userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop);
        
            const isShopManager = userProfile?.role === 'Shop Manager';

            // NEW: Define managedShops based on user profile to fix ReferenceError
            const managedShops = useMemo(() => {
                if (isShopManager) {
                    return Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                }
                return [];
            }, [userProfile, isShopManager]);

            const selectedEmployee = useMemo(() => employees.find(emp => emp.id === selectedEmployeeId), [selectedEmployeeId, employees]);
            
            // The hook now calculates LIVE data in the background. We will decide when to use it.
            // MODIFIED: Pass 'savingsWithdrawals' state to the hook
            // MODIFIED (STEP 5): Pass 'savingsData' state to the hook
            const { inputs: liveInputs, calculations: liveCalculations } = usePayrollCalculator(selectedEmployee, selectedMonth, allData, manualLoanDeduction, savingsWithdrawals, savingsData);

            // Effect to load a historical record or update display with live data for a new record.
            // FIX (Bug #2): Split this single useEffect into two separate effects below.
            // This original effect (lines 5422-5445) is replaced.
            /*
            useEffect(() => {
                if (editingRecord) {
                    // STEP 1 FIX: We are in "edit" mode. Load the exact saved data.
                    // 1. Set the dropdowns to match the record.
                    setSelectedMonth(editingRecord.month); 
                    setSelectedShop(editingRecord.shop); 
                    setSelectedEmployeeId(editingRecord.employeeId);
                    
                    // 2. Populate the display directly from the historical record's saved data.
                    setDisplayInputs(editingRecord.manualInputs || {});
                    setDisplayCalculations(editingRecord.calculations || {});
                    setManualLoanDeduction(editingRecord.manualInputs?.loanDeduction);
                    
                    // NEW (Step 2): Reset recalculation state whenever a new record is loaded.
                    setIsRecalculated(false); 
                } else {
                    // We are in "new payroll" mode. Use the live, auto-calculated data.
                    setDisplayInputs(liveInputs || {});
                    setDisplayCalculations(liveCalculations || {});
                }
            }, [editingRecord, liveInputs, liveCalculations]);
            */

            // --- START BUG #2 FIX ---
            // REPLACEMENT EFFECT 1: This effect *only* handles setting the dropdowns
            // and resetting state when a new editingRecord is loaded.
            useEffect(() => {
                if (editingRecord) {
                    // 1. Set the dropdowns to match the record.
                    setSelectedMonth(editingRecord.month); 
                    setSelectedShop(editingRecord.shop); 
                    setSelectedEmployeeId(editingRecord.employeeId);
                    
                    // 2. Reset recalculation state whenever a new record is loaded.
                    setIsRecalculated(false); 
                }
            }, [editingRecord]); // Only depends on the record itself

            // REPLACEMENT EFFECT 2: This effect handles what data to show in the UI.
            // It correctly shows live data if we are creating a new record OR
            // if we are editing and have clicked "Recalculate".
            useEffect(() => {
                if (editingRecord && !isRecalculated) {
                    // We are in "edit" mode and NOT recalculating. Load the exact saved data.
                    setDisplayInputs(editingRecord.manualInputs || {});
                    setDisplayCalculations(editingRecord.calculations || {});
                    setManualLoanDeduction(editingRecord.manualInputs?.loanDeduction);
                } else {
                    // We are in "new payroll" mode OR "edit and recalculated" mode.
                    // Use the live, auto-calculated data.
                    setDisplayInputs(liveInputs || {});
                    setDisplayCalculations(liveCalculations || {});
                }
            }, [editingRecord, liveInputs, liveCalculations, isRecalculated]); // Depends on live data and recalculate flag
            // --- END BUG #2 FIX ---

            // --- START NEW LOAN DEDUCTION BUG FIX ---
            
            // REMOVED: The two conflicting useEffect hooks that managed
            // manualLoanDeduction have been removed. They were:
            
            // --- REMOVED HOOK 1 (The "Resetter") ---
            // useEffect(() => {
            //     if (!editingRecord) {
            //         setManualLoanDeduction(undefined);
            //     }
            // }, [selectedEmployeeId, selectedMonth, editingRecord]); // <-- FIX: Removed `allData`
            
            // --- REMOVED HOOK 2 (The "Populator") ---
            // useEffect(() => {
            //     // Use the "pure" automatic value, ignoring any manual override
            //     if (!editingRecord && liveInputs.autoLoanDeduction !== undefined && manualLoanDeduction === undefined) {
            //         setManualLoanDeduction(liveInputs.autoLoanDeduction);
            //     }
            // }, [liveInputs.autoLoanDeduction, editingRecord]); // <-- FIX: Removed `manualLoanDeduction`
            

            // NEW: This single hook now replaces the two above.
            // It is the single source of truth for the manualLoanDeduction state
            // when in "new payroll" mode or "recalculate" mode.
            useEffect(() => {
                if (!editingRecord || isRecalculated) {
                    // We are in "new payroll" mode OR "edit and recalculated" mode.
                    // *always* set the manual loan input to the latest auto-calculated value.
                    // This populates "0" for no loan, "5000" for a loan, or
                    // "undefined" if it's still loading. This fixes the stuck "0" bug.
                    setManualLoanDeduction(liveInputs.autoLoanDeduction);
                }
                // If 'editingRecord' exists and 'isRecalculated' is false,
                // the "REPLACEMENT EFFECT 2" (at line 5437) is responsible for setting
                // the manualLoanDeduction from the saved record. This hook does nothing.
                
            }, [liveInputs.autoLoanDeduction, editingRecord, isRecalculated]);
            
            // --- END NEW LOAN DEDUCTION BUG FIX ---

            // Reset state when editingRecord is cleared (e.g., after a save) or on initial load
            useEffect(() => {
                if (!editingRecord && userProfile) {
                    if (userProfile.role === 'Admin' || isShopManager) { setSelectedShop(''); } 
                    else { setSelectedShop(userProfile.shop || ''); }
                    setSelectedEmployeeId(''); 
                    setSelectedMonth(currentMonth);
                    setManualLoanDeduction(undefined);
                    setIsRecalculated(false); // Also reset recalculation state
                }
            }, [editingRecord, userProfile, currentMonth, isShopManager]);
            
            const handleManualLoanChange = (e) => {
                const value = e.target.value;
                setManualLoanDeduction(value === '' ? undefined : parseFloat(value));
            };
            
            // NEW (Step 3): Handler to trigger on-demand recalculation
            const handleRecalculate = () => {
                setDisplayInputs(liveInputs || {});
                setDisplayCalculations(liveCalculations || {});
                // When recalculating, the loan deduction should also update to the live auto-calculated value
                setManualLoanDeduction(liveInputs.loanDeduction); 
                setIsRecalculated(true);
            };

            // NEW (Step 3): Handler to cancel recalculation and revert to the original historical data
            const handleCancelRecalculation = () => {
                if (editingRecord) {
                    setDisplayInputs(editingRecord.manualInputs || {});
                    setDisplayCalculations(editingRecord.calculations || {});
                    setManualLoanDeduction(editingRecord.manualInputs?.loanDeduction);
                    setIsRecalculated(false);
                }
            };

            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (isShopManager) {
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile, isShopManager, managedShops]);

            const employeesForDropdown = useMemo(() => {
                let relevantEmployees = [];
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') {
                     relevantEmployees = selectedShop 
                        ? employees.filter(e => Array.isArray(e.shop) ? e.shop.includes(selectedShop) : e.shop === selectedShop)
                        : []; // REVISED: No shop = no employees. Forces Admin to select a shop.
                } else if (isShopManager) {
                    const shopsToFilter = selectedShop ? [selectedShop] : managedShops;
                    relevantEmployees = employees.filter(e => {
                        const employeeShops = Array.isArray(e.shop) ? e.shop : [e.shop];
                        return employeeShops.some(s => shopsToFilter.includes(s));
                    });
                } else { // Staff
                    relevantEmployees = employees.filter(e => e.shop === userProfile.shop);
                }
                return relevantEmployees.filter(e => e.status === 'Active');
            }, [selectedShop, employees, userProfile, isShopManager, managedShops]);

            const handleDownloadPayslip = () => {
                const payslipElement = document.getElementById('payslip-preview');
                if (!payslipElement || !selectedEmployee) { alert("Please select an employee to generate a payslip."); return; }
                const [year, month] = selectedMonth.split('-');
                const shopName = Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop[0] : selectedEmployee.shop;
                html2canvas(payslipElement, { backgroundColor: '#ffffff', scale: 2 }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `${shopName}-${selectedEmployee.name}-${month}-${year.substring(2)}.png`;
                    link.href = canvas.toDataURL('image/png'); link.click();
                });
            };

            const handleSaveAndDownload = async () => {
                setIsProcessing(true);
                if (!selectedEmployee || displayCalculations.netSalary === undefined) {
                    alert("Cannot process. Please ensure an employee is selected and payroll is calculated.");
                    setIsProcessing(false);
                    return;
                }
                const shopName = Array.isArray(selectedEmployee.shop) ? selectedEmployee.shop[0] : selectedEmployee.shop;
                const { addDoc, collection, serverTimestamp, doc, updateDoc, getDocs, query, where } = window.firebaseSDK;
                
                // NEW: Check for duplicates before saving, but only if it's NOT an edit
                if (!editingRecord) {
                    const payrollCheckQuery = query(collection(db, "payrollHistory"), where("employeeId", "==", selectedEmployee.id), where("month", "==", selectedMonth));
                    const existingPayrollSnap = await getDocs(payrollCheckQuery);
                    if (!existingPayrollSnap.empty) {
                        alert(`Payroll for ${selectedEmployee.name} for ${selectedMonth} has already been generated and saved.`);
                        setIsProcessing(false);
                        return; // Stop the function to prevent a duplicate
                    }
                }

                const finalInputsForSave = { ...displayInputs, loanDeduction: manualLoanDeduction };
                        const payrollData = { month: selectedMonth, shop: shopName, employeeId: selectedEmployee.id, employeeName: selectedEmployee.name, baseSalary: displayCalculations.baseSalary, netSalary: displayCalculations.netSalary, manualInputs: finalInputsForSave, calculations: displayCalculations };
                
                let payrollRecordId;
                let success = false;
                try {
                    if (editingRecord) { 
                        await updateDoc(doc(db, 'payrollHistory', editingRecord.id), payrollData); 
                        payrollRecordId = editingRecord.id;
                    } 
                    else { 
                        const newDocRef = await addDoc(collection(db, 'payrollHistory'), { ...payrollData, createdAt: serverTimestamp() }); 
                        payrollRecordId = newDocRef.id;
                    }
                    
                    if (finalInputsForSave.loanDeduction > 0) {
                        // --- BUG FIX: Use deterministic logic to find the correct loan ---
                        // This ensures the deduction is applied to the *correct* loan,
                        // by finding the one with the latest effectiveDate.
                        const applicableLoans = (allData.staffLoans || [])
                            .filter(l => l.staffId === selectedEmployee.id && 
                                         l.status === 'Active' &&
                                         (!l.effectiveDate || l.effectiveDate.slice(0, 7) <= selectedMonth)
                            )
                            .sort((a, b) => (b.effectiveDate || '0000-00').localeCompare(a.effectiveDate || '0000-00'));

                        const activeLoan = applicableLoans.length > 0 ? applicableLoans[0] : null;
                        // --- END FIX ---

                        if (activeLoan) {
                            const newTotalPaid = (activeLoan.totalPaid || 0) + finalInputsForSave.loanDeduction;
                            const newBalance = activeLoan.loanAmount - newTotalPaid;
                            const newStatus = newBalance <= 0 ? 'Paid Off' : 'Active';
                            await updateDoc(doc(db, 'staffLoans', activeLoan.id), { totalPaid: newTotalPaid, status: newStatus });
                            // FIX: Add the payrollRecordId to the loan payment for reversal tracking.
                            await addDoc(collection(db, 'loanPayments'), { paymentDate: `${selectedMonth}-${new Date(selectedMonth.split('-')[0], selectedMonth.split('-')[1], 0).getDate()}`, staffId: selectedEmployee.id, staffName: selectedEmployee.name, shop: shopName, loanId: activeLoan.id, amountPaid: finalInputsForSave.loanDeduction, remainingBalance: newBalance, note: "Paid via payroll", payrollId: payrollRecordId });
                        }
                    }

                    // --- NEW: Step 3 - Process Savings Contribution ---
                    if (displayCalculations.savingsDeduction > 0) {
                        // MODIFIED (STEP 5): Pass the 'shopName' to the utility function
                        // NEW: Log before calling
                        console.log(`[Payroll Save] Calling manageSavingsContribution for ${selectedEmployee.name}, Amount: ${displayCalculations.savingsDeduction}`);
                        await Utils.manageSavingsContribution(
                            db,
                            selectedEmployee.id,
                            selectedEmployee.name,
                            shopName, // Pass the shopName
                            displayCalculations.savingsDeduction,
                            payrollRecordId // Link to the payroll record
                        );
                    }
                    // --- END: Step 3 ---

                    alert('Payroll saved successfully!');
                    success = true;
                } catch (error) {
                    console.error("Error saving payroll: ", error);
                    alert('Failed to save payroll.');
                    success = false;
                }

                if (success) {
                    setTimeout(() => {
                        handleDownloadPayslip();
                        onSaveSuccess(selectedMonth);
                    }, 500);
                } else {
                    setIsProcessing(false);
                }
            };
           
            const canSelectShop = (userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || isShopManager) && !editingRecord;
        
            return (
                // MODIFIED: Wrapped in React.Fragment to add the new section below
                <>
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <Card><CardTitle>Payroll Calculator</CardTitle>
                        {/* MODIFIED: Changed from space-y-6 to a responsive grid for the selectors */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        {/* MODIFIED: Simplified the wrapper for the Month selector to be a grid item */}
                        <div>
                            <label className="text-sm font-medium text-slate-400">Month</label>
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input" disabled={!!editingRecord} />
                        </div>
                        <div>
                            <label className="text-sm font-medium text-slate-400">Shop</label>
                            {canSelectShop ? (
                                <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select">
                                    <option value="">{userProfile?.role === 'Admin' || userProfile?.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            ) : (
                                <input value={selectedShop} className="input" disabled />
                            )}
                        </div>
                        <div>
                            <label className="text-sm font-medium text-slate-400">Employee</label>
                            <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select" disabled={!!editingRecord || employeesForDropdown.length === 0}>
                                <option value="">Select Employee</option>
                                {employeesForDropdown.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                            </select>
                        </div>
                    </div>{selectedEmployee && (<><div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-6 border-t border-slate-700"><h3 className="md:col-span-3 text-lg font-semibold text-slate-200">Attendance & Deductions</h3><div><label className="text-sm">Work Days</label><input type="number" name="workDays" value={displayInputs.workDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Given Off Days</label><input type="number" name="givenOffDays" value={displayInputs.givenOffDays ?? ''} className="input" disabled /></div><div><label className="text-sm">OT Days</label><input type="number" name="otDays" value={displayInputs.otDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Leave Days</label><input type="number" name="leaveDays" value={displayInputs.leaveDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Total Late Days</label><input type="number" name="totalLateDays" value={displayInputs.totalLateDays ?? ''} className="input" disabled /></div><div><label className="text-sm">Loan Deduction</label><input type="number" name="loanDeduction" value={manualLoanDeduction ?? ''} onChange={handleManualLoanChange} className="input" /></div></div><div className="pt-6 border-t border-slate-700 flex flex-col sm:flex-row gap-4">
                        {/* --- NEW (Step 2/3): Conditional button rendering for edit workflow --- */}
                        {editingRecord ? (
                            // We are editing a historical record
                            isRecalculated ? (
                                // After recalculation has been triggered
                                <>
                                    <Button variant="secondary" onClick={handleCancelRecalculation} className="flex-1">
                                        <i className="fas fa-undo"></i> Cancel Recalculation
                                    </Button>
                                    <Button variant="primary" onClick={handleSaveAndDownload} disabled={isProcessing} className="flex-1">
                                        {isProcessing ? (<><i className="fas fa-spinner fa-spin"></i> Processing...</>) : (<><i className="fas fa-save"></i> Save Updated Record</>)}
                                    </Button>
                                </>
                            ) : (
                                // Before recalculation (viewing original record)
                                <>
                                    <Button variant="secondary" onClick={handleDownloadPayslip} className="flex-1">
                                        <i className="fas fa-download"></i> Download Original
                                    </Button>
                                    <Button variant="primary" onClick={handleRecalculate} icon="fa-calculator" className="flex-1">
                                        Recalculate with Live Data
                                    </Button>
                                </>
                            )
                        ) : (
                            // This is a new payroll calculation
                            <Button variant="primary" onClick={handleSaveAndDownload} disabled={isProcessing} className="flex-1">
                                {isProcessing ? (<><i className="fas fa-spinner fa-spin"></i> Processing...</>) : (<><i className="fas fa-save"></i> Save & Download</>)}
                            </Button>
                        )}
                        {/* --- END: Conditional button rendering --- */}
                    </div></>)}</Card>
                    <PayslipPreview 
                        selectedEmployee={selectedEmployee}
                        selectedMonth={selectedMonth}
                        manualInputs={{...displayInputs, loanDeduction: manualLoanDeduction }}
                        calculations={displayCalculations}
                        // NEW (Step 4): Pass props needed for visual diffing
                        isRecalculated={isRecalculated}
                        originalRecord={editingRecord}
                    />
                    
                    {/* FIX: Added missing closing </div> for the main grid */}
                    </div>

                    {/* --- FIX: This block was corrupted. Replacing with correct TriggerSalaryTab --- */}
                    {/* NEW: Added TriggerSalaryTab below the calculator/payslip grid */}
                    {/* MODIFIED: Allow Shop Manager to access this tool as well */}
                    {(userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || userProfile?.role === 'Shop Manager') && (
                        <div className="mt-8">
                            <TriggerSalaryTab />
                        </div>
                    )}
                </>
            );
        };

        // MODIFIED (STEP 6.D): Removed the 'employees' prop
        const PayrollHistoryTab = ({ onEdit, userProfile }) => {
            const { db } = useFirebase();
            // FIX (Bug #1): Added Firestore functions needed for transactional delete
            // MODIFIED (STEP 6.D): We only need collectionGroup for the savings query now
            const { where, query, collection, getDocs, doc, runTransaction, deleteDoc, collectionGroup } = window.firebaseSDK;

            // --- START RESTORED CODE ---
            // Filter states
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));

            // Data states
            const [history, setHistory] = useState([]);
            const [loading, setLoading] = useState(false);
            // REFACTORED: Get shops from central context.
            const { shops } = useAppData();

            // PHASE 3: Fetch payroll history on-demand for all roles for consistency and performance
            useEffect(() => {
                const fetchHistory = async () => {
                    if (!userProfile) return;
                    setLoading(true);

                    const { role, shop } = userProfile;
                    let q = query(collection(db, 'payrollHistory'));

                    // 1. Filter by role
                    if (role === 'Shop Manager') {
                        const managedShops = Array.isArray(shop) ? shop : (shop ? [shop] : []);
                        if (managedShops.length > 0) {
                            // REVISED: If a specific shop is selected, query for just that one.
                            if (selectedShop) {
                                q = query(q, where("shop", "==", selectedShop));
                            } 
                            // Otherwise, query for all their managed shops.
                            else {
                                q = query(q, where("shop", "in", managedShops));
                            }
                        } else {
                            q = query(q, where("shop", "==", "null")); // No shops, no data
                        }
                    // REVISED: Apply on-demand logic for Admin/CEO
                    } else if (role === 'Admin' || role === 'CEO') {
                        if (selectedShop) {
                            // A specific shop is selected, query for it.
                            q = query(q, where("shop", "==", selectedShop));
                        } else {
                            // *** THE FIX ***
                            // If no shop is selected ("............"), do not fetch any
                            // records. This prevents the "Data-Bomb" quota error.
                            q = query(q, where("shop", "==", "null"));
                        }
                    }
                    // Staff don't see this page, so no specific filter needed.
                    
                    // 2. Add the month filter to the query
                    if (selectedMonth) {
                        q = query(q, where("month", "==", selectedMonth));
                    }
                    
                    try {
                        const snapshot = await getDocs(q);
                        const historyData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setHistory(historyData);
                    } catch (error) {
                        console.error("Error fetching payroll history:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchHistory();
            }, [db, userProfile, selectedMonth, selectedShop]); // Refetch when filters change

            const [recordToDelete, setRecordToDelete] = useState(null);
            
            // ... (rest of the component logic remains largely the same, but uses `history` state instead of `useCollection` data)
            
            const isMultiShopManager = userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop) && userProfile.shop.length > 1;
            const canFilterByShop = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || isMultiShopManager;

            const availableShopsForFilter = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (isMultiShopManager) {
                    // Map shop names to the structure expected by the select dropdown
                    return userProfile.shop.map(name => ({ id: name, name: name }));
                }
                return [];
            }, [shops, userProfile, isMultiShopManager]);
            
            // NEW: Set initial shop state based on user role - now only for Admin UI
            useEffect(() => { 
                if (userProfile && userProfile.role === 'Shop Manager' && !isMultiShopManager) {
                     setSelectedShop(userProfile.shop || ''); 
                } else {
                    setSelectedShop('');
                }
            }, [userProfile, isMultiShopManager]);

            const { filteredHistory, totals } = useMemo(() => {
                // Client-side filtering is now simpler as server does most of the work
                const filtered = history.filter(rec => {
                    // REVISED: This client-side filter is no longer needed, as the server query handles it.
                    // if (userProfile?.role === 'Shop Manager' && selectedShop) {
                    //     return rec.shop === selectedShop;
                    // }
                    return true;
                });
                    const sorted = [...filtered].sort((a,b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
                const totals = sorted.reduce((acc, curr) => { 
                    acc.baseSalary += curr.baseSalary || 0; 
                    acc.engagements += curr.calculations?.engagements || 0;
                    acc.otSalary += curr.calculations?.otSalary || 0;
                    acc.totalSavingsPayback += curr.calculations?.totalSavingsWithdrawal || 0; // Add this
                    acc.loanDeduction += curr.manualInputs?.loanDeduction || 0; 
                    acc.otherDeductions += curr.calculations?.otherDeductions || 0;
                    acc.savingsDeduction += curr.calculations?.savingsDeduction || 0; // NEW: Add savings to totals
                    acc.netSalary += curr.netSalary || 0; 
                    return acc; 
                }, { baseSalary: 0, engagements: 0, otSalary: 0, totalSavingsPayback: 0, loanDeduction: 0, otherDeductions: 0, savingsDeduction: 0, netSalary: 0 }); // NEW: Initialize savings
                return { filteredHistory: sorted, totals };
            }, [history, selectedShop, userProfile]);
            // --- END RESTORED CODE ---

            // --- START BUG FIX #1 RE-IMPLEMENTATION ---
            const handleDelete = async () => {
                if (!recordToDelete) return;
                
                // Get necessary data from the record before starting the transaction
                const payrollId = recordToDelete.id;
                const employeeId = recordToDelete.employeeId;
                const loanDeductionAmount = recordToDelete.manualInputs?.loanDeduction || 0;
                const savingsContributionAmount = recordToDelete.calculations?.savingsDeduction || 0;

                // MODIFIED (STEP 6.D): Removed the dependency on the 'employees' prop and the
                // faulty 'isEmployeeStillInSavingsProgram' logic.
                
                try {
                    // --- PRE-TRANSACTION READS (THE FIX) ---
                    // All queries must be run *before* the transaction starts.
                    
                    // 1. Find the loan payment record (if any) linked to this payroll ID.
                    const loanPaymentQuery = query(collection(db, 'loanPayments'), where("payrollId", "==", payrollId));
                    const loanPaymentSnap = await getDocs(loanPaymentQuery); // Run query *outside* transaction

                    // 2. Find the savings transaction record (if any) linked to this payroll ID.
                    // MODIFIED (STEP 6.D): Use the new subcollection path, which requires the employeeId.
                    const savingsTxQuery = query(
                        collection(db, 'savingprogram', employeeId, 'transactions'), 
                        where("payrollId", "==", payrollId), 
                        where("type", "==", "contribution")
                    );
                    const savingsTxSnap = await getDocs(savingsTxQuery); // Run query *outside* transaction
                    // --- END PRE-TRANSACTION READS ---

                    // Use runTransaction for atomic operations
                    await runTransaction(db, async (transaction) => {
                        
                        // --- 1. Loan Reversal Logic ---
                        if (loanDeductionAmount > 0) {
                            // Use the snapshot result from *outside* the transaction
                            if (!loanPaymentSnap.empty) {
                                const loanPaymentDoc = loanPaymentSnap.docs[0];
                                const loanPaymentData = loanPaymentDoc.data();
                                const loanId = loanPaymentData.loanId;
                                const amountPaidInPayroll = loanPaymentData.amountPaid || 0;

                                // Get the main staff loan document *within the transaction*.
                                const staffLoanRef = doc(db, 'staffLoans', loanId);
                                const staffLoanDoc = await transaction.get(staffLoanRef);

                                if (staffLoanDoc.exists()) {
                                    const staffLoanData = staffLoanDoc.data();
                                    const currentTotalPaid = staffLoanData.totalPaid || 0;
                                    // Calculate new total, ensuring it doesn't go below zero.
                                    const newTotalPaid = Math.max(0, currentTotalPaid - amountPaidInPayroll); 
                                    const newStatus = newTotalPaid < staffLoanData.loanAmount ? 'Active' : 'Paid Off';

                                    // Update the main staff loan document *within the transaction*.
                                    transaction.update(staffLoanRef, { 
                                        totalPaid: newTotalPaid,
                                        status: newStatus 
                                    });
                                } else {
                                     console.warn(`Staff loan document ${loanId} not found during payroll delete reversal.`);
                                }

                                // Delete the loan payment record *within the transaction*.
                                transaction.delete(loanPaymentDoc.ref);
                            } else {
                                console.warn(`Loan payment record for payroll ID ${payrollId} not found. Cannot reverse loan payment.`);
                            }
                        }

                        // --- 2. Savings Reversal Logic ---
                        // MODIFIED (STEP 6.D): This logic is now corrected and simplified.
                        if (savingsContributionAmount > 0) {
                            // Use the snapshot result from *outside* the transaction
                            if (!savingsTxSnap.empty) {
                                const savingsTxDoc = savingsTxSnap.docs[0];
                                const amountContributed = savingsTxDoc.data().amountDeducted || 0;
                                
                                // Get the main employee savings document *within the transaction*.
                                // MODIFIED (STEP 6.D): Use the new '/savingprogram' path
                                const employeeSavingsRef = doc(db, 'savingprogram', employeeId);
                                const employeeSavingsDoc = await transaction.get(employeeSavingsRef);

                                if (employeeSavingsDoc.exists()) {
                                    const currentBalance = employeeSavingsDoc.data().currentBalance || 0;
                                    // Calculate new balance, ensuring it doesn't go below zero.
                                    const newBalance = Math.max(0, currentBalance - amountContributed); 

                                    // Update the main employee savings document *within the transaction*.
                                    transaction.update(employeeSavingsRef, { 
                                        currentBalance: newBalance 
                                    });
                                } else {
                                     console.warn(`Employee savings document for ${employeeId} not found during payroll delete reversal.`);
                                }
                                
                                // Delete the savings transaction record *within the transaction*.
                                transaction.delete(savingsTxDoc.ref);
                            } else {
                                console.warn(`Savings contribution record for payroll ID ${payrollId} not found. Cannot reverse savings contribution.`);
                            }
                        }
                        
                        // MODIFIED (STEP 6.D): Removed the faulty 'else if' block that
                        // prevented savings reversal for inactive program members.
                        
                        // --- 3. Payroll History Deletion ---
                        // Delete the main payroll history document *within the transaction*.
                        const payrollHistoryRef = doc(db, 'payrollHistory', payrollId);
                        transaction.delete(payrollHistoryRef);
                    });
                    
                    // --- Post-Transaction UI Update ---
                    // Refetch data after successful delete by triggering the useEffect dependency.
                    // This forces the component to re-run the fetchHistory function.
                    // REVISED: The old method was unreliable.
                    // setSelectedMonth(prev => `${prev}`); 
                    
                    // NEW: Manually filter the deleted record out of the local state
                    // This provides an immediate UI update without a full refetch.
                    setHistory(prevHistory => prevHistory.filter(record => record.id !== payrollId));
                    
                    alert('Payroll record and associated transactions deleted successfully.');

                } catch (error) {
                    console.error("Error during transactional delete of payroll record:", error);
                    alert(`Failed to delete payroll record: ${error.message}`);
                } finally {
                    // Close the confirmation modal regardless of outcome
                    setRecordToDelete(null); 
                }
            };
            // --- END BUG FIX #1 RE-IMPLEMENTATION ---

            // ... The rest of the PayrollHistoryTab component's return statement (UI) remains unchanged ...
            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Payroll History</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            {canFilterByShop && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShopsForFilter.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                        </div>
                    </div>
                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-slate-700">
                                <thead className="bg-slate-900/50">
                                    <tr>
                                        {/* Table headers remain the same */}
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Month</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Base Salary</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Engagements</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">OT Salary</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Savings Payback</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Loan Ded.</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Other Ded.</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Savings Ded.</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Net Salary</th>
                                        <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                    </tr>
                                </thead>
                                {/* FIX: Restoring the correct table body for PayrollHistoryTab */}
                                <tbody className="divide-y divide-slate-700">
                                    {filteredHistory.map(record => (
                                        <tr key={record.id} className="hover:bg-slate-700/50">
                                            <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{record.month}</td>
                                            <td className="px-4 py-4 text-sm text-slate-300 whitespace-nowrap">{record.shop}</td>
                                            <td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{record.employeeName}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.baseSalary)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.calculations?.engagements)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.calculations?.otSalary)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.calculations?.totalSavingsWithdrawal)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.manualInputs?.loanDeduction)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.calculations?.otherDeductions)}</td>
                                            <td className="px-4 py-4 text-sm text-right">{Utils.formatCurrency(record.calculations?.savingsDeduction)}</td>
                                            <td className="px-4 py-4 text-sm text-right font-bold text-blue-300">{Utils.formatCurrency(record.netSalary)}</td>
                                            <td className="px-4 py-4 text-center">
                                                <div className="flex items-center justify-center gap-4">
                                                    <Button variant="icon-edit" icon="fa-edit" onClick={() => onEdit(record)} title="Edit"/>
                                                    <Button variant="icon-delete" icon="fa-trash" onClick={() => setRecordToDelete(record)} title="Delete"/>
                                                </div>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                                <tfoot className="bg-slate-900/50">
                                     {/* Table footer remains the same */}
                                    <tr>
                                        <td colSpan="3" className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Total</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.baseSalary)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.engagements)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.otSalary)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalSavingsPayback)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.loanDeduction)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.otherDeductions)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-blue-300">{Utils.formatCurrency(totals.savingsDeduction)}</td>
                                        <td className="px-4 py-3 text-right font-bold text-blue-300">{Utils.formatCurrency(totals.netSalary)}</td>
                                        <td></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    )}
                    {/* Updated confirmation message */}
                    <ConfirmationModal 
                        isOpen={!!recordToDelete} 
                        onClose={() => setRecordToDelete(null)} 
                        onConfirm={handleDelete} 
                        title="Delete Payroll Record" 
                        message="Are you sure? Deleting this payroll record will also reverse any associated loan payments and savings contributions made during this payroll run. This action cannot be undone." 
                    />
                </Card>
            );
        };

        const EmployeeStateTab = ({ userProfile }) => {
            const { db } = useFirebase();
            const fileInputRef = useRef(null); // For triggering file upload
            const [isImporting, setIsImporting] = useState(false);
            const [importResult, setImportResult] = useState(null);
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingRecord, setEditingRecord] = useState(null);
            const [recordToDelete, setRecordToDelete] = useState(null);
            const { where } = window.firebaseSDK;

            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();

            const queryConstraints = useMemo(() => {
                if (!userProfile) return [where("staffId", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) {
                        return [where("shop", "in", shops)];
                    }
                    return [where("staffId", "==", "null")]; // No shops, no data
                }
                // Staff can only see their own records.
                return [where("staffId", "==", userProfile.id || null)];
            }, [userProfile]);

            const { data: employeeStates } = useCollection('employeeStates', queryConstraints);
            
            const [selectedShop, setSelectedShop] = useState('');
            const [filterMode, setFilterMode] = useState('month'); // 'month' or 'date'
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [selectedDate, setSelectedDate] = useState(new Date().toISOString().slice(0, 10));
            const [selectedEmployeeId, setSelectedEmployeeId] = useState('');

            // NEW: Add collections needed for penalty calculation
            const salaryRevQueryConstraints = useMemo(() => {
                if (!userProfile) return [where("shopName", "==", "null")];
                if (userProfile.role === 'Admin') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    return shops.length > 0 ? [where("shopName", "in", shops)] : [where("shopName", "==", "null")];
                }
                const userShop = employees.find(e => e.id === userProfile.id)?.shop;
                return [where("shopName", "==", userShop || null)];
            }, [userProfile, employees]);
            
            const { data: attendance } = useCollection('attendance', queryConstraints);
            const { data: leaveRequests } = useCollection('leaveRequests', queryConstraints);
            const { data: salaryRevisions } = useCollection('salaryRevisions', salaryRevQueryConstraints);


            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin') {
                    // For managers with multiple shops, default to showing all their shops.
                    // For single-shop users, their shop is pre-selected.
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);

            const filteredRecords = useMemo(() => {
                const dbRecords = employeeStates.filter(rec => {
                    const dateMatch = filterMode === 'month'
                        ? (!selectedMonth || (rec.date && rec.date.startsWith(selectedMonth)))
                        : (!selectedDate || rec.date === selectedDate);
                    
                    return dateMatch &&
                           (!selectedShop || rec.shop === selectedShop) &&
                           (!selectedEmployeeId || rec.staffId === selectedEmployeeId);
                });

                // NEW: Calculate penalty records for the selected month
                const calculatedPenaltyRecords = [];
                if (filterMode === 'month' && selectedMonth) {
                    const [year, monthNum] = selectedMonth.split('-').map(Number);
                    const daysInMonth = new Date(year, monthNum, 0).getDate();
                    
                    const employeesToCheck = employees.filter(emp => 
                        emp.status === 'Active' &&
                        (!selectedShop || (Array.isArray(emp.shop) ? emp.shop.includes(selectedShop) : emp.shop === selectedShop)) &&
                        (!selectedEmployeeId || emp.id === selectedEmployeeId)
                    );

                    for (const employee of employeesToCheck) {
                        const monthAttendance = (attendance || []).filter(r => r.employeeId === employee.id && r.timestamp?.toDate().toISOString().startsWith(selectedMonth));
                        const attendedDays = new Set(monthAttendance.map(r => r.timestamp.toDate().toISOString().split('T')[0]));
                        const approvedLeaves = (leaveRequests || []).filter(lr => lr.staffId === employee.id && lr.status === 'Approved');
                        
                        const applicableRevisions = (salaryRevisions || [])
                            .filter(rev => rev.staffId === employee.id && rev.effectiveDate && rev.effectiveDate <= `${selectedMonth}-31` && rev.status === 'Approved')
                            .sort((a, b) => b.effectiveDate.localeCompare(a.effectiveDate));
                        
                        const baseSalary = applicableRevisions.length > 0
                            ? (parseFloat(String(applicableRevisions[0].updatedSalary).replace(/[^0-9.-]/g, '')) || 0)
                            : (parseFloat(String(employee.salary).replace(/[^0-9.-]/g, '')) || 0);
                        
                        const salaryPerDay = baseSalary > 0 && daysInMonth > 0 ? baseSalary / daysInMonth : 0;
                        const rejectedLeaves = (leaveRequests || []).filter(lr => lr.staffId === employee.id && lr.status === 'Rejected');
                        
                        let penaltyAmount = 0;
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);

                        for (let day = 1; day <= daysInMonth; day++) {
                            const currentDay = new Date(year, monthNum - 1, day);
                            if (currentDay >= today) break;

                            const dayKey = `${year}-${String(monthNum).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                            if (!attendedDays.has(dayKey)) {
                                const isOnApprovedLeave = approvedLeaves.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                                if (!isOnApprovedLeave) {
                                    const hadRejectedLeave = rejectedLeaves.some(lr => dayKey >= lr.leaveDate && dayKey < lr.returnDate);
                                    if (hadRejectedLeave) {
                                        penaltyAmount += (salaryPerDay * 2);
                                    }
                                }
                            }
                        }

                        if (penaltyAmount > 0) {
                            calculatedPenaltyRecords.push({
                                id: `virtual_penalty_${employee.id}`,
                                date: `${selectedMonth}-01`, // Assign to the start of the month for sorting
                                shop: Array.isArray(employee.shop) ? employee.shop[0] : employee.shop,
                                staffId: employee.id,
                                staffName: employee.name,
                                statusState: 'Deduction',
                                amount: penaltyAmount,
                                note: 'Penalty (Absence on Rejected Leave)',
                                status: 'Approved',
                                isVirtual: true,
                            });
                        }
                    }
                }
                
                // Combine DB records with calculated ones and sort
                const combinedRecords = [...dbRecords, ...calculatedPenaltyRecords];
                
                return combinedRecords.sort((a, b) => {
                    if (a.status === 'Pending' && b.status !== 'Pending') return -1;
                    if (a.status !== 'Pending' && b.status === 'Pending') return 1;
                    return new Date(b.date) - new Date(a.date);
                });
            }, [employeeStates, selectedShop, selectedMonth, selectedDate, filterMode, selectedEmployeeId, employees, attendance, leaveRequests, salaryRevisions]);
            
            const handleOpenModal = (record = null) => { setEditingRecord(record); setModalOpen(true); };
            const handleCloseModal = () => { setEditingRecord(null); setModalOpen(false); };

            const handleSave = async (formData) => {
                const { addDoc, collection, doc, updateDoc } = window.firebaseSDK;
                const staffName = employees.find(e => e.id === formData.staffId)?.name || '';
                const dataToSave = { ...formData, amount: parseFloat(formData.amount) || 0, staffName: staffName };

                // Add approval status for new records
                if (!formData.id) {
                    dataToSave.status = dataToSave.statusState === 'Engagement' ? 'Pending' : 'Approved';
                }

                try {
                    if (formData.id) { const { id, ...data } = dataToSave; await updateDoc(doc(db, 'employeeStates', id), data); } 
                    else { await addDoc(collection(db, 'employeeStates'), dataToSave); }
                    handleCloseModal();
                } catch (error) { console.error("Error saving employee state:", error); }
            };

            const handleDelete = async () => {
                if (!recordToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'employeeStates', recordToDelete.id));
                    setRecordToDelete(null);
                } catch (error) { console.error("Error deleting record:", error); setRecordToDelete(null); }
            };

            const handleUpdateStatus = useCallback(async (recordId, newStatus) => {
                if (!recordId || !newStatus) return;
                try {
                    await window.firebaseSDK.updateDoc(window.firebaseSDK.doc(db, 'employeeStates', recordId), { status: newStatus });
                } catch (error) {
                    console.error(`Error updating record ${recordId} status:`, error);
                }
            }, [db]);

            // NEW: Function to download the Excel template
            const handleDownloadTemplate = useCallback(() => {
                const templateData = [
                    { employeeId: '(Optional)', staffName: 'Example Staff Name', shop: 'Example Shop Name', date: '2025-09-26', statusState: 'Deduction', amount: 5000, note: 'Sample reason' },
                ];
                // Explicitly set the header order
                const worksheet = XLSX.utils.json_to_sheet(templateData, { header: ["employeeId", "staffName", "shop", "date", "statusState", "amount", "note"] });
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Template");
                worksheet["!cols"] = [ { wch: 20 }, { wch: 25 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 40 } ];
                XLSX.writeFile(workbook, "Engagement_Deduction_Template.xlsx");
            }, []);

            // NEW: Function to trigger the hidden file input
            const triggerFileUpload = () => {
                if (fileInputRef.current) {
                    fileInputRef.current.value = ""; // Allow re-uploading the same file
                }
                fileInputRef.current.click();
            };
            
            // NEW: Function to handle the file upload and processing
            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setIsImporting(true);
                setImportResult(null);

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: "array", cellDates: true });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        // Convert dates to YYYY-MM-DD format string to avoid timezone issues
                        const json = XLSX.utils.sheet_to_json(worksheet, { raw: false, dateNF: 'yyyy-mm-dd' });

                        if (json.length === 0) {
                            setImportResult({ success: false, message: 'The Excel file is empty or in the wrong format.' });
                            setIsImporting(false);
                            return;
                        }

                        const { collection, writeBatch, doc } = window.firebaseSDK;
                        const batch = writeBatch(db);
                        let errors = [];
                        let successCount = 0;

                        json.forEach((row, index) => {
                            const rowNum = index + 2;
                            const employeeId = row.employeeId?.trim();
                            const staffName = row.staffName?.trim();
                            const shopName = row.shop?.trim();
                            const statusState = row.statusState?.trim();
                            
                            if ((!employeeId && !staffName) || !row.date || !statusState || row.amount === undefined) {
                                errors.push(`Row ${rowNum}: Missing required data (employeeId/staffName, shop, date, statusState, amount).`);
                                return;
                            }
                            
                            let employee;
                            // Prioritize finding employee by ID for accuracy
                            if (employeeId && employeeId !== '(Optional)') {
                                employee = employees.find(e => e.id === employeeId && e.status === 'Active');
                                if (!employee) {
                                    errors.push(`Row ${rowNum}: Active employee with ID "${employeeId}" not found.`);
                                    return;
                                }
                            } else {
                                // Fallback to name if ID is not provided
                                employee = employees.find(e => e.name.toLowerCase() === staffName.toLowerCase() && e.status === 'Active');
                                if (!employee) {
                                    errors.push(`Row ${rowNum}: Active staff member "${staffName}" not found.`);
                                    return;
                                }
                            }

                            if (statusState !== 'Engagement' && statusState !== 'Deduction') {
                                errors.push(`Row ${rowNum}: Invalid statusState "${statusState}". Must be 'Engagement' or 'Deduction'.`);
                                return;
                            }
                            
                            const targetShop = shopName || (Array.isArray(employee.shop) ? employee.shop[0] : employee.shop);
                            if (!targetShop) {
                                errors.push(`Row ${rowNum}: Shop for "${employee.name}" could not be determined. Please specify a shop in the template or employee profile.`);
                                return;
                            }
                             // Validate that the shop from the file is one of the employee's assigned shops
                            const employeeShops = Array.isArray(employee.shop) ? employee.shop : [employee.shop];
                            if (!employeeShops.includes(targetShop)) {
                                errors.push(`Row ${rowNum}: Shop "${targetShop}" is not an assigned shop for ${employee.name}.`);
                                return;
                            }

                            const newRecord = {
                                staffId: employee.id, staffName: employee.name,
                                shop: targetShop,
                                date: row.date, statusState: statusState,
                                amount: parseFloat(row.amount) || 0,
                                note: row.note || '',
                                status: statusState === 'Engagement' ? 'Pending' : 'Approved'
                            };
                            
                            const newDocRef = doc(collection(db, 'employeeStates'));
                            batch.set(newDocRef, newRecord);
                            successCount++;
                        });

                        if (errors.length > 0) {
                            setImportResult({ success: false, message: `Import failed with ${errors.length} error(s):`, errors });
                        } else if (successCount > 0) {
                            await batch.commit();
                            setImportResult({ success: true, message: `Successfully imported ${successCount} records.` });
                        } else {
                             setImportResult({ success: false, message: 'No valid records found to import.' });
                        }
                    } catch (error) {
                        console.error("Error processing Excel file:", error);
                        setImportResult({ success: false, message: `An error occurred during import: ${error.message}` });
                    } finally {
                        setIsImporting(false);
                    }
                };
                reader.readAsArrayBuffer(file);
            };

            const handleExportExcel = useCallback(() => {
                const dataToExport = filteredRecords.map(rec => ({
                    'Date': rec.date,
                    'Shop': rec.shop,
                    'Staff Name': rec.staffName,
                    'Status': rec.statusState,
                    'Amount (KHR)': parseFloat(String(rec.amount).replace(/[^0-9.-]/g, '')) || 0,
                    'Reason / Note': rec.note,
                }));
                const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "Employee States");
                
                worksheet["!cols"] = [ { wch: 12 }, { wch: 15 }, { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 40 } ];
                
                const fileName = filterMode === 'month'
                    ? `Employee_State_Report_${selectedMonth}.xlsx`
                    : `Employee_State_Report_${selectedDate}.xlsx`;
                XLSX.writeFile(workbook, fileName);
            }, [filteredRecords, selectedMonth, selectedDate, filterMode]);
            
            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h3 className="text-xl font-semibold text-slate-100">Engagements / Deductions</h3>
                        <div className="flex flex-wrap gap-4 items-center">
                             {(userProfile.role === 'Admin' || (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop))) && (
                                <select value={selectedShop} onChange={e => { setSelectedShop(e.target.value); setSelectedEmployeeId(''); }} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            {(userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') && selectedShop && (
                                <select value={selectedEmployeeId} onChange={e => setSelectedEmployeeId(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">All Staff</option>
                                    {employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
                                </select>
                            )}
                            <select value={filterMode} onChange={e => setFilterMode(e.target.value)} className="select w-full sm:w-auto">
                                <option value="month">Filter by Month</option>
                                <option value="date">Filter by Date</option>
                            </select>
                            {filterMode === 'month' ? (
                                <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                            ) : (
                                <input type="date" value={selectedDate} onChange={e => setSelectedDate(e.target.value)} className="input w-full sm:w-auto" />
                            )}
                            {(userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager') && (
                                <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add New</Button>
                            )}
                            {userProfile?.role === 'Admin' && (
                                <>
                                    <input
                                        type="file"
                                        ref={fileInputRef}
                                        onChange={handleFileChange}
                                        className="hidden"
                                        accept=".xlsx, .xls"
                                    />
                                    <Button 
                                        variant="secondary" 
                                        icon="fa-download"
                                        onClick={handleDownloadTemplate}
                                    >
                                        Template
                                    </Button>
                                    <Button 
                                        variant="secondary" 
                                        icon="fa-upload"
                                        onClick={triggerFileUpload}
                                        disabled={isImporting}
                                    >
                                        {isImporting ? 'Importing...' : 'Import'}
                                    </Button>
                                </>
                            )}
                             <Button variant="success" icon="fa-file-excel" onClick={handleExportExcel}>Excel</Button>
                        </div>
                    </div>
                    {/* Desktop Table */}
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Date</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Staff</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Type</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Amount</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Reason</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th><th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead><tbody className="divide-y divide-slate-700">{filteredRecords.map(record => (<tr key={record.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{record.isVirtual ? selectedMonth : record.date}</td><td className="px-4 py-4 text-sm text-slate-300">{record.shop}</td><td className="px-4 py-4 text-sm text-slate-300">{record.staffName}</td><td className="px-4 py-4 text-sm text-slate-300">{record.statusState}</td><td className={`px-4 py-4 text-sm text-right font-semibold ${record.note?.includes('Penalty') ? 'text-red-400' : 'text-slate-300'}`}>{Utils.formatCurrency(record.amount)}</td><td className="px-4 py-4 text-sm text-slate-300">{record.note}</td><td className="px-4 py-4 text-center text-sm">{record.statusState === 'Engagement' && (<span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${ record.status === 'Approved' ? 'bg-green-100 text-green-800' : record.status === 'Rejected' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800' }`}>{record.status || 'Pending'}</span>)}</td><td className="px-4 py-4 text-center whitespace-nowrap"><div className="flex items-center justify-center gap-4">
                                            {/* REVISED: Only Admin/CEO can approve/reject */}
                                            {!record.isVirtual && (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && record.statusState === 'Engagement' && record.status === 'Pending' && (<><Button variant="icon-approve" icon="fa-check-circle" onClick={() => handleUpdateStatus(record.id, 'Approved')} title="Approve" /><Button variant="icon-reject" icon="fa-times-circle" onClick={() => handleUpdateStatus(record.id, 'Rejected')} title="Reject" /></>)}
                                            
                                            {/* REVISED: Only Admin/CEO can edit/delete */}
                                            {!record.isVirtual && (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') && (<><Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(record)} title="Edit" /><Button variant="icon-delete" icon="fa-trash" onClick={() => setRecordToDelete(record)} title="Delete" /></>)}
                                        </div></td></tr>))}</tbody></table></div>
                    <EmployeeStateModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSave} record={editingRecord} userProfile={userProfile} />
                    <ConfirmationModal isOpen={!!recordToDelete} onClose={() => setRecordToDelete(null)} onConfirm={handleDelete} title="Delete Record" message="Are you sure you want to delete this record?" />
                    {/* NEW: Modal to show import results */}
                    <Modal isOpen={!!importResult} onClose={() => setImportResult(null)} maxWidth="max-w-2xl">
                        <ModalHeader title="Import Result" onClose={() => setImportResult(null)} />
                        <ModalBody>
                            {importResult && (
                                <div>
                                    <p className={`font-bold ${importResult.success ? 'text-green-400' : 'text-red-400'}`}>
                                        {importResult.message}
                                    </p>
                                    {importResult.errors && (
                                        <ul className="mt-4 list-disc list-inside space-y-1 text-slate-300 bg-slate-700 p-4 rounded-md max-h-60 overflow-y-auto">
                                            {importResult.errors.map((err, i) => <li key={i}>{err}</li>)}
                                        </ul>
                                    )}
                                </div>
                            )}
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="primary" onClick={() => setImportResult(null)}>Close</Button>
                        </ModalFooter>
                    </Modal>
                </Card>
            );
        };

        const EmployeeStateModal = ({ isOpen, onClose, onSave, record, userProfile }) => {
            const [formData, setFormData] = useState({});
            const [selectedShop, setSelectedShop] = useState('');
            
            // REFACTORED: Get global data from App Data Context.
            const { shops, employees } = useAppData();

            const availableShops = useMemo(() => {
                if (!userProfile) return [];
                if (userProfile.role === 'Admin') return shops
                const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                if (managedShops.length > 0) {
                    return shops.filter(s => managedShops.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const canSelectShop = useMemo(() => {
                if (!userProfile) return false;
                if (userProfile.role === 'Admin') return true;
                if (userProfile.role === 'Shop Manager' && Array.isArray(userProfile.shop) && userProfile.shop.length > 1) return true;
                return false;
            }, [userProfile]);

            useEffect(() => {
                let initialShop = '';
                if (!record && userProfile) { // Set default shop for NEW records based on user profile
                     if (userProfile.role !== 'Admin') {
                        const managedShops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                        if (managedShops.length === 1) {
                            initialShop = managedShops[0];
                        }
                     }
                }

                const initialData = record 
                    ? { ...record } 
                    : { date: new Date().toISOString().substring(0, 10), shop: initialShop, staffId: '', statusState: 'Deduction', amount: '', note: '' };
                
                setFormData(initialData);
                setSelectedShop(initialData.shop || '');
            }, [record, isOpen, userProfile]);
            
            const employeesInShop = useMemo(() => {
                if (!selectedShop) return [];
                return employees.filter(emp => {
                    const employeeShops = Array.isArray(emp.shop) ? emp.shop : [emp.shop];
                    return employeeShops.includes(selectedShop) && emp.status === 'Active';
                });
            }, [selectedShop, employees]);
            
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
                if (name === 'shop') { 
                    setSelectedShop(value); 
                    setFormData(prev => ({ ...prev, staffId: '' })); // Reset staff selection when shop changes
                }
            };

            const handleSubmit = (e) => { 
                e.preventDefault(); 
                if (!formData.shop || !formData.staffId || !formData.amount) { 
                    alert("Please fill all required fields."); 
                    return; 
                } 
                onSave(formData); 
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose}>
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={record ? "Edit Record" : "Add New Record"} onClose={onClose} />
                        <ModalBody>
                            <div className="space-y-4">
                                <div><label className="text-sm">Date</label><input type="date" name="date" value={formData.date || ''} onChange={handleChange} className="input"/></div>
                                <div>
                                    <label className="text-sm">Shop</label>
                                    <select name="shop" value={formData.shop || ''} onChange={handleChange} className="select" disabled={!canSelectShop}>
                                        <option value="">Select Shop</option>
                                        {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                    </select>
                                </div>
                                <div><label className="text-sm">Staff</label><select name="staffId" value={formData.staffId || ''} onChange={handleChange} className="select" disabled={!selectedShop}><option value="">Select Staff</option>{employeesInShop.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}</select></div>
                                <div><label className="text-sm">Status State</label><select name="statusState" value={formData.statusState || 'Deduction'} onChange={handleChange} className="select"><option>Deduction</option><option>Engagement</option></select></div>
                                <div><label className="text-sm">Amount (KHR)</label><input type="number" name="amount" value={formData.amount || ''} onChange={handleChange} className="input"/></div>
                                <div><label className="text-sm">Reason / Note</label><textarea name="note" value={formData.note || ''} onChange={handleChange} className="input" rows="3"></textarea></div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary" className="px-6">Save Record</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        // --- END PAYROLL PAGE ---

        // --- START EXPENSE REPORT PAGE ---
        const ExpenseReportPage = ({ userProfile }) => {
            const { where } = window.firebaseSDK;
            
            const payrollQueryConstraints = useMemo(() => {
                if (!userProfile) return [where("shop", "==", "null")];
                if (userProfile.role === 'Admin' || userProfile.role === 'CEO') return [];
                if (userProfile.role === 'Shop Manager') {
                    const shops = Array.isArray(userProfile.shop) ? userProfile.shop : (userProfile.shop ? [userProfile.shop] : []);
                    if (shops.length > 0) return [where("shop", "in", shops)];
                    return [where("shop", "==", "null")];
                }
                return [where("shop", "==", "null")];
            }, [userProfile]);

            const { data: payrollHistory } = useCollection('payrollHistory', payrollQueryConstraints);
            const { data: shops } = useCollection('shops');
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            
            useEffect(() => {
                if (userProfile && userProfile.role !== 'Admin' && userProfile.role !== 'CEO') {
                    setSelectedShop(Array.isArray(userProfile.shop) ? '' : userProfile.shop || '');
                }
            }, [userProfile]);

            const availableShops = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return shops;
                if (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop)) {
                    return shops.filter(s => userProfile.shop.includes(s.name));
                }
                return [];
            }, [shops, userProfile]);

            const { expenseSummary, totals } = useMemo(() => {
                if (!payrollHistory.length) return { expenseSummary: [], totals: {} };
                const filteredHistory = payrollHistory.filter(rec => (!selectedShop || rec.shop === selectedShop) && (!selectedMonth || rec.month === selectedMonth));
                
                const summary = filteredHistory.reduce((acc, rec) => {
                    if (!rec.shop || !rec.month) return acc;
                    const key = `${rec.shop}_${rec.month}`;
                    if (!acc[key]) { acc[key] = { month: rec.month, shopName: rec.shop, totalLoanDed: 0, totalOtherDed: 0, totalSavingsDed: 0, totalSavingsPayback: 0, totalFinalSalary: 0 }; }
                    acc[key].totalLoanDed += parseFloat(rec.manualInputs?.loanDeduction) || 0;
                    acc[key].totalOtherDed += parseFloat(rec.calculations?.otherDeductions) || 0;
                    acc[key].totalSavingsDed += parseFloat(rec.calculations?.savingsDeduction) || 0;
                    acc[key].totalSavingsPayback += parseFloat(rec.calculations?.totalSavingsWithdrawal) || 0;
                    acc[key].totalFinalSalary += parseFloat(rec.netSalary) || 0;
                    return acc;
                }, {});

                const summaryArray = Object.values(summary).map(item => {
                    // FIX: The Account Note was double-counting savings payback.
                    // Savings Payback is already included in the 'totalFinalSalary' (as it's part of Gross Salary).
                    // We must remove it from this sum to prevent double-counting.
                    const accountNote = (item.totalFinalSalary || 0) + (item.totalLoanDed || 0) + (item.totalOtherDed || 0) + (item.totalSavingsDed || 0);
                    return { ...item, accountNote };
                }).sort((a, b) => b.month.localeCompare(a.month) || a.shopName.localeCompare(b.shopName));

                const totals = summaryArray.reduce((acc, curr) => { 
                    acc.totalLoanDed += curr.totalLoanDed; 
                    acc.totalOtherDed += curr.totalOtherDed; 
                    acc.totalSavingsDed += curr.totalSavingsDed;
                    acc.totalSavingsPayback += curr.totalSavingsPayback;
                    acc.totalFinalSalary += curr.totalFinalSalary; 
                    acc.totalAccountNote += curr.accountNote;
                    return acc; 
                }, { totalLoanDed: 0, totalOtherDed: 0, totalSavingsDed: 0, totalSavingsPayback: 0, totalFinalSalary: 0, totalAccountNote: 0 });
                
                return { expenseSummary: summaryArray, totals };
            }, [payrollHistory, selectedShop, selectedMonth]);
            
            const canFilterByShop = userProfile?.role === 'Admin' || userProfile?.role === 'CEO' || (userProfile?.role === 'Shop Manager' && Array.isArray(userProfile.shop));

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <CardTitle>Expense Report Summary</CardTitle>
                        <div className="flex flex-wrap gap-4 items-center">
                            {canFilterByShop && (
                                <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select w-full sm:w-auto">
                                    <option value="">{userProfile.role === 'Admin' || userProfile.role === 'CEO' ? 'All Shops' : 'All My Shops'}</option>
                                    {availableShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                                </select>
                            )}
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input w-full sm:w-auto" />
                        </div>
                    </div>
                    <div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Month</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Shop Name</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Loan Ded.</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Other Ded.</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Saving Program</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Savings Payback</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Total Final Salary</th><th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Account Note</th></tr></thead><tbody className="divide-y divide-slate-700">{expenseSummary.map((item, index) => (<tr key={index} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200">{item.month}</td><td className="px-4 py-4 text-sm text-slate-300">{item.shopName}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalLoanDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalOtherDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalSavingsDed)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right">{Utils.formatCurrency(item.totalSavingsPayback)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(item.totalFinalSalary)}</td><td className="px-4 py-4 text-sm text-slate-300 text-right font-semibold">{Utils.formatCurrency(item.accountNote)}</td></tr>))}</tbody><tfoot className="bg-slate-900/50"><tr><td colSpan="2" className="px-4 py-3 text-right font-bold text-slate-300 uppercase">Sub-Total</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalLoanDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalOtherDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalSavingsDed)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalSavingsPayback)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalFinalSalary)}</td><td className="px-4 py-3 text-right font-bold text-slate-300">{Utils.formatCurrency(totals.totalAccountNote)}</td></tr></tfoot></table></div>
                </Card>
            );
        };
        // --- END EXPENSE REPORT PAGE ---

        // --- START POLICY BOARD PAGE ---
        const PolicyModal = memo(({ isOpen, onClose, onSave, policy }) => {
            const [formData, setFormData] = useState({});
            const quillRef = useRef(null);
            const quillInstanceRef = useRef(null);
        
            // This useEffect now correctly handles both the CREATION and DESTRUCTION of the Quill editor instance,
            // syncing its lifecycle with the modal's `isOpen` state.
            useEffect(() => {
                // 1. CREATION LOGIC: This runs only when the modal opens (`isOpen` is true).
                if (isOpen) {
                    const initialData = policy ? { ...policy } : { title: '', category: 'General', content: '' };
                    setFormData(initialData);
        
                    // We create the editor instance only if the container element exists and an instance doesn't already.
                    if (quillRef.current && !quillInstanceRef.current) {
                        quillInstanceRef.current = new Quill(quillRef.current, {
                            theme: 'snow',
                            modules: {
                                toolbar: [
                                    [{ 'header': [1, 2, 3, false] }],
                                    ['bold', 'italic', 'underline', 'strike'],
                                    [{ 'color': [] }, { 'background': [] }],
                                    [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                    [{ 'align': [] }],
                                    ['link', 'blockquote', 'code-block'],
                                    ['clean']
                                ]
                            },
                            placeholder: 'Compose the policy content here...',
                        });
        
                        // Attach the listener to update our React state as the user types.
                        quillInstanceRef.current.on('text-change', (delta, oldDelta, source) => {
                            if (source === 'user') {
                                setFormData(prev => ({ ...prev, content: quillInstanceRef.current.root.innerHTML }));
                            }
                        });

                        // Set the initial content when the editor is first created.
                        const editor = quillInstanceRef.current;
                        const newContent = initialData.content || '';
                        // Convert HTML to Quill's native 'Delta' format for the most reliable way to set content.
                        const delta = editor.clipboard.convert(newContent);
                        editor.setContents(delta, 'silent');
                    }
                }
        
                // 2. DESTRUCTION LOGIC (THE FIX): This cleanup function runs when the modal closes (when `isOpen` becomes false).
                return () => {
                    if (quillInstanceRef.current) {
                        // Destroy the Quill instance and release its resources.
                        quillInstanceRef.current = null;
                        // Manually clear the DOM element to prevent leftover Quill UI from appearing on the next open.
                        if (quillRef.current) {
                            quillRef.current.innerHTML = '';
                        }
                    }
                };
            }, [isOpen, policy]); // This effect correctly depends on `isOpen` to manage the lifecycle.
        
            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            }, []);
        
            const handleSubmit = useCallback(() => {
                onSave(formData);
            }, [onSave, formData]);
        
            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <ModalHeader title={policy ? "Edit Policy" : "Add New Policy"} onClose={onClose} />
                    <ModalBody>
                        <div className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Title</label>
                                    <input name="title" value={formData.title || ''} onChange={handleChange} className="input" required />
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Category</label>
                                    <input name="category" value={formData.category || ''} onChange={handleChange} className="input" placeholder="e.g., General, Leave" required />
                                </div>
                            </div>
                            <div>
                                <label className="text-sm font-medium text-slate-400">Content</label>
                                <div className="bg-slate-100 text-slate-900 mt-1 rounded-lg overflow-hidden border border-slate-600">
                                    <div ref={quillRef} style={{ height: '300px' }}></div>
                                </div>
                            </div>
                        </div>
                    </ModalBody>
                    <ModalFooter>
                        <Button variant="secondary" onClick={onClose}>Cancel</Button>
                        <Button type="button" variant="primary" onClick={handleSubmit}>Save Policy</Button>
                    </ModalFooter>
                </Modal>
            );
        });

        // NEW: Modal for reading a policy's content
        const PolicyReadModal = ({ isOpen, onClose, policy }) => {
            if (!policy) return null;

            // FIX (Bug #1): Sanitize HTML content before rendering to prevent XSS attacks.
            // This uses the DOMPurify library to strip out any potentially malicious code
            // like <script> tags or onerror attributes, while keeping safe formatting.
            const sanitizedContent = window.DOMPurify ? window.DOMPurify.sanitize(policy.content) : policy.content;

            const formatTimestamp = (timestamp) => {
                if (!timestamp || !timestamp.toDate) return 'N/A';
                return timestamp.toDate().toLocaleDateString('en-GB');
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-4xl">
                    <ModalHeader title={policy.title} onClose={onClose} />
                    <ModalBody>
                        <div className="policy-content" dangerouslySetInnerHTML={{ __html: sanitizedContent }}></div>
                    </ModalBody>
                    <ModalFooter>
                        <div className="flex justify-between w-full items-center">
                            <span className="text-xs text-slate-500">Last updated: {formatTimestamp(policy.updatedAt || policy.createdAt)}</span>
                            <Button variant="secondary" onClick={onClose}>Close</Button>
                        </div>
                    </ModalFooter>
                </Modal>
            );
        };

        const PolicyBoardPage = ({ userProfile }) => {
            const { db } = useFirebase();
            const { data: policies, loading } = useCollection('policies');
            const [searchTerm, setSearchTerm] = useState('');
            const [isModalOpen, setModalOpen] = useState(false);
            const [editingPolicy, setEditingPolicy] = useState(null);
            const [policyToDelete, setPolicyToDelete] = useState(null);
            const [policyToRead, setPolicyToRead] = useState(null); // State for the read modal

            const isAdmin = userProfile?.role === 'Admin';

            const categorizedPolicies = useMemo(() => {
                const filtered = policies.filter(p =>
                    (p.title?.toLowerCase() || '').includes(searchTerm.toLowerCase()) ||
                    (p.content?.toLowerCase() || '').includes(searchTerm.toLowerCase())
                );

                const grouped = filtered.reduce((acc, policy) => {
                    const category = policy.category || 'General';
                    if (!acc[category]) {
                        acc[category] = [];
                    }
                    acc[category].push(policy);
                    return acc;
                }, {});

                for (const category in grouped) {
                    grouped[category].sort((a, b) => a.title.localeCompare(b.title));
                }
                return grouped;
            }, [policies, searchTerm]);

            const sortedCategories = useMemo(() => Object.keys(categorizedPolicies).sort(), [categorizedPolicies]);

            const handleOpenModal = useCallback((policy = null) => { setEditingPolicy(policy); setModalOpen(true); }, []);
            const handleCloseModal = useCallback(() => { setEditingPolicy(null); setModalOpen(false); }, []);
            
            // Handlers for the new read modal
            const handleReadPolicy = useCallback((policy) => { setPolicyToRead(policy); }, []);
            const handleCloseReadModal = useCallback(() => { setPolicyToRead(null); }, []);

            const handleSavePolicy = useCallback(async (policyData) => {
                const { addDoc, updateDoc, doc, collection, serverTimestamp } = window.firebaseSDK;
                const dataToSave = { ...policyData };
                try {
                    if (dataToSave.id) {
                        const { id, ...data } = dataToSave;
                        await updateDoc(doc(db, 'policies', id), { ...data, updatedAt: serverTimestamp() });
                    } else {
                        await addDoc(collection(db, 'policies'), { ...dataToSave, createdAt: serverTimestamp(), updatedAt: serverTimestamp() });
                    }
                    handleCloseModal();
                } catch (error) {
                    console.error("Error saving policy:", error);
                }
            }, [db, handleCloseModal]);

            const handleDeleteConfirm = useCallback(async () => {
                if (!policyToDelete) return;
                try {
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'policies', policyToDelete.id));
                } catch (error) {
                    console.error("Error deleting policy:", error);
                } finally {
                    setPolicyToDelete(null);
                }
            }, [db, policyToDelete]);

            return (
                <Card>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        {/* The CardTitle component was here and has been removed to fix the duplication. */}
                        <div className="flex flex-wrap gap-4 items-center w-full justify-end">
                            <input type="text" placeholder="Search policies..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="input w-full sm:w-auto" />
                            {isAdmin && <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add Policy</Button>}
                        </div>
                    </div>
                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i></div>
                    ) : (
                        <div className="space-y-6">
                            {sortedCategories.length > 0 ? sortedCategories.map(category => (
                                <div key={category}>
                                    <h3 className="text-xl font-semibold text-slate-100 mb-3 border-b border-slate-700 pb-2">{category}</h3>
                                    {/* FIX: Changed from <ul> to <ol> and updated child elements for proper numbering */}
                                    <ol className="space-y-2 list-decimal list-inside">
                                        {categorizedPolicies[category].map(policy => (
                                            <li key={policy.id} className="p-3 rounded-lg bg-slate-800 hover:bg-slate-700/50 transition-colors">
                                                <span className="inline-flex justify-between items-center w-full">
                                                    <button onClick={() => handleReadPolicy(policy)} className="flex-grow text-left group">
                                                        <span className="font-medium text-slate-200 group-hover:text-blue-400 transition-colors">{policy.title}</span>
                                                    </button>
                                                    {isAdmin && (
                                                        <div className="flex space-x-3 flex-shrink-0 ml-4">
                                                            <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(policy)} title="Edit Policy"/>
                                                            <Button variant="icon-delete" icon="fa-trash" onClick={() => setPolicyToDelete(policy)} title="Delete Policy"/>
                                                        </div>
                                                    )}
                                                </span>
                                            </li>
                                        ))}
                                    </ol>
                                </div>
                            )) : (
                                <div className="text-center py-10 text-slate-400">
                                    <i className="fas fa-file-alt text-4xl mb-4"></i>
                                    <p>No policies found matching your search.</p>
                                </div>
                            )}
                        </div>
                    )}
                    <PolicyModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSavePolicy} policy={editingPolicy} />
                    <ConfirmationModal isOpen={!!policyToDelete} onClose={() => setPolicyToDelete(null)} onConfirm={handleDeleteConfirm} title="Delete Policy" message={`Are you sure you want to delete the policy "${policyToDelete?.title}"? This action cannot be undone.`} />
                    <PolicyReadModal isOpen={!!policyToRead} onClose={handleCloseReadModal} policy={policyToRead} />
                </Card>
            );
        };
        // --- END POLICY BOARD PAGE ---

        // --- START USER ACTIVITY PAGE ---
        const UserActivityPage = () => {
            const { db } = useFirebase();
            const { data: employees } = useCollection('employees');
            const employeeNameMap = useMemo(() => employees.reduce((acc, emp) => { if (emp.uid) acc[emp.uid] = emp.name; return acc; }, {}), [employees]);
            
            const [logs, setLogs] = useState([]);
            const [loading, setLoading] = useState(true);
            const [currentPage, setCurrentPage] = useState(1);
            const [pageCursors, setPageCursors] = useState({ 1: null }); // Store cursors in an object: { pageNum: cursorDoc }
            const [hasNextPage, setHasNextPage] = useState(false);
            const itemsPerPage = 15;

            // Helper function to safely format Firestore timestamps or other date formats
            const formatTimestamp = (timestamp) => {
                if (!timestamp) return 'No date';
                if (typeof timestamp.toDate === 'function') { return timestamp.toDate().toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }); }
                const date = new Date(timestamp);
                if (!isNaN(date.getTime())) { return date.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }); }
                return 'Invalid Date';
            };

            // REFACTORED: Data fetching logic is now self-contained within this effect.
            // It only re-runs when the database connection is ready or the page number changes.
            useEffect(() => {
                if (!db) return;

                const fetchLogsForPage = async () => {
                    setLoading(true);
                    const { collection, query, orderBy, limit, startAfter, getDocs } = window.firebaseSDK;
                    
                    // The cursor for the current page is the last document of the *previous* page.
                    const cursor = pageCursors[currentPage - 1];
                    
                    let q = query(
                        collection(db, 'userLogs'),
                        orderBy('timestamp', 'desc'),
                        limit(itemsPerPage + 1)
                    );

                    if (cursor) {
                        q = query(q, startAfter(cursor));
                    }
                    
                    try {
                        const documentSnapshots = await getDocs(q);
                        
                        setHasNextPage(documentSnapshots.docs.length > itemsPerPage);
                        
                        const newLogs = documentSnapshots.docs.slice(0, itemsPerPage).map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setLogs(newLogs);

                        // If there are logs, store the last one as the cursor for the CURRENT page,
                        // which will be used to fetch the NEXT page.
                        if (documentSnapshots.docs.length > 0) {
                            const lastVisible = documentSnapshots.docs[newLogs.length - 1];
                            if (lastVisible) {
                                setPageCursors(prev => ({ ...prev, [currentPage]: lastVisible }));
                            }
                        }
                    } catch (error) {
                        console.error("Error fetching user logs:", error);
                    } finally {
                        setLoading(false);
                    }
                };

                fetchLogsForPage();
            }, [db, currentPage]); // This dependency array is the key to the fix.

            const handleNext = () => {
                if (hasNextPage) {
                    setCurrentPage(prev => prev + 1);
                }
            };
            const handlePrevious = () => {
                if (currentPage > 1) {
                    setCurrentPage(prev => prev - 1);
                }
            };
            
            // Function to format log details for better readability
            const formatActivityDetails = (log) => {
                const { originalData, updatedData, action } = log;
                if (action === 'Add Employee' || action === 'Delete Employee') {
                    return `Details for ${log.targetName}`;
                }
                if (originalData && updatedData) {
                    const changes = [];
                    const allKeys = new Set([...Object.keys(originalData), ...Object.keys(updatedData)]);
                    
                    const formatValue = (val) => {
                        if (val === undefined || val === null) return 'empty';
                        if (Array.isArray(val)) return `[${val.join(', ')}]`;
                        // Handle objects gracefully to avoid "[object Object]"
                        if (typeof val === 'object' && val !== null) return JSON.stringify(val);
                        return String(val);
                    };

                    allKeys.forEach(key => {
                        if (key === 'id') return;
                        const originalValue = formatValue(originalData[key]);
                        const updatedValue = formatValue(updatedData[key]);
                        if (originalValue !== updatedValue) {
                            changes.push(`${key}: from '${originalValue}' to '${updatedValue}'`);
                        }
                    });
                    return changes.length > 0 ? changes.join('; ') : 'No detailed changes detected.';
                }
                return log.action || 'Unknown Action';
            };
            
            return (
                <Card>
                    <CardTitle>User Activity Log</CardTitle>
                    {loading ? (
                         <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl text-blue-400"></i><p className="mt-2 text-slate-400">Loading Logs...</p></div>
                    ) : (
                        <>
                            <div className="overflow-x-auto">
                                <table className="min-w-full divide-y divide-slate-700">
                                    <thead className="bg-slate-900/50"><tr><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Timestamp</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">User</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Action</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Target</th><th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Activity Details</th></tr></thead>
                                    <tbody className="divide-y divide-slate-700">
                                        {logs.map(log => (<tr key={log.id} className="hover:bg-slate-700/50"><td className="px-4 py-4 text-sm text-slate-200 whitespace-nowrap">{formatTimestamp(log.timestamp)}</td><td className="px-4 py-4 text-sm text-slate-300">{employeeNameMap[log.userId] || log.userId}</td><td className="px-4 py-4 text-sm text-slate-300">{log.action}</td><td className="px-4 py-4 text-sm text-slate-300">{log.targetName || 'N/A'}</td><td className="px-4 py-4 text-sm text-slate-300">{formatActivityDetails(log)}</td></tr>))}
                                    </tbody>
                                </table>
                            </div>
                            <div className="mt-6 flex justify-between items-center">
                                <Button variant="secondary" onClick={handlePrevious} disabled={currentPage === 1 || loading}>
                                    Previous
                                </Button>
                                <span className="text-sm text-slate-400">Page {currentPage}</span>
                                <Button variant="secondary" onClick={handleNext} disabled={!hasNextPage || loading}>
                                    Next
                                </Button>
                            </div>
                        </>
                    )}
                </Card>
            );
        };
        // --- END USER ACTIVITY PAGE ---

        // --- START SETTINGS PAGE ---
        
        // --- START DATA MIGRATION TAB (TEMP) ---
        // This component is for Step 2 of the refactor plan. It should be removed after use.
        /* REMOVED: The entire 'DataMigrationTab' component (approximately 110 lines) 
            was here. It has been deleted as requested.
        */
        // --- END DATA MIGRATION TAB (TEMP) ---

        // NEW: Modal for adding/editing scheduled memos
        const MemoAlertModal = ({ isOpen, onClose, onSave, memo }) => {
            const [formData, setFormData] = useState({});
            // NEW: Get shops from the app context
            const { shops } = useAppData();

            useEffect(() => {
                if (isOpen) {
                    // Set default values for a new memo
                    const initialData = memo 
                        ? { ...memo, targetShops: memo.targetShops || [] } // Ensure targetShops is an array when editing
                        : { 
                            title: '', 
                            content: '', 
                            startTime: '07:30', 
                            endTime: '16:00', 
                            status: 'Active', 
                            targetShops: [] // REVISED: Replaced targetRole with targetShops array
                          };
                    setFormData(initialData);
                }
            }, [memo, isOpen]);

            const handleChange = (e) => {
                const { name, value, type, checked } = e.target;
                
                // REVISED: Handle the new targetShops checkbox array
                if (name === 'targetShops') {
                    setFormData(prev => {
                        const shopArray = Array.isArray(prev.targetShops) ? prev.targetShops : [];
                        const newShops = checked ? [...shopArray, value] : shopArray.filter(s => s !== value);
                        return { ...prev, targetShops: newShops };
                    });
                } else {
                    setFormData(prev => ({ ...prev, [name]: value }));
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                // REVISED: Updated validation
                if (!formData.title || !formData.content || !formData.startTime || !formData.endTime) {
                    alert("Please fill in title, content, start time, and end time.");
                    return;
                }
                if (formData.endTime <= formData.startTime) {
                    alert("End Time must be after Start Time.");
                    return;
                }
                onSave(formData);
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} maxWidth="max-w-xl">
                    <form onSubmit={handleSubmit}>
                        <ModalHeader title={memo ? "Edit Memo" : "Add New Memo"} onClose={onClose} />
                        <ModalBody>
                            {/* REVISED: Updated layout for new shop selector */}
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Memo Title</label>
                                    <input name="title" value={formData.title || ''} onChange={handleChange} className="input" required />
                                </div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Start Time</label>
                                        <input type="time" name="startTime" value={formData.startTime || ''} onChange={handleChange} className="input" required />
                                    </div>
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">End Time</label>
                                        <input type="time" name="endTime" value={formData.endTime || ''} onChange={handleChange} className="input" required />
                                    </div>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Status</label>
                                        <select name="status" value={formData.status || 'Active'} onChange={handleChange} className="select" required>
                                            <option value="Active">Active</option>
                                            <option value="Inactive">Inactive</option>
                                        </select>
                                    </div>
                                    {/* REVISED: Replaced Role selector with Shop selector */}
                                    <div>
                                        <label className="text-sm font-medium text-slate-400">Target Shops (Select none for "All Shops")</label>
                                        <div className="mt-1 p-2 border border-slate-600 rounded-lg bg-slate-700/50 max-h-32 overflow-y-auto">
                                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                                                {(shops || []).sort((a,b) => a.name.localeCompare(b.name)).map(shop => (
                                                    <div key={shop.id} className="flex items-center">
                                                        <input 
                                                            id={`shop-memo-${shop.id}`} 
                                                            name="targetShops" 
                                                            type="checkbox" 
                                                            value={shop.name} 
                                                            checked={(Array.isArray(formData.targetShops) ? formData.targetShops : []).includes(shop.name)} 
                                                            onChange={handleChange} 
                                                            className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600"
                                                        />
                                                        <label htmlFor={`shop-memo-${shop.id}`} className="ml-2 text-sm text-slate-300 truncate" title={shop.name}>{shop.name}</label>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label className="text-sm font-medium text-slate-400">Content</label>
                                    <textarea
                                        name="content"
                                        rows="6"
                                        className="input"
                                        value={formData.content || ''}
                                        onChange={handleChange}
                                        placeholder="Enter memo content..."
                                        required
                                    ></textarea>
                                </div>
                            </div>
                        </ModalBody>
                        <ModalFooter>
                            <Button variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" variant="primary">Save Memo</Button>
                        </ModalFooter>
                    </form>
                </Modal>
            );
        };
        
        // REVISED: This component is now a full CRUD manager for the `memoAlerts` collection
        const MemoAlertTab = () => {
            const { db } = useFirebase();
            // Use the new `memoAlerts` collection
            const { data: memos, loading } = useCollection('memoAlerts');
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingMemo, setEditingMemo] = useState(null);
            const [memoToDelete, setMemoToDelete] = useState(null);

            const handleOpenModal = (memo = null) => {
                setEditingMemo(memo);
                setIsModalOpen(true);
            };
            const handleCloseModal = () => {
                setEditingMemo(null);
                setIsModalOpen(false);
            };

            const handleSave = async (formData) => {
                const { addDoc, updateDoc, doc, collection, serverTimestamp } = window.firebaseSDK;
                const { id, ...dataToSave } = formData;
                
                try {
                    if (id) {
                        // Update existing memo
                        await updateDoc(doc(db, 'memoAlerts', id), { ...dataToSave, updatedAt: serverTimestamp() });
                    } else {
                        // Add new memo
                        await addDoc(collection(db, 'memoAlerts'), { ...dataToSave, createdAt: serverTimestamp() });
                    }
                    handleCloseModal();
                } catch (error) {
                    console.error("Error saving memo:", error);
                }
            };

            const handleDeleteConfirm = async () => {
                if (!memoToDelete) return;
                try {
                    // Delete memo
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, 'memoAlerts', memoToDelete.id));
                } catch (error) {
                    console.error("Error deleting memo:", error);
                } finally {
                    setMemoToDelete(null);
                }
            };

            // Sort memos by start time for a logical display
            const sortedMemos = useMemo(() => {
                if (!memos) return [];
                return [...memos].sort((a, b) => (a.startTime || '00:00').localeCompare(b.startTime || '00:00'));
            }, [memos]);

            return (
                <Card>
                    <div className="flex justify-between items-center mb-6">
                        <CardTitle>Memo Alert Management</CardTitle>
                        <Button variant="primary" icon="fa-plus" onClick={() => handleOpenModal()}>Add New Memo</Button>
                    </div>
                    {loading ? (
                        <div className="text-center py-10"><i className="fas fa-spinner fa-spin text-3xl"></i></div>
                    ) : (
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-slate-700">
                                <thead className="bg-slate-900/50">
                                    <tr>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Title</th>
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Time Window</th>
                                        {/* REVISED: Changed header from Target Role to Target Shops */}
                                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">Target Shops</th>
                                        <th className="px-4 py-3 text-center text-xs font-semibold text-slate-400 uppercase">Status</th>
                                        <th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Actions</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-700">
                                    {sortedMemos.map(memo => (
                                        <tr key={memo.id} className="hover:bg-slate-700/50">
                                            <td className="px-4 py-4 text-sm text-slate-200">{memo.title}</td>
                                            <td className="px-4 py-4 text-sm text-slate-300">{memo.startTime} to {memo.endTime}</td>
                                            {/* REVISED: Display the list of shops or "All Shops" */}
                                            <td className="px-4 py-4 text-sm text-slate-300">
                                                {(Array.isArray(memo.targetShops) && memo.targetShops.length > 0)
                                                    ? memo.targetShops.join(', ')
                                                    : 'All Shops'
                                                }
                                            </td>
                                            <td className="px-4 py-4 text-center text-sm">
                                                <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${memo.status === 'Active' ? 'bg-green-100 text-green-800' : 'bg-slate-100 text-slate-800'}`}>
                                                    {memo.status}
                                                </span>
                                            </td>
                                            <td className="px-4 py-4 text-right">
                                                <div className="flex items-center justify-end gap-4">
                                                    <Button variant="icon-edit" icon="fa-edit" onClick={() => handleOpenModal(memo)} />
                                                    <Button variant="icon-delete" icon="fa-trash" onClick={() => setMemoToDelete(memo)} />
                                                </div>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                    {/* The new modal component is used here */}
                    <MemoAlertModal isOpen={isModalOpen} onClose={handleCloseModal} onSave={handleSave} memo={editingMemo} />
                    <ConfirmationModal isOpen={!!memoToDelete} onClose={() => setMemoToDelete(null)} onConfirm={handleDeleteConfirm} title="Delete Memo" message={`Are you sure you want to delete the memo "${memoToDelete?.title}"?`} />
                </Card>
            );
        };
        const SettingsPage = ({ initialTab = 'shop' }) => {
            const { data: shops } = useCollection('shops');
            const { data: positions } = useCollection('positions');
            const { data: shifts } = useCollection('shifts');
            const [activeTab, setActiveTab] = useState(initialTab);
            // NEW: Get userProfile to conditionally show migration tab
            const { userProfile } = useFirebase(); 

            // NEW: Effect to update the active tab if the initialTab prop changes
            // This allows the Dashboard to control which tab is shown.
            useEffect(() => {
                setActiveTab(initialTab);
            }, [initialTab]);
            
            // NEW: Add migration tab only for Admins
            const tabs = useMemo(() => {
                const baseTabs = { 
                    shop: 'Shop & Shift Management', 
                    position: 'Position Management', 
                    memo: 'Memo Alert' 
                };
                // REMOVED: The logic adding the 'migration' tab has been deleted.
                return baseTabs;
            }, [userProfile]);

            // NEW: Timezone options for shop settings
            const timezoneOptions = [
                'Asia/Phnom_Penh',
                'Asia/Bangkok',
                'Asia/Ho_Chi_Minh',
                'Asia/Singapore',
                'Asia/Kuala_Lumpur',
                'Asia/Tokyo',
                'Europe/London',
                'America/New_York',
                'UTC'
            ];

            // Configuration for the generic CRUD component for Shops
            const shopFormFields = [
                { name: 'name', label: 'Shop Name', required: true }, 
                { name: 'latitude', label: 'Latitude' }, 
                { name: 'longitude', label: 'Longitude' }, 
                { name: 'radius', label: 'Radius (m)', type: 'number' }, 
                { name: 'timezone', label: 'Time Zone', type: 'select', options: timezoneOptions, required: true },
                { name: 'note', label: 'Note', fullWidth: true }
            ];

            // FIX: Define the missing column/form configurations
            const shopListColumns = [
                { header: 'Shop Name', accessor: 'name' },
                { header: 'Time Zone', accessor: 'timezone' },
                { header: 'Radius (m)', accessor: 'radius' },
                { header: 'Note', accessor: 'note' }
            ];

            const shopNames = useMemo(() => shops.map(s => s.name), [shops]);

            const shiftFormFields = [
                { name: 'shopName', label: 'Shop Name', type: 'select', options: shopNames, required: true },
                { name: 'name', label: 'Shift Name', required: true },
                { name: 'startTime', label: 'Start Time', type: 'time' },
                { name: 'endTime', label: 'End Time', type: 'time' },
                { name: 'lateThreshold', label: 'Late Threshold', type: 'time' }
            ];
            
            const shiftListColumns = [
                { header: 'Shift Name', accessor: 'name' },
                { header: 'Start Time', accessor: 'startTime' },
                { header: 'End Time', accessor: 'endTime' },
                { header: 'Late Threshold', accessor: 'lateThreshold' }
            ];

            const positionFormFields = [
                { name: 'position', label: 'Position Name', required: true }
            ];
            
            const positionListColumns = [
                { header: 'Position Name', accessor: 'position' }
            ];
            // END FIX

            return (
                // MODIFIED: Use the new dynamic tabs object
                <TabbedPage tabs={tabs} activeTab={activeTab} setActiveTab={setActiveTab}>
                    <div id="shop">
                        <SettingsCRUD title="Shop" collectionName="shops" items={shops} formFields={shopFormFields} listColumns={shopListColumns} />
                        <div className="mt-8">
                           <SettingsCRUD title="Shift" collectionName="shifts" items={shifts} formFields={shiftFormFields} listColumns={shiftListColumns} />
                        </div>
                    </div>
                    <div id="position"><SettingsCRUD title="Position" collectionName="positions" items={positions} formFields={positionFormFields} listColumns={positionListColumns} /></div>
                    {/* REVISED: Use the new memo management component */}
                    <div id="memo"><MemoAlertTab /></div>
                    {/* REMOVED: The div for the 'migration' tab has been deleted. */}
                </TabbedPage>
            );
        }

        // NEW: Component for manually triggering payroll for a whole shop
        const TriggerSalaryTab = () => {
            const { db, userProfile } = useFirebase(); // MODIFIED: Added useFirebase hook to get db
            const [selectedShop, setSelectedShop] = useState('');
            const [selectedMonth, setSelectedMonth] = useState(new Date().toISOString().slice(0, 7));
            const [triggerConfirmed, setTriggerConfirmed] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processLog, setProcessLog] = useState([]);
            const [processComplete, setProcessComplete] = useState(false);

            // Fetch all data needed for calculations in one go, using one-time fetches for efficiency
            // REMOVED: All useStaticCollection hooks have been removed from here to prevent
            // the 87,000+ reads on page load. Data will now be fetched *inside* handleTriggerPayroll.
            /*
            const { data: allShops, loading: shopsLoading } = useStaticCollection('shops');
            const { data: employees, loading: employeesLoading } = useStaticCollection('employees');
            const { data: attendance, loading: attendanceLoading } = useStaticCollection('attendance');
            ... (and so on) ...
            */

            // MODIFIED: This check is no longer needed here, as data is fetched on-demand.
            // const allDataReady = !shopsLoading && !employeesLoading && !attendanceLoading && !leaveLoading && !otLoading && !loansLoading && !statesLoading && !revisionsLoading;
            // NEW: We still need a static list of shops for the dropdown.
            const { data: allShops } = useStaticCollection('shops');


            const handleTriggerPayroll = async () => {
                // MODIFIED: Removed the 'allDataReady' check which was causing a ReferenceError
                if (!triggerConfirmed || !selectedShop || !selectedMonth) {
                    alert("Please select a shop, month, and confirm the action.");
                    return;
                }

                setIsProcessing(true);
                setProcessLog([]);
                setProcessComplete(false);

                // --- START MODIFICATION: Fetch all data on-demand ---
                setProcessLog(prev => [...prev, 'Fetching all required data... This may take a moment.']);

                // FIX 1: Added 'writeBatch', 'doc', and 'serverTimestamp' which are needed inside the processing loop.
                const { collection, getDocs, query, where, writeBatch, doc, serverTimestamp } = window.firebaseSDK;

                let allShopsData, employees, attendance, leaveRequests, otRequests, staffLoans, employeeStates, salaryRevisions;
                let savingsData;

                try {
                    const [
                        shopsSnap,
                        empSnap,
                        attSnap,
                        leaveSnap,
                        otSnap,
                        loanSnap,
                        stateSnap,
                        revSnap,
                        // MODIFIED (STEP 5): Add 'savingsSnap'
                        savingsSnap
                    ] = await Promise.all([
                        getDocs(collection(db, 'shops')),
                        getDocs(collection(db, 'employees')),
                        getDocs(collection(db, 'attendance')),
                        getDocs(collection(db, 'leaveRequests')),
                        getDocs(collection(db, 'otRequests')),
                        getDocs(collection(db, 'staffLoans')),
                        getDocs(collection(db, 'employeeStates')),
                        getDocs(collection(db, 'salaryRevisions')),
                        // MODIFIED (STEP 5): Add query for 'savingprogram'
                        getDocs(collection(db, 'savingprogram'))
                    ]);

                    allShopsData = shopsSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    employees = empSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    attendance = attSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    leaveRequests = leaveSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    otRequests = otSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    staffLoans = loanSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    employeeStates = stateSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    salaryRevisions = revSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                    // MODIFIED (STEP 5): Process 'savingsData'
                    savingsData = savingsSnap.docs.map(d => ({ id: d.id, ...d.data() }));

                    setProcessLog(prev => [...prev, 'All data fetched successfully.']);

                } catch (fetchError) {
                    console.error("Critical error fetching bulk data:", fetchError);
                    setProcessLog(prev => [...prev, `FATAL ERROR: Could not fetch data. ${fetchError.message}`]);
                    setIsProcessing(false);
                    return;
                }
                // --- END MODIFICATION ---

                // MODIFIED: Use the locally fetched data
                const allData = { shops: allShopsData, employees, attendance, leaveRequests, otRequests, staffLoans, employeeStates, salaryRevisions };
                // MODIFIED (STEP 5): Create a Map for savings data
                const savingsDataMap = new Map(savingsData.map(d => [d.id, d]));

                let employeesToProcess = [];
                if (selectedShop === 'ALL_SHOPS') {
                    employeesToProcess = employees.filter(e => e.status === 'Active');
                } else {
                    employeesToProcess = employees.filter(e => e.status === 'Active' && (Array.isArray(e.shop) ? e.shop.includes(selectedShop) : e.shop === selectedShop));
                }

                if (employeesToProcess.length === 0) {
                    setProcessLog(['No active employees found for the selected shop.']);
                    setIsProcessing(false);
                    return;
                }
                
                // Check if payroll for this shop/month already exists to prevent duplicates
                // --- BUG FIX: This check is flawed. It checks for the whole shop, not per-employee. ---
                // --- This logic will be removed and moved inside the loop. ---
                /*
                const payrollCheckQuery = query(collection(db, "payrollHistory"), where("month", "==", selectedMonth), where("shop", "==", selectedShop));
                const existingPayrollSnap = await getDocs(payrollCheckQuery);
                if (!existingPayrollSnap.empty) {
                     setProcessLog(prev => [...prev, `Warning: Payroll for ${selectedShop} for ${selectedMonth} may already exist. Please check history.`]);
                }
                */

                setProcessLog(prev => [...prev, `Found ${employeesToProcess.length} employees. Starting payroll generation...`]);
                
                // --- NEW: Get start/end of month for savings query ---
                const [year, month] = selectedMonth.split('-').map(Number);
                const startDate = new Date(year, month - 1, 1);
                const endDate = new Date(year, month, 0, 23, 59, 59, 999);
                // --- END NEW ---

                let successCount = 0;
                for (const employee of employeesToProcess) {
                    await new Promise(res => setTimeout(res, 50)); // Tiny delay for UI to update
                    
                    // --- NEW DUPLICATE CHECK (BUG FIX) ---
                    // Check if a payroll record already exists for this specific employee and month.
                    try {
                        const payrollCheckQuery = query(
                            collection(db, "payrollHistory"), 
                            where("employeeId", "==", employee.id), 
                            where("month", "==", selectedMonth)
                        );
                        const existingPayrollSnap = await getDocs(payrollCheckQuery);
                        
                        if (!existingPayrollSnap.empty) {
                            // A record already exists. Log it and skip this employee.
                            setProcessLog(prev => [...prev, `[Skipped] ${employee.name}: Payroll record already exists for ${selectedMonth}.`]);
                            continue; // Move to the next employee
                        }
                    } catch (checkError) {
                        setProcessLog(prev => [...prev, `[Error] Failed to check duplicates for ${employee.name}: ${checkError.message}`]);
                        continue; // Skip this employee due to the check error
                    }
                    // --- END DUPLICATE CHECK ---

                    setProcessLog(prev => [...prev, `[${successCount + 1}/${employeesToProcess.length}] Calculating for ${employee.name}...`]);

                    // --- NEW: Fetch savings withdrawals for this specific employee and month ---
                    let employeeSavingsWithdrawals = [];
                    try {
                        const q = query(
                            // MODIFIED (STEP 6.A): Path changed from 'savingsTransactions' to the new subcollection
                            collection(db, 'savingprogram', employee.id, 'transactions'),
                            // FIX 2 (Index Error): Removed the 'type' filter from the query. We will filter in JS.
                            // where("type", "==", "withdrawal"), 
                            where("date", ">=", startDate),
                            where("date", "<=", endDate)
                        );
                        
                        const querySnapshot = await getDocs(q);
                        // FIX 2 (Index Error): Apply the 'type' filter here in JavaScript
                        employeeSavingsWithdrawals = querySnapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(tx => tx.type === 'withdrawal');
                            
                        if (employeeSavingsWithdrawals.length > 0) {
                             setProcessLog(prev => [...prev.slice(0, -1), `[${successCount + 1}/${employeesToProcess.length}] Calculating for ${employee.name}... (Found ${employeeSavingsWithdrawals.length} withdrawals)`]);
                        }
                    } catch (error) {
                        console.error(`Error fetching savings withdrawals for ${employee.name}:`, error);
                         setProcessLog(prev => [...prev.slice(0, -1), `[${successCount + 1}/${employeesToProcess.length}] Calculating for ${employee.name}... (Error fetching withdrawals)`]);
                    }
                    // --- END NEW ---

                    // Here we call the logic from our hook, but directly.
                    // This is a simplified version; in a real large-scale app, this would be a backend function.
                    
                    // MODIFIED (STEP 5): Get this employee's savingsData from the Map
                    const employeeSavingsData = savingsDataMap.get(employee.id) || null;
                    
                    // --- MODIFIED CALL: Pass the fetched withdrawals and savingsData to the calculator ---
                    const { inputs, calculations } = calculatePayrollForEmployee(employee, selectedMonth, allData, undefined, employeeSavingsWithdrawals, employeeSavingsData);
                    
                    if (calculations.netSalary !== undefined) {
                        const batch = writeBatch(db);
                        
                        const shopName = Array.isArray(employee.shop) ? employee.shop[0] : employee.shop;
                        const payrollData = { month: selectedMonth, shop: shopName, employeeId: employee.id, employeeName: employee.name, baseSalary: calculations.baseSalary, netSalary: calculations.netSalary, manualInputs: inputs, calculations: calculations, createdAt: serverTimestamp() };
                        
                        const payrollDocRef = doc(collection(db, "payrollHistory"));
                        batch.set(payrollDocRef, payrollData);
                        
                        // Handle loan deduction logic
                        if (inputs.loanDeduction > 0) {
                            // --- BUG FIX: Use deterministic logic to find the correct loan ---
                            // This ensures the deduction is applied to the *correct* loan,
                            // by finding the one with the latest effectiveDate.
                            const applicableLoans = (staffLoans || [])
                                .filter(l => l.staffId === employee.id && 
                                             l.status === 'Active' &&
                                             (!l.effectiveDate || l.effectiveDate.slice(0, 7) <= selectedMonth)
                                )
                                .sort((a, b) => (b.effectiveDate || '0000-00').localeCompare(a.effectiveDate || '0000-00'));
                            
                            const activeLoan = applicableLoans.length > 0 ? applicableLoans[0] : null;
                            // --- END FIX ---

                            if (activeLoan) {
                                const newTotalPaid = (activeLoan.totalPaid || 0) + inputs.loanDeduction;
                                const newBalance = activeLoan.loanAmount - newTotalPaid;
                                const newStatus = newBalance <= 0 ? 'Paid Off' : 'Active';
                                
                                batch.update(doc(db, 'staffLoans', activeLoan.id), { totalPaid: newTotalPaid, status: newStatus });
                                
                                batch.set(doc(collection(db, 'loanPayments')), { 
                                    paymentDate: `${selectedMonth}-${new Date(year, month, 0).getDate()}`, // Use year/month from above
                                    staffId: employee.id, 
                                    staffName: employee.name, 
                                    shop: shopName, 
                                    loanId: activeLoan.id, 
                                    amountPaid: inputs.loanDeduction, 
                                    remainingBalance: newBalance, 
                                    note: "Paid via payroll",
                                    payrollId: payrollDocRef.id // Link to the payroll doc
                                });
                            }
                        }

                        // --- Batch commit and Savings Contribution ---
                        try {
                            await batch.commit();

                            // --- NEW: Step 3 - Process Savings Contribution (after batch commit) ---
                            if (calculations.savingsDeduction > 0) {
                                // MODIFIED (STEP 5): Pass the 'shopName' to the utility function
                                // NEW: Log before calling
                                console.log(`[Payroll Trigger] Calling manageSavingsContribution for ${employee.name}, Amount: ${calculations.savingsDeduction}`);
                                await Utils.manageSavingsContribution(
                                    db,
                                    employee.id,
                                    employee.name,
                                    shopName, // Pass the shopName
                                    calculations.savingsDeduction,
                                    payrollDocRef.id // Use the ID from the ref created for the batch
                                );
                            }
                            // --- END: Step 3 ---

                            successCount++;
                            setProcessLog(prev => [...prev.slice(0, -1), `[${successCount}/${employeesToProcess.length}] Successfully processed for ${employee.name}.`]);
                        
                        } catch (error) {
                             setProcessLog(prev => [...prev.slice(0, -1), `[Error] Failed to save for ${employee.name}: ${error.message}`]);
                        }
                    } else {
                         setProcessLog(prev => [...prev.slice(0, -1), `[Skipped] Could not calculate salary for ${employee.name}.`]);
                    }
                }

                setProcessLog(prev => [...prev, `\nProcess finished. Successfully generated payroll for ${successCount} out of ${employeesToProcess.length} employees.`]);
                setIsProcessing(false);
                setProcessComplete(true);
                setTriggerConfirmed(false); // Reset confirmation checkbox
            };

            return (
                <Card>
                    <CardTitle>Trigger Bulk Salary Calculation</CardTitle>
                    <div className="max-w-xl mx-auto space-y-6">
                        <p className="text-slate-400">This tool allows you to generate payroll for all active employees in a selected shop for a specific month. The results will be saved to the Payroll History.</p>
                        
                        <div>
                            <label className="text-sm font-medium text-slate-400">Select Month</label>
                            <input type="month" value={selectedMonth} onChange={e => setSelectedMonth(e.target.value)} className="input" disabled={isProcessing} />
                        </div>

                        <div>
                            <label className="text-sm font-medium text-slate-400">Select Shop</label>
                            <select value={selectedShop} onChange={e => setSelectedShop(e.target.value)} className="select" disabled={isProcessing}>
                                <option value="">-- Select a Shop --</option>
                                <option value="ALL_SHOPS">All Shops (Admin Only)</option>
                                {allShops.map(s => <option key={s.id} value={s.name}>{s.name}</option>)}
                            </select>
                        </div>
                        
                        <div className="p-4 border border-yellow-600 bg-yellow-900/20 rounded-lg space-y-3">
                            <h4 className="font-bold text-yellow-300">Confirmation</h4>
                            <div className="flex items-start">
                                <input id="confirm-trigger" type="checkbox" checked={triggerConfirmed} onChange={e => setTriggerConfirmed(e.target.checked)} className="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 bg-slate-600 mt-1" disabled={isProcessing} />
                                <label htmlFor="confirm-trigger" className="ml-3 text-sm text-slate-300">I understand that this action will generate and save payroll records for all employees in the selected shop and month. This may overwrite existing records if run multiple times.</label>
                            </div>
                        </div>

                        <Button 
                            onClick={handleTriggerPayroll} 
                            // MODIFIED: Removed !allDataReady check
                            disabled={!triggerConfirmed || isProcessing || !selectedShop}
                            variant="danger"
                            className="w-full py-3 text-base"
                        >
                            {isProcessing ? <><i className="fas fa-spinner fa-spin"></i> Processing...</> : <><i className="fas fa-bolt"></i> Trigger Payroll Generation</>}
                        </Button>
                        
                        {(isProcessing || processLog.length > 0) && (
                            <div className="mt-6">
                                <h4 className="font-semibold text-slate-200">Processing Log:</h4>
                                <pre className="mt-2 bg-slate-900/70 p-4 rounded-lg text-sm text-slate-300 h-64 overflow-y-auto font-mono">
                                    {processLog.join('\n')}
                                </pre>
                            </div>
                        )}
                        {processComplete && (
                             <div className="mt-4 p-4 text-center bg-green-900/50 border border-green-700 rounded-lg">
                                <p className="font-semibold text-green-300">Process Complete!</p>
                            </div>
                        )}
                    </div>
                </Card>
            );
        };

        // Generic component for CRUD operations (Create, Read, Update, Delete)
        function SettingsCRUD({ title, collectionName, items, formFields, listColumns }) {
            const { db } = useFirebase();
            const [editingItem, setEditingItem] = useState(null);
            const [itemToDelete, setItemToDelete] = useState(null);
            const getInitialState = useCallback(() => formFields.reduce((acc, field) => ({...acc, [field.name]: '' }), {}), [formFields]);
            const [newItem, setNewItem] = useState(getInitialState());

            useEffect(() => { setNewItem(getInitialState()); }, [getInitialState]);

            // NEW: Memoized grouping logic specifically for shifts
            const groupedItems = useMemo(() => {
                if (collectionName !== 'shifts') return null;

                // Group items by shopName
                const grouped = items.reduce((acc, item) => {
                    const groupKey = item.shopName || 'Uncategorized';
                    if (!acc[groupKey]) {
                        acc[groupKey] = [];
                    }
                    acc[groupKey].push(item);
                    return acc;
                }, {});

                // Sort shifts within each group (e.g., AM, PM)
                Object.keys(grouped).forEach(shop => {
                    grouped[shop].sort((a, b) => a.name.localeCompare(b.name));
                });

                return grouped;
            }, [items, collectionName]);

            // NEW: Get sorted keys for rendering the groups in alphabetical order
            const sortedGroupKeys = useMemo(() => {
                if (!groupedItems) return [];
                return Object.keys(groupedItems).sort();
            }, [groupedItems]);


            const handleSave = useCallback(async (item) => {
                const { doc, updateDoc, addDoc, collection } = window.firebaseSDK;
                try {
                    if (item.id) { const { id, ...data } = item; await updateDoc(doc(db, collectionName, id), data); } 
                    else { 
                        // NEW: Add a duplicate check specifically for new shifts before saving.
                        if (collectionName === 'shifts') {
                            const isDuplicate = items.some(
                                existingShift => existingShift.name === item.name && existingShift.shopName === item.shopName
                            );
                            if (isDuplicate) {
                                alert(`A shift with the name "${item.name}" already exists for "${item.shopName}". Please choose a different name.`);
                                return; // Stop the function to prevent saving a duplicate.
                            }
                        }
                        await addDoc(collection(db, collectionName), item); 
                    }
                    setEditingItem(null); setNewItem(getInitialState());
                } catch (e) { console.error(`Error saving ${collectionName}:`, e); }
            }, [db, collectionName, getInitialState, items]); // Added `items` to dependency array for duplicate check
            
            const handleDelete = useCallback(async () => {
                if (!itemToDelete) return;
                try { 
                    await window.firebaseSDK.deleteDoc(window.firebaseSDK.doc(db, collectionName, itemToDelete.id)); 
                } catch (e) { 
                    console.error(`Error deleting ${collectionName}:`, e); 
                } finally {
                    setItemToDelete(null);
                }
            }, [db, collectionName, itemToDelete]);

            // Reusable form renderer
            const renderForm = (item, setItem, isNew = false) => (<form onSubmit={(e) => { e.preventDefault(); handleSave(item); }} className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 items-end p-4 bg-slate-800/50 rounded-lg mb-6 border border-slate-700">{formFields.map(field => (<div key={field.name} className={field.fullWidth ? 'col-span-full' : 'sm:col-span-1'}><label className="block text-sm font-medium text-slate-400">{field.label}</label>{field.type === 'select' ? (<select name={field.name} value={item[field.name] || ''} onChange={(e) => setItem({...item, [field.name]: e.target.value})} className="select" required={field.required}><option value="">Select {field.label}</option>{(field.options || []).map(option => (<option key={option} value={option}>{option}</option>))}</select>) : (<input type={field.type || 'text'} name={field.name} value={item[field.name] || ''} onChange={(e) => setItem({...item, [field.name]: e.target.value})} className="input" required={field.required} />)}</div>))}<div className="flex space-x-2 col-span-full md:col-span-1 self-end mt-4 md:mt-0"><Button type="submit" variant="primary" className="w-full">{isNew ? `Add ${title}` : 'Save'}</Button>{!isNew && <Button type="button" variant="secondary" onClick={() => setEditingItem(null)} className="w-full">Cancel</Button>}</div></form>);

            return (<Card><CardTitle>{title} Management</CardTitle>{renderForm(newItem, setNewItem, true)}<div className="overflow-x-auto"><table className="min-w-full divide-y divide-slate-700"><thead className="bg-slate-900/50"><tr>{listColumns.map(col => <th key={col.accessor} className="px-4 py-3 text-left text-xs font-semibold text-slate-400 uppercase">{col.header}</th>)}<th className="px-4 py-3 text-right text-xs font-semibold text-slate-400 uppercase">Actions</th></tr></thead>
                <tbody className="divide-y divide-slate-700">
                    {/* NEW: Conditional rendering for grouped shifts vs. flat lists */}
                    {collectionName === 'shifts' && groupedItems ? (
                        sortedGroupKeys.map(shopName => (
                            <React.Fragment key={shopName}>
                                <tr className="bg-slate-900">
                                    <td colSpan={listColumns.length + 1} className="px-4 py-2 text-sm font-semibold text-blue-400 tracking-wider">
                                        {shopName}
                                    </td>
                                </tr>
                                {groupedItems[shopName].map(item => (
                                    <tr key={item.id} className="hover:bg-slate-700/50">
                                        {editingItem?.id === item.id ? (
                                            <td colSpan={listColumns.length + 1} className="p-0">{renderForm(editingItem, setEditingItem)}</td>
                                        ) : (
                                            <>
                                                {listColumns.map(col => <td key={col.accessor} className="px-4 py-4 text-sm text-slate-300">{item[col.accessor]}</td>)}
                                                <td className="px-4 py-4 text-sm">
                                                    <div className="flex items-center justify-end gap-4">
                                                        <Button variant="icon-edit" icon="fa-edit" onClick={() => setEditingItem({ ...item })} />
                                                        <Button variant="icon-delete" icon="fa-trash" onClick={() => setItemToDelete(item)} />
                                                    </div>
                                                </td>
                                            </>
                                        )}
                                    </tr>
                                ))}
                            </React.Fragment>
                        ))
                    ) : (
                        items.map(item => (<tr key={item.id} className="hover:bg-slate-700/50">{editingItem?.id === item.id ? (<td colSpan={listColumns.length + 1} className="p-0">{renderForm(editingItem, setEditingItem)}</td>) : (<>{listColumns.map(col => <td key={col.accessor} className="px-4 py-4 text-sm text-slate-300">{item[col.accessor]}</td>)}<td className="px-4 py-4 text-sm"><div className="flex items-center justify-end gap-4"><Button variant="icon-edit" icon="fa-edit" onClick={() => setEditingItem({ ...item })} /><Button variant="icon-delete" icon="fa-trash" onClick={() => setItemToDelete(item)} /></div></td></>)}</tr>))
                    )}
                </tbody>
            </table></div><ConfirmationModal isOpen={!!itemToDelete} onClose={() => setItemToDelete(null)} onConfirm={handleDelete} title={`Delete ${title}`} message="Are you sure you want to delete this item?" /></Card>);
        }
        // --- END SETTINGS PAGE ---

        // --- START LAYOUT & MAIN APP COMPONENTS ---
        const Sidebar = memo(({ activePage, setActivePage, isSidebarOpen, toggleSidebar, userProfile }) => {
            const { isOnline } = useConnectivity();
            const sidebarLinks = useMemo(() => [ 
                { key: 'policy', icon: 'fa-book-open', label: 'Policy Board' },
                { key: 'employees', icon: 'fa-users', label: 'Employees' }, 
                { key: 'checkinme', icon: 'fa-user-clock', label: 'CheckInMe' }, 
                // REMOVED: Saving Program link
                { key: 'attendanceReport', icon: 'fa-file-alt', label: 'Attendance Report' }, 
                { key: 'payroll', icon: 'fa-money-check-dollar', label: 'Payroll' }, 
                { key: 'hrBanking', icon: 'fa-university', label: 'HR Banking' },
                { key: 'expenseReport', icon: 'fa-file-invoice-dollar', label: 'Expense Report' }, 
                { key: 'userActivity', icon: 'fa-chart-line', label: 'User Activity' }, 
                { key: 'settings', icon: 'fa-cog', label: 'Settings' }, 
            ], []);

            // Filter sidebar links based on user permissions
            const availableLinks = useMemo(() => {
                if (userProfile?.role === 'Admin' || userProfile?.role === 'CEO') return sidebarLinks; // Admin & CEO see all available links
                if (!userProfile?.permissions) {
                    // If no permissions array exists, just show the policy board to be safe.
                    return sidebarLinks.filter(link => link.key === 'policy');
                }
                // Create a set of allowed pages, ensuring 'policy' is always included without duplication.
                const allowedPages = new Set(userProfile.permissions);
                allowedPages.add('policy');
        
                return sidebarLinks.filter(link => allowedPages.has(link.key));
            }, [userProfile, sidebarLinks]);

             const handleLinkClick = useCallback((pageKey) => { 
                setActivePage(pageKey); 
                if (window.innerWidth < 768) toggleSidebar(); // Close sidebar on mobile after navigation
            }, [setActivePage, toggleSidebar]);

            return (
                <aside className={`w-64 bg-slate-900 text-slate-300 p-4 flex flex-col transform ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 transition-transform duration-300 ease-in-out z-40 fixed md:relative h-full border-r border-slate-700`}>
                    <div className="flex items-center mb-2 px-2">
                        <i className="fas fa-building-user text-3xl text-blue-500 mr-3"></i>
                        <h1 className="text-2xl font-bold text-white">HR System</h1>
                    </div>
                    {/* Desktop Connectivity Status */}
                    <div className="px-2 mb-6 hidden md:block">
                        {isOnline ? (
                            <div className="flex items-center gap-2 text-xs text-green-400 font-medium">
                                <i className="fas fa-circle text-[8px]"></i> Online
                            </div>
                        ) : (
                            <div className="flex items-center gap-2 text-xs text-red-400 font-medium">
                                <i className="fas fa-circle text-[8px]"></i> Offline Mode
                            </div>
                        )}
                    </div>
                    <nav className="flex-grow">{availableLinks.map(link => (<a href="#" key={link.key} onClick={() => handleLinkClick(link.key)} className={`flex items-center py-3 px-4 rounded-lg transition duration-200 mt-2 ${activePage === link.key ? 'bg-blue-600 text-white shadow-lg' : 'hover:bg-slate-700/50'}`}><i className={`fas ${link.icon} w-6 mr-4`}></i><span className="font-medium">{link.label}</span></a>))}</nav>
                </aside>
            );
        });

        const Header = memo(({ pageTitle, toggleSidebar, userProfile, pendingLeaves, pendingOTs, onNotificationClick }) => {
            const { auth } = useFirebase();
            const { isOnline } = useConnectivity();

            const handleLogout = useCallback(async () => { 
                try { await window.firebaseSDK.signOut(auth); } 
                catch (error) { console.error("Error signing out: ", error); } 
            }, [auth]);

            const showNotifications = userProfile?.role === 'Admin' || userProfile?.role === 'Shop Manager';

            return (
                <header className="bg-slate-800/80 backdrop-blur-sm shadow-md p-4 flex justify-between items-center z-30 border-b border-slate-700 sticky top-0">
                    <div className="flex items-center min-w-0">
                        <button onClick={toggleSidebar} className="text-slate-400 focus:outline-none md:hidden mr-4"><i className="fas fa-bars text-2xl"></i></button>
                        <div className="flex flex-col">
                            <h2 className="text-xl sm:text-2xl font-bold text-slate-100 truncate">{pageTitle}</h2>
                             {/* Mobile Connectivity Status */}
                            <div className="md:hidden">
                                {isOnline ? (
                                    <div className="flex items-center gap-1.5 text-xs text-green-400 font-medium">
                                        <i className="fas fa-circle text-[8px]"></i> Online
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-1.5 text-xs text-red-400 font-medium">
                                        <i className="fas fa-circle text-[8px]"></i> Offline Mode
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                    <div className="flex items-center gap-2 sm:gap-4 flex-shrink-0">
                        {userProfile && (<div className="text-right hidden sm:block"><span className="text-sm text-slate-400">Welcome, </span><span className="font-medium text-slate-200">{userProfile.name}</span></div>)}
                        {showNotifications && (
                            <NotificationBell
                                pendingLeaves={pendingLeaves}
                                pendingOTs={pendingOTs}
                                onNotificationClick={onNotificationClick}
                            />
                        )}
                        <button onClick={handleLogout} title="Logout" className="bg-slate-700 text-slate-300 w-10 h-10 rounded-full hover:bg-slate-600 hover:text-white transition duration-150 flex items-center justify-center flex-shrink-0"><i className="fas fa-sign-out-alt"></i></button>
                    </div>
                </header>
            );
        });
        
        const Dashboard = ({ userProfile }) => {
            const [isSidebarOpen, setSidebarOpen] = useState(false);
            const [activePage, setActivePage] = useState('');
            const [initialCheckInMeTab, setInitialCheckInMeTab] = useState('checkInOut');
            const [showNotificationModal, setShowNotificationModal] = useState(true);
            
            // REVISED: Renamed state to be more specific
            const [memoToDisplay, setMemoToDisplay] = useState(null);
            const [isMemoVisible, setMemoVisible] = useState(false);
            
            const [memoShownThisSession, setMemoShownThisSession] = useState(false);
            const { db } = useFirebase();
            const { where } = window.firebaseSDK; // Added where for query

            // REVISED: Fetches all *active* memos from the new `memoAlerts` collection
            const { data: activeMemos } = useCollection('memoAlerts', [where("status", "==", "Active")]);

            // Logic to show memo modal
            useEffect(() => {
                // REVISED: This logic now finds the correct memo based on time and role
                // Check if we have active memos, a user profile, and haven't shown a memo this session
                if (activeMemos && activeMemos.length > 0 && userProfile && !memoShownThisSession) {
                    
                    const now = new Date();
                    // Get current time in "HH:mm" format (24-hour)
                    const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    
                    // REVISED: Find the first memo that matches the new criteria (shop and time)
                    const memoToShow = activeMemos.find(memo => {
                        if (!memo.startTime || !memo.endTime) return false; // Skip memos without time
                        
                        // 1. Check if user's shop matches
                        const userShops = Array.isArray(userProfile.shop) ? userProfile.shop : [userProfile.shop];
                        const targetShops = Array.isArray(memo.targetShops) ? memo.targetShops : [];
                        
                        // Shop match is true if targetShops is empty (All Shops)
                        // OR if any of the user's shops are in the targetShops list.
                        const shopMatch = targetShops.length === 0 || 
                                          userShops.some(shop => targetShops.includes(shop));

                        // 2. Check if current time is within the [startTime, endTime) range
                        const timeMatch = currentTime >= memo.startTime && currentTime < memo.endTime;
                        
                        return shopMatch && timeMatch;
                    });

                    // If we found a memo to show, update state to display it
                    if (memoToShow) {
                        setMemoToDisplay(memoToShow);
                        setMemoVisible(true);
                        setMemoShownThisSession(true); // Ensure it only shows once per session/reload
                    }
                }
            }, [activeMemos, userProfile, memoShownThisSession]); // Re-run when memos or user profile changes
            
            // Set the default page based on user role and permissions
            useEffect(() => {
                if (userProfile) {
                    let defaultPage = 'checkinme'; // Fallback for staff
                    if (userProfile.role === 'Admin' || userProfile.role === 'Shop Manager') {
                        // Default Admins/Managers to Employees page if they have access, otherwise their first permission
                        defaultPage = userProfile.permissions?.includes('employees') 
                            ? 'employees' 
                            : userProfile.permissions?.[0] || 'checkinme';
                    } else if (userProfile.permissions && userProfile.permissions.length > 0) {
                        // For other roles, default to their first permission
                        defaultPage = userProfile.permissions[0];
                    }
                    setActivePage(defaultPage);
                }
            }, [userProfile]);

            const toggleSidebar = useCallback(() => setSidebarOpen(prev => !prev), []);
            
            // const { where } = window.firebaseSDK; // <-- Removed duplicate declaration
            const requestQueryConstraints = useMemo(() => {
                // This logic determines which pending requests to fetch for notifications.
                if (userProfile?.role === 'Admin') {
                    // Admin sees all pending requests from all shops.
                    return [where("status", "==", "Pending")];
                }
                if (userProfile?.role === 'Shop Manager') {
                    // Shop Manager is restricted to see pending requests only from their assigned shop.
                    return [
                        where("status", "==", "Pending"),
                        where("shop", "==", userProfile.shop || null) // Using || null for safety.
                    ];
                }
                // For any other role (e.g., Staff), return a query that will match no documents.
                // This prevents fetching unnecessary data for users who won't see the notifications.
                return [where("status", "==", "non-existent-status")];
            }, [userProfile]);

            const { data: pendingLeaves } = useCollection('leaveRequests', requestQueryConstraints);
            const { data: pendingOTs } = useCollection('otRequests', requestQueryConstraints);

            const handleNotificationClick = useCallback((targetTab) => {
                setActivePage('checkinme');
                setInitialCheckInMeTab(targetTab);
                setShowNotificationModal(false);
            }, []);

            const pageTitles = useMemo(() => ({ 
                employees: 'Employees', checkinme: 'CheckInMe', attendanceReport: 'Attendance Report', 
                payroll: 'Payroll', 
                hrBanking: 'HR Banking',
                expenseReport: 'Expense Report', 
                userActivity: 'User Activity', settings: 'Settings', policy: 'Company Policy Board',
                // REMOVED: savingProgram title
            }), []);
            
            const totalPending = pendingLeaves.length + pendingOTs.length;
            // Renders the component for the currently active page
            const renderActivePage = useCallback(() => {
                const hasPermission = (userProfile?.role === 'Admin') || (userProfile?.role === 'CEO' && activePage !== 'sysConfig') || userProfile?.permissions?.includes(activePage) || activePage === 'policy';
                if (!activePage) return null;
                if (!hasPermission) return <Card><CardTitle>Access Denied</CardTitle><p>You do not have permission to view this page.</p></Card>;
                
                switch(activePage) {
                    case 'employees': return <EmployeesPage userProfile={userProfile} />;
                    case 'checkinme': return <CheckInMePage userProfile={userProfile} initialTab={initialCheckInMeTab} />;
                    // REMOVED: savingProgram case
                    case 'attendanceReport': return <AttendanceReportPage userProfile={userProfile} />;
                    case 'payroll': return <PayrollPage userProfile={userProfile} />;
                    case 'hrBanking': return <HRBankingPage userProfile={userProfile} />;
                    case 'expenseReport': return <ExpenseReportPage userProfile={userProfile} />;
                    case 'policy': return <PolicyBoardPage userProfile={userProfile} />;
                    case 'userActivity': return <UserActivityPage />;
                    case 'settings': return <SettingsPage />;
                    default: return <UnderConstructionPage title="Page Not Found" />;
                }
            }, [activePage, userProfile, initialCheckInMeTab]);

            return (
                <div className="flex h-screen bg-slate-900 text-slate-300">
                    <Sidebar activePage={activePage} setActivePage={setActivePage} isSidebarOpen={isSidebarOpen} toggleSidebar={toggleSidebar} userProfile={userProfile} />
                    <div className="flex-1 flex flex-col overflow-hidden">
                        <Header 
                            pageTitle={pageTitles[activePage] || 'Dashboard'} 
                            toggleSidebar={toggleSidebar} 
                            userProfile={userProfile}
                            pendingLeaves={pendingLeaves}
                            pendingOTs={pendingOTs}
                            onNotificationClick={handleNotificationClick}
                        />
                        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-slate-800 p-4 sm:p-6">
                            {renderActivePage()}
                        </main>
                        <Modal isOpen={showNotificationModal && totalPending > 0 && userProfile?.role !== 'Staff'} onClose={() => setShowNotificationModal(false)} maxWidth="max-w-md">
                            <ModalHeader title="Pending Approvals" onClose={() => setShowNotificationModal(false)} />
                            <ModalBody>
                                <p className="text-slate-300">You have {totalPending} new request(s) waiting for your approval.</p>
                                <ul className="mt-4 space-y-2">
                                    {pendingLeaves.length > 0 && <li><span className="font-semibold">{pendingLeaves.length}</span> Leave Request(s)</li>}
                                    {pendingOTs.length > 0 && <li><span className="font-semibold">{pendingOTs.length}</span> OT Request(s)</li>}
                                </ul>
                            </ModalBody>
                            <ModalFooter>
                                <Button variant="secondary" onClick={() => setShowNotificationModal(false)}>Dismiss</Button>
                                <Button variant="primary" onClick={() => handleNotificationClick('leaveRequest')}>View Requests</Button>
                            </ModalFooter>
                        </Modal>
                        {/* REVISED: This modal now reads from the new `memoToDisplay` state */}
                        {memoToDisplay && (
                            <Modal isOpen={isMemoVisible} onClose={() => setMemoVisible(false)} maxWidth="max-w-lg">
                                <ModalHeader title={memoToDisplay.title || "ដំណឹងប្រាប់ពត៏មាន"} onClose={() => setMemoVisible(false)} />
                                <ModalBody>
                                    <pre className="text-slate-300 whitespace-pre-wrap font-sans">{memoToDisplay.content}</pre>
                                </ModalBody>
                                <ModalFooter>
                                    <Button variant="primary" onClick={() => setMemoVisible(false)}>ទទួលបាន</Button>
                                </ModalFooter>
                            </Modal>
                        )}
                    </div>
                </div>
            );
        };

        // Main App Component: Decides whether to show Login or Dashboard
        function AppContent() {
            const { currentUser, userProfile, loading } = useFirebase();
            
            if (loading) return <div className="flex items-center justify-center h-screen text-lg text-slate-300">Loading Application...</div>;
            
            return (
                <div>
                    {currentUser ? <Dashboard userProfile={userProfile} /> : <LoginPage />}
                </div>
            );
        }

        // Root Component with Firebase Provider
        function App() {
            return (
                <FirebaseProvider>
                    <AppDataProvider> {/* NEW: Wrap AppContent with the new data provider */}
                        <AppContent />
                    </AppDataProvider>
                </FirebaseProvider>
            );
        }

        // Render the application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <ConnectivityProvider>
                <App />
            </ConnectivityProvider>
        );
        // --- END LAYOUT & MAIN APP COMPONENTS ---
    </script>
</body>
</html>
