<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JLW - CashFlow Report</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4f46e5">
    <link rel="manifest" id="manifest">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="CashFlow App">
    <link rel="apple-touch-icon" href="https://i.imgur.com/Ahdcb2w.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        body { background-color: #f1f5f9; font-family: 'Inter', sans-serif; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin { animation: spin 1s linear infinite; }

        .modal-enter { animation: modal-enter 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both; }
        @keyframes modal-enter {
            0% { opacity: 0; transform: translateY(20px) scale(0.95); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        .notification-enter { animation: notification-enter 0.4s ease-out; }
        @keyframes notification-enter {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="h-full">
    <div id="root" class="h-full"></div>

    <script type="module">
        // Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getFirestore, collection, onSnapshot, doc, getDoc, Timestamp, addDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut, setPersistence, browserSessionPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyA4upjtl0UFToWSfRZEiEQvwz9ieFLfqhI",
            authDomain: "cashflow-mgr.firebaseapp.com",
            projectId: "cashflow-mgr",
            storageBucket: "cashflow-mgr.appspot.com",
            messagingSenderId: "873891130920",
            appId: "1:873891130920:web:b6b8f0432943c33a930f1d",
            measurementId: "G-LVLMJ8ZY0B"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        window.db = db;
        window.auth = auth;
        window.Firebase = {
            Timestamp,
            onAuthStateChanged,
            signInWithEmailAndPassword,
            signOut,
            collection,
            onSnapshot,
            doc,
            getDoc,
            addDoc,
            updateDoc,
            deleteDoc,
            setPersistence,
            browserSessionPersistence,
            browserLocalPersistence
        };
    </script>
    
    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, createContext, useContext, useRef } = React;
        
        // =================================================================================
        // #region CONTEXT & PROVIDERS
        // =================================================================================
        const DataContext = createContext();
        const useData = () => useContext(DataContext);
        const NotificationContext = createContext();

        const NotificationProvider = ({ children }) => {
            const [notification, setNotification] = useState(null);
            const timeoutRef = useRef(null);
            const showNotification = useCallback((message, type = 'success', duration = 3000) => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                setNotification({ message, type, id: Date.now() });
                timeoutRef.current = setTimeout(() => setNotification(null), duration);
            }, []);
            return (
                <NotificationContext.Provider value={{ showNotification }}>
                    {children}
                    {notification && <Notification message={notification.message} type={notification.type} onClose={() => setNotification(null)} />}
                </NotificationContext.Provider>
            );
        };
        const useNotification = () => useContext(NotificationContext);

        const DataProvider = ({ children }) => {
            const [user, setUser] = useState(null);
            const [userData, setUserData] = useState(null);
            const [dbData, setDbData] = useState({
                shops: [], businessExpenses: [], familyExpenses: [], cashDrops: [],
                purchaseOrders: [], internalTransfers: [], personalCashflowStatements: [],
                appSettings: { exchangeRate: 4000 }
            });
            const [isLoading, setIsLoading] = useState(true);
            const { showNotification } = useNotification();
            
            useEffect(() => {
                const { onAuthStateChanged, signOut, doc, getDoc } = window.Firebase;
                const unsubscribeAuth = onAuthStateChanged(window.auth, async (firebaseUser) => {
                    setIsLoading(true);
                    if (firebaseUser) {
                        const userDocRef = doc(window.db, "employees", firebaseUser.uid);
                        try {
                            const userDocSnap = await getDoc(userDocRef);
                            if (userDocSnap.exists()) {
                                const profile = userDocSnap.data();
                                if (profile.role === 'Admin' || profile.role === 'Management') {
                                    setUser(firebaseUser);
                                    setUserData({ uid: firebaseUser.uid, ...profile });
                                } else {
                                    showNotification("You are not authorized to view this page.", "error");
                                    signOut(window.auth);
                                }
                            } else {
                                signOut(window.auth);
                            }
                        } catch (error) {
                            signOut(window.auth);
                        }
                    } else {
                        setUser(null);
                        setUserData(null);
                    }
                    setIsLoading(false);
                });
                return () => unsubscribeAuth();
            }, [showNotification]);

            useEffect(() => {
                if (!user || !userData) return;
                const { collection, onSnapshot, doc } = window.Firebase;
                const collectionsToSubscribe = [
                    'shops', 'businessExpenses', 'familyExpenses', 'cashDrops',
                    'purchaseOrders', 'internalTransfers', 'personalCashflowStatements'
                ];
                const unsubscribes = collectionsToSubscribe.map(colName => 
                    onSnapshot(collection(window.db, colName), (snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setDbData(prev => ({ ...prev, [colName]: data }));
                    }, (error) => console.error(`Error fetching ${colName}:`, error))
                );
                const unsubSettings = onSnapshot(doc(window.db, "settings", "app"), (docSnap) => {
                    if (docSnap.exists()) setDbData(prev => ({ ...prev, appSettings: docSnap.data() }));
                });
                return () => {
                    unsubscribes.forEach(unsub => unsub());
                    unsubSettings();
                };
            }, [user, userData]);

            const value = { ...dbData, user, userData, isLoading, reports: dbData.cashDrops };
            return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
        };
        // #endregion

        // =================================================================================
        // #region HELPERS & UI COMPONENTS
        // =================================================================================
        const getCambodiaISODate = (date = new Date()) => date.toLocaleDateString('en-CA', { timeZone: 'Asia/Phnom_Penh' });
        const formatInCambodiaDateOnly = (ts) => ts?.toDate ? ts.toDate().toLocaleDateString('en-GB', { timeZone: 'Asia/Phnom_Penh' }).split('/').reverse().join('-') : 'N/A';
        const createTimestampFromDateAndCurrentTime = (dateString) => window.Firebase.Timestamp.fromDate(new Date(dateString));
        const parseFormattedNumber = (val) => parseFloat(String(val).replace(/,/g, '')) || 0;
        const formatCurrency = (val, currency = 'KHR') => {
            const num = parseFormattedNumber(val);
            if (currency === 'KHR') return `${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}៛`;
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2 }).format(num);
        };

        const Icon = React.memo(({ name, size = 16, className = '' }) => {
            const Svg = ({ children }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>;
            const iconMap = {
                LoaderCircle: <Svg><path d="M21 12a9 9 0 1 1-6.219-8.56" /></Svg>,
                Download: <Svg><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></Svg>,
                Eye: <Svg><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"/><circle cx="12" cy="12" r="3"/></Svg>,
                EyeOff: <Svg><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></Svg>,
                Landmark: <Svg><line x1="3" x2="21" y1="22" y2="22"/><line x1="6" x2="6" y1="18" y2="11"/><line x1="10" x2="10" y1="18" y2="11"/><line x1="14" x2="14" y1="18" y2="11"/><line x1="18" x2="18" y1="18" y2="11"/><polygon points="12 2 20 7 4 7"/></Svg>,
                X: <Svg><path d="M18 6 6 18"/><path d="m6 6 12 12"/></Svg>,
                ArrowUp: <Svg><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></Svg>,
                ArrowDown: <Svg><path d="M12 5v14"/><path d="m19 12-7 7-7-7"/></Svg>,
                PenSquare: <Svg><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></Svg>,
                Trash2: <Svg><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></Svg>,
            };
            return iconMap[name] || null;
        });

        const Card = ({ children, className = "" }) => <div className={`bg-white p-4 sm:p-6 rounded-2xl shadow-sm border border-gray-200/80 ${className}`}>{children}</div>;
        const PageHeader = ({ title, subtitle, children }) => <header className="mb-8 flex flex-col sm:flex-row justify-between sm:items-center gap-4"><div><h1 className="text-2xl sm:text-3xl font-bold text-gray-900">{title}</h1>{subtitle && <p className="mt-1 text-md sm:text-lg text-gray-600">{subtitle}</p>}</div><div className="flex-shrink-0 flex items-center gap-2">{children}</div></header>;
        const Button = ({ children, onClick, variant = 'primary', disabled = false, className = '', icon: IconName }) => {
            const baseStyles = 'px-4 py-2 rounded-lg font-semibold flex items-center justify-center gap-2 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2';
            const variants = { primary: 'bg-indigo-600 text-white hover:bg-indigo-700 disabled:bg-indigo-400 focus:ring-indigo-500', secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 disabled:bg-gray-200 focus:ring-gray-400', danger: 'bg-red-600 text-white hover:bg-red-700 disabled:bg-red-400 focus:ring-red-500', ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 focus:ring-indigo-500' };
            return <button onClick={onClick} disabled={disabled} className={`${baseStyles} ${variants[variant]} ${className}`}>{IconName && <Icon name={IconName} size={16} className={IconName === 'LoaderCircle' ? 'animate-spin' : ''} />}{children}</button>;
        };
        const FormInput = React.memo(({ label, name, icon: IconName, ...props }) => (
            <div className="w-full">
                {label && <label htmlFor={name} className="block text-sm font-medium text-gray-700 mb-1.5">{label}</label>}
                <div className="relative">
                    {IconName && <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"><Icon name={IconName} className="h-5 w-5 text-gray-400" /></div>}
                    <input name={name} id={name} {...props} className={`block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent sm:text-sm ${IconName ? 'pl-10' : ''}`} />
                </div>
            </div>
        ));
        const FormTextarea = React.memo(({ label, name, ...props }) => <div>{label && <label htmlFor={name} className="block text-sm font-medium text-gray-700 mb-1.5">{label}</label>}<textarea name={name} id={name} {...props} rows="3" className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent sm:text-sm" /></div>);
        const FormSelect = React.memo(({ label, name, options, ...props }) => <div>{label && <label htmlFor={name} className="block text-sm font-medium text-gray-700 mb-1.5">{label}</label>}<select name={name} id={name} {...props} className="block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent sm:text-sm">{options.map((opt, i) => <option key={`${opt.value}-${i}`} value={opt.value}>{opt.label}</option>)}</select></div>);
        const LiveFormatInput = React.memo(({ value, onChange, name, label, ...props }) => {
            const handleChange = useCallback((e) => {
                let sanitized = e.target.value.replace(/[^0-9.]/g, '');
                const parts = sanitized.split('.');
                if (parts.length > 2) sanitized = parts[0] + '.' + parts.slice(1).join('');
                onChange({ target: { name, value: sanitized } });
            }, [onChange, name]);
            const formatForDisplay = (val) => {
                if (val === null || val === undefined || val === '') return '';
                const [intPart, decPart] = String(val).split('.');
                const formattedInt = intPart ? new Intl.NumberFormat('en-US').format(intPart) : '';
                if (decPart !== undefined) return `${formattedInt}.${decPart}`;
                if (String(val).endsWith('.')) return `${formattedInt}.`;
                return formattedInt;
            };
            return <FormInput label={label} name={name} value={formatForDisplay(value)} onChange={handleChange} placeholder="0" {...props}/>;
        });
        const Modal = ({ children, onClose, title, size = 'xl' }) => {
            const sizeClasses = { lg: 'max-w-lg', '2xl': 'max-w-2xl' };
            return <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm"><div className={`bg-gray-50 rounded-xl shadow-2xl w-full ${sizeClasses[size]} max-h-[90vh] flex flex-col modal-enter`}><header className="flex justify-between items-center p-4 border-b bg-white rounded-t-xl"><h3 className="text-xl font-bold text-gray-900">{title}</h3><Button variant="ghost" onClick={onClose} className="p-1 rounded-full" icon="X" /></header><div className="p-6 overflow-y-auto">{children}</div></div></div>;
        };
        const ConfirmationModal = React.memo(({ title, message, onConfirm, onClose, isSubmitting, confirmVariant = 'primary', confirmText = 'Confirm' }) => (
            <Modal title={title} onClose={onClose} size="sm">
                <div className="space-y-4">
                    <p className="text-sm text-gray-600">{message}</p>
                    <div className="flex justify-end gap-4">
                        <Button onClick={onClose} variant="secondary">Cancel</Button>
                        <Button onClick={onConfirm} disabled={isSubmitting} variant={confirmVariant} className="w-28" icon={isSubmitting ? "LoaderCircle" : null}>
                            {isSubmitting ? '' : confirmText}
                        </Button>
                    </div>
                </div>
            </Modal>
        ));
        const Notification = ({ message, type, onClose }) => {
            const typeClasses = { success: 'text-green-800 bg-green-50', error: 'text-red-800 bg-red-50' };
            const icons = { success: <Icon name="CheckCircle" className="text-green-500" />, error: <Icon name="XCircle" className="text-red-500" /> };
            return <div className={`fixed top-5 right-5 z-[100] flex items-center w-full max-w-xs p-4 space-x-4 text-gray-500 bg-white divide-x divide-gray-200 rounded-lg shadow-2xl space-x notification-enter`} role="alert"><div className="flex-shrink-0">{icons[type]}</div><div className="pl-4 text-sm font-normal">{message}</div><button onClick={onClose} className="ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-900 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-100 inline-flex h-8 w-8"><Icon name="X" size={20} /></button></div>;
        };
        // #endregion

        // =================================================================================
        // #region DATA HOOKS & RESPONSIVE TABLE
        // =================================================================================
        const useMonthlyData = (filters) => {
            const { reports, businessExpenses, familyExpenses, shops, purchaseOrders, internalTransfers, appSettings } = useData();
            return useMemo(() => {
                if (!filters.year || !filters.month) {
                    return { exchangeRate: 4100, shops: [], filteredReports: [], filteredBusinessExpenses: [], filteredFamilyExpenses: [], filteredInternalTransfers: [], filteredPurchaseOrders: [], allPOs: [], allReports: [], allTransfers: [] };
                }
                const year = parseInt(filters.year, 10);
                const month = parseInt(filters.month, 10);
                const startDate = new Date(year, month - 1, 1);
                const endDate = new Date(year, month, 0, 23, 59, 59, 999);
                const exchangeRate = appSettings.exchangeRate || 4100;
                const filterByDate = (item) => {
                    const itemDate = item.createdAt?.toDate() || item.date?.toDate();
                    return itemDate && itemDate >= startDate && itemDate <= endDate;
                };
                const filteredReports = reports.filter(filterByDate);
                const filteredBusinessExpenses = businessExpenses.filter(filterByDate);
                const filteredFamilyExpenses = familyExpenses.filter(filterByDate);
                const filteredInternalTransfers = internalTransfers.filter(filterByDate);
                const filteredPurchaseOrders = purchaseOrders.filter(filterByDate);
                return { exchangeRate, shops, filteredReports, filteredBusinessExpenses, filteredFamilyExpenses, filteredInternalTransfers, filteredPurchaseOrders, allPOs: purchaseOrders, allReports: reports, allTransfers: internalTransfers };
            }, [filters.year, filters.month, reports, businessExpenses, familyExpenses, shops, purchaseOrders, internalTransfers, appSettings]);
        };

        const ResponsiveTable = ({ headers, data, footer }) => {
            return (
                <div className="overflow-x-auto">
                    {/* Desktop Table */}
                    <table className="hidden md:table w-full text-sm">
                        <thead className="bg-gray-100">
                            <tr>{headers.map(h => <th key={h.key} className={`p-2 text-${h.align || 'left'}`}>{h.label}</th>)}</tr>
                        </thead>
                        <tbody>{data.map((row, rowIndex) => <tr key={rowIndex} className="border-b">{headers.map(h => <td key={h.key} className={`p-2 text-${h.align || 'left'} font-mono ${h.className ? h.className(row) : ''}`}>{row[h.key]}</td>)}</tr>)}</tbody>
                        {footer && <tfoot className="bg-gray-200 font-bold"><tr>{footer.map((f, i) => <td key={i} colSpan={f.colSpan || 1} className={`p-2 text-${f.align || 'left'} font-mono`}>{f.content}</td>)}</tr></tfoot>}
                    </table>
                    {/* Mobile Cards */}
                    <div className="block md:hidden space-y-4">
                        {data.map((row, rowIndex) => (
                            <div key={rowIndex} className="bg-white border rounded-lg p-4 space-y-2">
                                {headers.map(h => (
                                    <div key={h.key} className="flex justify-between items-center">
                                        <span className="text-gray-600 font-semibold">{h.label}</span>
                                        <span className={`text-right font-mono ${h.className ? h.className(row) : ''}`}>{row[h.key]}</span>
                                    </div>
                                ))}
                            </div>
                        ))}
                         {footer && (
                            <div className="bg-gray-200 border rounded-lg p-4 mt-4 space-y-2 font-bold">
                               {footer.map((f, i) => (
                                    f.colSpan ? <div key={i} className="flex justify-between items-center"><span className="text-gray-800">{f.content}</span></div>
                                    : <div key={i} className="flex justify-between items-center"><span className="text-gray-600">{headers[i].label}</span><span className="text-right font-mono">{f.content}</span></div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        // #endregion

        // =================================================================================
        // #region SHAREHOLDER NET TAB
        // =================================================================================
        const ShareholderNetTab = ({ filters }) => {
            const data = useMonthlyData(filters);
            const { tableData, footerData } = useMemo(() => {
                const shareholderData = {};
                const allShareholders = [...new Set(data.shops.flatMap(s => (s.shareholders || []).map(sh => sh.name)))];
                allShareholders.forEach(name => { shareholderData[name] = { totalGCA: 0, totalNetIncome: 0, familyExpense: 0, finalNetIncome: 0, totalCOH: 0 }; });
                data.shops.forEach(shop => {
                    const openingGCA = shop.gca || 0;
                    const saleMargin = shop.saleMargin || 0;
                    const netSaleAllTime = data.allReports.filter(cd => cd.shop === shop.name).reduce((sum, cd) => sum + (cd.grandTotalKhr || 0), 0);
                    const salesContributionAllTime = netSaleAllTime * (1 - (saleMargin / 100));
                    const totalPOsAllTime = data.allPOs.filter(po => po.shop === shop.name).reduce((sum, po) => sum + ((po.amountKhr || 0) + (po.amountUsd || 0) * data.exchangeRate), 0);
                    const transfersInAllTime = data.allTransfers.filter(it => it.toShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    const transfersOutAllTime = data.allTransfers.filter(it => it.fromShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    const currentGCA = openingGCA + salesContributionAllTime - totalPOsAllTime - transfersInAllTime + transfersOutAllTime;
                    const netSaleForMonth = data.filteredReports.filter(cd => cd.shop === shop.name).reduce((sum, cd) => sum + (cd.grandTotalKhr || 0), 0);
                    const bizExpenseForMonth = data.filteredBusinessExpenses.filter(e => e.shop === shop.name).reduce((sum, e) => sum + (e.totalAmountKhr || 0), 0);
                    const netProfitForMonth = netSaleForMonth * (saleMargin / 100);
                    const totalNetIncomeForMonth = netProfitForMonth - bizExpenseForMonth;
                    (shop.shareholders || []).forEach(sh => { if(shareholderData[sh.name]) { shareholderData[sh.name].totalGCA += currentGCA * (sh.percentage / 100); shareholderData[sh.name].totalNetIncome += totalNetIncomeForMonth * (sh.percentage / 100); } });
                });
                data.filteredFamilyExpenses.forEach(expense => { if (shareholderData[expense.paidBy]) { shareholderData[expense.paidBy].familyExpense += (expense.totalAmountKhr || 0); } });
                Object.keys(shareholderData).forEach(name => { const d = shareholderData[name]; d.finalNetIncome = d.totalNetIncome - d.familyExpense; d.totalCOH = d.finalNetIncome + d.totalGCA; });
                const totals = Object.values(shareholderData).reduce((acc, d) => { acc.totalGCA += d.totalGCA; acc.totalNetIncome += d.totalNetIncome; acc.familyExpense += d.familyExpense; acc.finalNetIncome += d.finalNetIncome; acc.totalCOH += d.totalCOH; return acc; }, { totalGCA: 0, totalNetIncome: 0, familyExpense: 0, finalNetIncome: 0, totalCOH: 0 });
                const tableData = Object.entries(shareholderData).map(([name, d], index) => ({
                    no: index + 1,
                    shareholder: <span className="font-semibold">{name}</span>,
                    totalGCA: d.totalGCA.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}),
                    totalNetIncome: d.totalNetIncome.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}),
                    familyExpense: d.familyExpense.toLocaleString(),
                    finalNetIncome: d.finalNetIncome.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}),
                    totalCOH: d.totalCOH.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})
                }));
                const footerData = [
                    { content: 'Sub-Total (KHR)', colSpan: 2, align: 'right' },
                    { content: totals.totalGCA.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' },
                    { content: totals.totalNetIncome.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' },
                    { content: totals.familyExpense.toLocaleString(), align: 'right' },
                    { content: totals.finalNetIncome.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' },
                    { content: totals.totalCOH.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' }
                ];
                return { tableData, footerData };
            }, [data]);
            const headers = [
                { key: 'no', label: 'No.' }, { key: 'shareholder', label: 'Shareholder' },
                { key: 'totalGCA', label: 'Total GCA', align: 'right' }, { key: 'totalNetIncome', label: 'Total Net-Income', align: 'right' },
                { key: 'familyExpense', label: 'Family Expense', align: 'right', className: () => 'text-red-600' },
                { key: 'finalNetIncome', label: 'Final Net-Income', align: 'right', className: () => 'font-bold' },
                { key: 'totalCOH', label: 'Total COH', align: 'right', className: () => 'font-bold text-indigo-600' }
            ];
            return (
                <Card><h3 className="text-lg font-bold mb-4">Shareholder NET</h3><ResponsiveTable headers={headers} data={tableData} footer={footerData} /></Card>
            );
        };
        // #endregion

        // =================================================================================
        // #region CASHFLOW HISTORY TAB
        // =================================================================================
        const CashflowHistoryTab = ({ filters }) => {
            const data = useMonthlyData(filters);
            const { tableData, footerData } = useMemo(() => {
                const shopCalculations = data.shops.map(shop => {
                    const openingGCA = shop.gca || 0;
                    const saleMargin = shop.saleMargin || 0;
                    const netSaleAllTime = data.allReports.filter(cd => cd.shop === shop.name).reduce((sum, cd) => sum + (cd.grandTotalKhr || 0), 0);
                    const salesContributionAllTime = netSaleAllTime * (1 - (saleMargin / 100));
                    const totalPOsAllTime = data.allPOs.filter(po => po.shop === shop.name).reduce((sum, po) => sum + ((po.amountKhr || 0) + (po.amountUsd || 0) * data.exchangeRate), 0);
                    const transfersInAllTime = data.allTransfers.filter(it => it.toShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    const transfersOutAllTime = data.allTransfers.filter(it => it.fromShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    const currentGCA = openingGCA + salesContributionAllTime - totalPOsAllTime - transfersInAllTime + transfersOutAllTime;
                    const netSaleForMonth = data.filteredReports.filter(cd => cd.shop === shop.name).reduce((sum, cd) => sum + (cd.grandTotalKhr || 0), 0);
                    const bizExpenseForMonth = data.filteredBusinessExpenses.filter(e => e.shop === shop.name).reduce((sum, e) => sum + (e.totalAmountKhr || 0), 0);
                    const netProfitForMonth = netSaleForMonth * (saleMargin / 100);
                    const totalNetIncomeForMonth = netProfitForMonth - bizExpenseForMonth;
                    const totalPOForMonth = data.filteredPurchaseOrders.filter(po => po.shop === shop.name).reduce((sum, po) => sum + ((po.amountKhr || 0) + (po.amountUsd || 0) * data.exchangeRate), 0);
                    const totalTransInForMonth = data.filteredInternalTransfers.filter(it => it.toShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    const totalTransOutForMonth = data.filteredInternalTransfers.filter(it => it.fromShop === shop.name).reduce((sum, it) => sum + (it.amountKhr || 0) + ((it.amountUsd || 0) * data.exchangeRate), 0);
                    return { name: shop.name, currentGCA, netSale: netSaleForMonth, netProfit: netProfitForMonth, totalPO: totalPOForMonth, totalTransIn: totalTransInForMonth, totalTransOut: totalTransOutForMonth, totalBizExpense: bizExpenseForMonth, totalNetIncome: totalNetIncomeForMonth };
                });
                const totals = shopCalculations.reduce((acc, shop) => { Object.keys(shop).forEach(key => { if (key !== 'name') acc[key] = (acc[key] || 0) + shop[key]; }); return acc; }, {});
                const tableData = shopCalculations.map((shop, index) => ({
                    no: index + 1,
                    shop: <span className="font-semibold">{shop.name}</span>,
                    currentGCA: shop.currentGCA.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}),
                    netSale: shop.netSale.toLocaleString(),
                    netProfit: shop.netProfit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}),
                    totalPO: shop.totalPO.toLocaleString(),
                    totalTransIn: shop.totalTransIn.toLocaleString(),
                    totalTransOut: shop.totalTransOut.toLocaleString(),
                    totalBizExpense: shop.totalBizExpense.toLocaleString(),
                    totalNetIncome: shop.totalNetIncome.toLocaleString()
                }));
                const footerData = [
                    { content: 'Sub-Totals', colSpan: 2, align: 'right' },
                    { content: totals.currentGCA?.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' },
                    { content: totals.netSale?.toLocaleString(), align: 'right' },
                    { content: totals.netProfit?.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}), align: 'right' },
                    { content: totals.totalPO?.toLocaleString(), align: 'right' },
                    { content: totals.totalTransIn?.toLocaleString(), align: 'right' },
                    { content: totals.totalTransOut?.toLocaleString(), align: 'right' },
                    { content: totals.totalBizExpense?.toLocaleString(), align: 'right' },
                    { content: totals.totalNetIncome?.toLocaleString(), align: 'right' }
                ];
                return { tableData, footerData };
            }, [data]);
            const headers = [
                { key: 'no', label: 'No.' }, { key: 'shop', label: 'Shop' },
                { key: 'currentGCA', label: 'Current GCA (៛)', align: 'right' },
                { key: 'netSale', label: 'Net Sale', align: 'right' },
                { key: 'netProfit', label: 'Net Profit', align: 'right', className: () => 'text-green-600' },
                { key: 'totalPO', label: 'Total PO', align: 'right', className: () => 'text-red-600' },
                { key: 'totalTransIn', label: 'Total Tran-IN', align: 'right' },
                { key: 'totalTransOut', label: 'Total-Trans-OUT', align: 'right' },
                { key: 'totalBizExpense', label: 'Total Biz Expense', align: 'right', className: () => 'text-red-600' },
                { key: 'totalNetIncome', label: 'Total Net Income', align: 'right', className: () => 'font-bold text-indigo-600 bg-green-50' }
            ];
            return (
                <Card><h3 className="text-lg font-bold mb-4">CashFlow History</h3><ResponsiveTable headers={headers} data={tableData} footer={footerData} /></Card>
            );
        };
        // #endregion

        // =================================================================================
        // #region IIT PAYMENT TAB
        // =================================================================================
        const IitPaymentTab = ({ filters, isCapturing }) => {
            const data = useMonthlyData(filters);
            const {shops} = useData();
            const [payeeFilter, setPayeeFilter] = useState('All');
            const { tableData, footerData } = useMemo(() => {
                let filteredTransfers = data.filteredInternalTransfers;
                if (payeeFilter !== 'All') {
                    filteredTransfers = filteredTransfers.filter(t => t.toShop === payeeFilter);
                }
                const iitPaymentData = Object.values(filteredTransfers.reduce((acc, transfer) => {
                    const key = `${transfer.toShop}-${transfer.fromShop}`;
                    if (!acc[key]) { acc[key] = { payee: transfer.toShop, receiver: transfer.fromShop, totalAmount: 0 }; }
                    acc[key].totalAmount += transfer.totalAmount || 0;
                    return acc;
                }, {}));
                const subtotal = iitPaymentData.reduce((sum, item) => sum + item.totalAmount, 0);
                const tableData = iitPaymentData.map((t, index) => ({
                    no: index + 1,
                    payee: t.payee,
                    receiver: t.receiver,
                    totalAmount: (t.totalAmount || 0).toLocaleString()
                }));
                const footerData = [
                    { content: 'Sub-Total', colSpan: 3, align: 'right' },
                    { content: subtotal.toLocaleString(), align: 'right' }
                ];
                return { tableData, footerData };
            }, [data, payeeFilter]);
            const headers = [
                { key: 'no', label: 'No.' }, { key: 'payee', label: 'Shop Payee' },
                { key: 'receiver', label: 'Shop Receiver' }, { key: 'totalAmount', label: 'Total Amount (៛)', align: 'right' }
            ];
            return (
                <Card>
                    <h3 className="text-lg font-bold mb-4">IIT Payment Report</h3>
                    <div className="mb-4 max-w-sm">
                        {isCapturing ? (
                            <div><label className="block text-sm font-medium text-gray-700 mb-1.5">Filter by Shop Payee</label><div className="block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm sm:text-sm">{payeeFilter}</div></div>
                        ) : (
                            <FormSelect label="Filter by Shop Payee" name="payee" value={payeeFilter} onChange={(e) => setPayeeFilter(e.target.value)} options={[{value: 'All', label: 'All Shops'}, ...shops.map(s => ({value: s.name, label: s.name}))]} />
                        )}
                    </div>
                    <ResponsiveTable headers={headers} data={tableData} footer={footerData} />
                </Card>
            );
        };
        // #endregion

        // =================================================================================
        // #region PERSONAL CASHFLOW TAB
        // =================================================================================
        const StatementEditModal = ({ statement, onClose }) => {
            const { showNotification } = useNotification();
            const { updateDoc, doc } = window.Firebase;
            const isMounted = useRef(true);
            
            const [formData, setFormData] = useState({
                ...statement,
                date: formatInCambodiaDateOnly(statement.createdAt),
                amount: String(statement.amount || ''),
            });
            const [isSubmitting, setIsSubmitting] = useState(false);

            useEffect(() => {
                isMounted.current = true;
                return () => { isMounted.current = false; };
            }, []);

            const handleChange = useCallback((e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            }, []);

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!isMounted.current) return;
                setIsSubmitting(true);
                try {
                    const updatedData = {
                        ...formData,
                        amount: parseFormattedNumber(formData.amount),
                        createdAt: createTimestampFromDateAndCurrentTime(formData.date),
                        flowType: formData.statementType === 'Deposit' ? 'Inflow' : 'Outflow'
                    };
                    delete updatedData.id;
                    delete updatedData.balanceKhr;
                    delete updatedData.balanceUsd;
                    delete updatedData.totalBalance;
                    
                    await updateDoc(doc(window.db, "personalCashflowStatements", statement.id), updatedData);
                    showNotification("Statement updated successfully!", "success");
                    if (isMounted.current) onClose();
                } catch (error) {
                    console.error("Update error:", error);
                    showNotification("Failed to update statement.", "error");
                } finally {
                    if (isMounted.current) setIsSubmitting(false);
                }
            };

            return (
                <Modal title="Edit Statement" onClose={onClose} size="lg">
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <FormInput label="Date" type="date" name="date" value={formData.date} onChange={handleChange} />
                            <FormSelect label="Statement Type" name="statementType" value={formData.statementType} onChange={handleChange} options={[{value: 'Deposit', label: 'Deposit'}, {value: 'Withdrawal', label: 'Withdrawal'}]} />
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <FormSelect label="Currency" name="currency" value={formData.currency} onChange={handleChange} options={[{value: 'KHR', label: 'KHR'}, {value: 'USD', label: 'USD'}]} />
                            <LiveFormatInput label="Amount" name="amount" value={formData.amount} onChange={handleChange} />
                        </div>
                        <FormInput label="Purpose" name="purpose" value={formData.purpose} onChange={handleChange} />
                        <FormTextarea label="Note" name="note" value={formData.note} onChange={handleChange} />
                        <div className="flex justify-end gap-4 pt-4 border-t">
                            <Button type="button" variant="secondary" onClick={onClose}>Cancel</Button>
                            <Button type="submit" disabled={isSubmitting} icon={isSubmitting ? "LoaderCircle" : null}>
                                {isSubmitting ? 'Saving...' : 'Save Changes'}
                            </Button>
                        </div>
                    </form>
                </Modal>
            );
        };

        const PersonalCashFlowManagement = () => {
            const { personalCashflowStatements, appSettings } = useData();
            const { showNotification } = useNotification();
            const { addDoc, collection, deleteDoc, doc } = window.Firebase;
            const [isSubmitting, setIsSubmitting] = useState(false);
            const [editingStatement, setEditingStatement] = useState(null);
            const [deletingStatement, setDeletingStatement] = useState(null);
            const [isDeleting, setIsDeleting] = useState(false);
            const isMounted = useRef(true);

            const [filters, setFilters] = useState({
                statementType: 'All',
                year: 'All',
                month: 'All'
            });

            useEffect(() => {
                isMounted.current = true;
                return () => { isMounted.current = false; };
            }, []);

            const getInitialState = useCallback(() => ({ 
                date: getCambodiaISODate(), 
                statementType: 'Deposit', 
                flowType: 'Inflow',
                currency: 'KHR', 
                amount: '', 
                purpose: '', 
                note: '' 
            }), []);
            const [formState, setFormState] = useState(getInitialState());

            const handleFormChange = (e) => {
                const { name, value } = e.target;
                setFormState(prev => ({ ...prev, [name]: value, ...(name === 'statementType' && { flowType: value === 'Deposit' ? 'Inflow' : 'Outflow' }) }));
            };

            const handleFilterChange = (e) => {
                const { name, value } = e.target;
                setFilters(prev => ({...prev, [name]: value}));
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!isMounted.current) return;
                setIsSubmitting(true);
                try {
                    const dataToSave = {
                         ...formState,
                        amount: parseFormattedNumber(formState.amount),
                        createdAt: createTimestampFromDateAndCurrentTime(formState.date),
                        flowType: formState.statementType === 'Deposit' ? 'Inflow' : 'Outflow'
                    };
                    await addDoc(collection(db, 'personalCashflowStatements'), dataToSave);
                    showNotification('Statement added successfully!', 'success');
                    if (isMounted.current) setFormState(getInitialState());
                } catch (error) {
                    showNotification('Failed to add statement.', 'error');
                } finally {
                    if (isMounted.current) setIsSubmitting(false);
                }
            };

            const handleDelete = async () => {
                if (!deletingStatement) return;
                setIsDeleting(true);
                try {
                    await deleteDoc(doc(db, 'personalCashflowStatements', deletingStatement.id));
                    showNotification('Statement deleted.', 'success');
                } catch (error) {
                    showNotification('Failed to delete statement.', 'error');
                } finally {
                    if (isMounted.current) {
                        setDeletingStatement(null);
                        setIsDeleting(false);
                    }
                }
            };
            
            const { years, months } = useMemo(() => {
                const years = [...new Set(personalCashflowStatements.filter(s => s.createdAt).map(s => s.createdAt.toDate().getFullYear()))].sort((a,b) => b-a);
                const months = [...new Set(personalCashflowStatements.filter(s => s.createdAt && (filters.year === 'All' || s.createdAt.toDate().getFullYear() == filters.year)).map(s => s.createdAt.toDate().getMonth()))]
                    .sort((a,b) => a-b)
                    .map(m => ({ value: m + 1, label: new Date(0, m).toLocaleString('default', { month: 'long' }) }));
                return { years, months };
            }, [personalCashflowStatements, filters.year]);

            const historyWithBalance = useMemo(() => {
                const sorted = [...personalCashflowStatements].sort((a,b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                
                let balanceKhr = 0;
                let balanceUsd = 0;
                const result = [];

                for (const statement of sorted) {
                    const amount = statement.amount || 0;
                    if (statement.statementType === 'Deposit') {
                        if (statement.currency === 'KHR') balanceKhr += amount;
                        else balanceUsd += amount;
                    } else { // Withdrawal
                        if (statement.currency === 'KHR') balanceKhr -= amount;
                        else balanceUsd -= amount;
                    }
                    const totalBalance = balanceKhr + (balanceUsd * (appSettings.exchangeRate || 4100));
                    result.push({ ...statement, balanceKhr, balanceUsd, totalBalance });
                }
                
                return result;
            }, [personalCashflowStatements, appSettings.exchangeRate]);
            
            const filteredHistory = useMemo(() => {
                return historyWithBalance.filter(item => {
                    if (!item.createdAt) return false;
                    const date = item.createdAt.toDate();
                    const yearMatch = filters.year === 'All' || date.getFullYear() == filters.year;
                    const monthMatch = filters.month === 'All' || (date.getMonth() + 1) == filters.month;
                    const statementTypeMatch = filters.statementType === 'All' || item.statementType === filters.statementType;
                    return yearMatch && monthMatch && statementTypeMatch;
                }).reverse();
            }, [historyWithBalance, filters]);

            const finalBalance = historyWithBalance[historyWithBalance.length - 1] || { balanceKhr: 0, balanceUsd: 0, totalBalance: 0 };

            return (
                <div className="space-y-6">
                    <Card>
                        <h2 className="text-xl font-bold mb-4">New Statement</h2>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                <FormInput label="Date" type="date" name="date" value={formState.date} onChange={handleFormChange} />
                                <FormSelect label="Statement Type" name="statementType" value={formState.statementType} onChange={handleFormChange} options={[{value: 'Deposit', label: 'Deposit'}, {value: 'Withdrawal', label: 'Withdrawal'}]} />
                                <FormInput label="Flow Type" name="flowType" value={formState.statementType === 'Deposit' ? 'Inflow' : 'Outflow'} disabled />
                            </div>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                <FormSelect label="Currency" name="currency" value={formState.currency} onChange={handleFormChange} options={[{value: 'KHR', label: 'KHR'}, {value: 'USD', label: 'USD'}]} />
                                <LiveFormatInput label="Amount" name="amount" value={formState.amount} onChange={handleFormChange} />
                                <FormInput label="Purpose" name="purpose" value={formState.purpose} onChange={handleFormChange} />
                            </div>
                            <FormTextarea label="Note" name="note" value={formState.note} onChange={handleFormChange} />
                            <div className="flex justify-end"><Button type="submit" disabled={isSubmitting} icon={isSubmitting ? "LoaderCircle" : null}>{isSubmitting ? 'Adding...' : 'Add Statement'}</Button></div>
                        </form>
                    </Card>
                    <Card>
                        <h2 className="text-xl font-bold mb-4">Cashflow Statement History</h2>
                        
                        <div className="bg-gray-50 p-4 rounded-lg mb-6 border">
                            <h3 className="text-lg font-semibold text-gray-800 mb-3">Current Balance</h3>
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 text-center">
                                <div>
                                    <p className="text-sm text-gray-500">KHR Balance</p>
                                    <p className="text-xl font-bold text-gray-900 font-mono">{formatCurrency(finalBalance.balanceKhr, 'KHR')}</p>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-500">USD Balance</p>
                                    <p className="text-xl font-bold text-gray-900 font-mono">{formatCurrency(finalBalance.balanceUsd, 'USD')}</p>
                                </div>
                                <div className="sm:border-l pl-4">
                                    <p className="text-sm text-gray-500">Total Balance (in KHR)</p>
                                    <p className="text-2xl font-extrabold text-indigo-600 font-mono">{formatCurrency(finalBalance.totalBalance, 'KHR')}</p>
                                </div>
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                             <FormSelect label="Filter by Statement Type" name="statementType" value={filters.statementType} onChange={handleFilterChange} options={[{value: 'All', label: 'All'}, {value: 'Deposit', label: 'Deposit'}, {value: 'Withdrawal', label: 'Withdrawal'}]} />
                             <FormSelect label="Filter by Year" name="year" value={filters.year} onChange={handleFilterChange} options={[{value: 'All', label: 'All'}, ...years.map(y => ({value: y, label: y}))]} />
                            <FormSelect label="Filter by Month" name="month" value={filters.month} onChange={handleFilterChange} options={[{value: 'All', label: 'All'}, ...months]} />
                        </div>

                        <div className="space-y-3">
                            {filteredHistory.length > 0 ? filteredHistory.map(item => {
                                const isDeposit = item.statementType === 'Deposit';
                                const amountColor = isDeposit ? 'text-green-600' : 'text-red-600';
                                const iconContainerColor = isDeposit ? 'bg-green-100' : 'bg-red-100';
                                const iconColor = isDeposit ? 'text-green-500' : 'text-red-500';

                                return (
                                    <div key={item.id} className="group flex items-center p-3 bg-white rounded-lg border hover:bg-gray-50 transition-colors">
                                        <div className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center ${iconContainerColor}`}>
                                            <Icon name={isDeposit ? 'ArrowUp' : 'ArrowDown'} className={iconColor} size={20} />
                                        </div>
                                        <div className="flex-grow ml-4">
                                            <p className="font-semibold text-gray-800">{item.purpose || 'Transaction'}</p>
                                            <p className="text-sm text-gray-500">{formatInCambodiaDateOnly(item.createdAt)} - {item.note || 'No note'}</p>
                                        </div>
                                        <div className="text-right">
                                            <p className={`font-bold text-lg font-mono ${amountColor}`}>{formatCurrency(item.amount, item.currency)}</p>
                                            <p className="text-xs text-gray-400 font-mono">Balance: {formatCurrency(item.totalBalance, 'KHR')}</p>
                                        </div>
                                        <div className="flex flex-col ml-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                            <Button variant="ghost" size="sm" onClick={() => setEditingStatement(item)}><Icon name="PenSquare" size={14} /></Button>
                                            <Button variant="ghost" size="sm" onClick={() => setDeletingStatement(item)} className="text-red-500"><Icon name="Trash2" size={14} /></Button>
                                        </div>
                                    </div>
                                )
                            }) : (
                                <p className="text-center text-gray-500 py-8">No statements for the selected period.</p>
                            )}
                        </div>
                    </Card>
                    {editingStatement && <StatementEditModal statement={editingStatement} onClose={() => setEditingStatement(null)} />}
                    {deletingStatement && <ConfirmationModal title="Delete Statement" message="Are you sure you want to delete this statement?" onConfirm={handleDelete} onClose={() => setDeletingStatement(null)} isSubmitting={isDeleting} confirmVariant="danger" confirmText="Delete" />}
                </div>
            )
        }
        // #endregion
        
        // =================================================================================
        // #region MAIN PAGE COMPONENT
        // =================================================================================
        const CashFlowReportPage = () => {
            const { cashDrops } = useData();
            const [activeTab, setActiveTab] = useState('shareholderNet');
            
            const availableYears = useMemo(() => {
                const years = new Set(cashDrops.filter(cd => cd.createdAt).map(cd => cd.createdAt.toDate().getFullYear()));
                return Array.from(years).sort((a,b) => b-a);
            }, [cashDrops]);

            const [filters, setFilters] = useState({ 
                year: new Date().getFullYear(),
                month: new Date().getMonth() + 1
            });
            
            useEffect(() => {
                if (availableYears.length > 0) {
                    setFilters(prev => ({ ...prev, year: availableYears[0] }));
                }
            }, [availableYears]);


            const printRef = useRef();
            const { showNotification } = useNotification();
            const [isCapturing, setIsCapturing] = useState(false);
            const isMounted = useRef(true);

            useEffect(() => {
                isMounted.current = true;
                return () => { isMounted.current = false; };
            }, []);

            const handleDownloadImage = useCallback(async () => {
                if (!printRef.current || !isMounted.current) return;
                setIsCapturing(true);
                // Use a short timeout to allow the UI to update to the "capturing" state
                setTimeout(async () => {
                    try {
                        const canvas = await html2canvas(printRef.current, { 
                            useCORS: true, 
                            scale: 2,
                            backgroundColor: '#f1f5f9' // Match body background
                        });
                        const image = canvas.toDataURL("image/png", 1.0);
                        const link = document.createElement('a');
                        link.href = image;
                        link.download = `JLW-cashflow-report-${filters.year}-${filters.month}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        showNotification("Image downloaded successfully!", "success");
                    } catch (error) {
                        console.error("Failed to download image:", error);
                        showNotification("Failed to download image.", "error");
                    } finally {
                        if(isMounted.current) setIsCapturing(false);
                    }
                }, 100);
            }, [filters.year, filters.month, showNotification]);

            const TabButton = ({ tabName, label, isActive, onClick }) => (
                <button onClick={() => onClick(tabName)} className={`px-3 sm:px-4 py-2 text-sm font-semibold rounded-t-lg whitespace-nowrap ${isActive ? 'border-b-2 border-indigo-600 text-indigo-600' : 'text-slate-500 hover:bg-slate-100'}`}>
                    {label}
                </button>
            );

            return (
                <div>
                    <PageHeader title="CashFlow Report" subtitle="Monthly financial overview.">
                         <Button onClick={handleDownloadImage} disabled={isCapturing} variant="secondary" icon={isCapturing ? 'LoaderCircle' : 'Download'}>
                            <span className="hidden sm:inline">{isCapturing ? 'Capturing...' : 'Download'}</span>
                            <span className="sm:hidden">PNG</span>
                        </Button>
                    </PageHeader>
                    <div className="border-b border-gray-200 flex space-x-1 sm:space-x-2 flex-wrap">
                        <TabButton tabName="shareholderNet" label="Shareholder NET" isActive={activeTab === 'shareholderNet'} onClick={setActiveTab} />
                        <TabButton tabName="cashflowHistory" label="CashFlow History" isActive={activeTab === 'cashflowHistory'} onClick={setActiveTab} />
                        <TabButton tabName="iitPayment" label="IIT Payment" isActive={activeTab === 'iitPayment'} onClick={setActiveTab} />
                        <TabButton tabName="personalCashflow" label="Personal" isActive={activeTab === 'personalCashflow'} onClick={setActiveTab} />
                    </div>
                    
                    <div className="mt-6">
                        {activeTab !== 'personalCashflow' && (
                            <Card className="mb-6">
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                    <FormSelect label="Select Year" name="year" value={filters.year} onChange={(e) => setFilters(prev => ({...prev, year: e.target.value}))} options={availableYears.map(y => ({value: y, label: y}))} />
                                    <FormSelect label="Select Month" name="month" value={filters.month} onChange={(e) => setFilters(prev => ({...prev, month: e.target.value}))} options={[...Array(12).keys()].map(m => ({value: m+1, label: new Date(0,m).toLocaleString('default', {month: 'long'})}))} />
                                </div>
                            </Card>
                        )}
                        
                        <div ref={printRef} className="bg-gray-100 space-y-6">
                            {activeTab === 'shareholderNet' && <ShareholderNetTab filters={filters} />}
                            {activeTab === 'cashflowHistory' && <CashflowHistoryTab filters={filters} />}
                            {activeTab === 'iitPayment' && <IitPaymentTab filters={filters} isCapturing={isCapturing} />}
                            {activeTab === 'personalCashflow' && <PersonalCashFlowManagement />}
                        </div>
                    </div>
                </div>
            );
        };
        // #endregion

        // =================================================================================
        // #region APP & AUTHENTICATION
        // =================================================================================
        const LoginPage = () => {
            const { signInWithEmailAndPassword, setPersistence, browserSessionPersistence, browserLocalPersistence } = window.Firebase;
            const { showNotification } = useNotification();
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [showPassword, setShowPassword] = useState(false);
            const [rememberMe, setRememberMe] = useState(false);
            const isMounted = useRef(true);
            useEffect(() => { isMounted.current = true; return () => { isMounted.current = false; }; }, []);

            const handleLogin = async (e) => {
                e.preventDefault();
                setIsLoading(true);
                try {
                    const persistence = rememberMe ? browserLocalPersistence : browserSessionPersistence;
                    await setPersistence(window.auth, persistence);
                    await signInWithEmailAndPassword(window.auth, email, password);
                } catch (err) {
                    showNotification('Login failed. Please check your credentials.', 'error');
                } finally {
                    if (isMounted.current) setIsLoading(false);
                }
            };

            return (
                <div className="flex items-center justify-center min-h-full bg-gray-100 px-4 py-12 sm:px-6 lg:px-8">
                    <div className="w-full max-w-md space-y-8">
                        <div>
                            <Icon name="Landmark" className="mx-auto h-12 w-auto text-indigo-600" />
                            <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">CashFlow Report</h2>
                        </div>
                        <form onSubmit={handleLogin} className="mt-8 space-y-6">
                            <div className="rounded-md shadow-sm space-y-4">
                                <FormInput label="Email address" name="email" type="email" value={email} onChange={(e) => setEmail(e.target.value)} required placeholder="Email address" />
                                <div>
                                    <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1.5">Password</label>
                                    <div className="relative">
                                        <input id="password" name="password" type={showPassword ? 'text' : 'password'} value={password} onChange={(e) => setPassword(e.target.value)} required className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent sm:text-sm" placeholder="Password" />
                                        <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-500 hover:text-gray-700"><Icon name={showPassword ? 'EyeOff' : 'Eye'} /></button>
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center"><input id="remember-me" name="remember-me" type="checkbox" checked={rememberMe} onChange={(e) => setRememberMe(e.target.checked)} className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" /><label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">Remember me</label></div>
                            <div><Button type="submit" disabled={isLoading} className="w-full" icon={isLoading ? "LoaderCircle" : null}>{isLoading ? 'Signing in...' : 'Sign in'}</Button></div>
                        </form>
                    </div>
                </div>
            );
        };

        const App = () => {
            const { user, isLoading, userData } = useData();
            
            // PWA Manifest setup
            useEffect(() => {
                const manifest = {
                    "name": "JLW CashFlow Report",
                    "short_name": "CashFlow",
                    "start_url": ".",
                    "display": "standalone",
                    "background_color": "#f1f5f9",
                    "theme_color": "#4f46e5",
                    "description": "A standalone cashflow reporting application.",
                    "icons": [{
                        "src": "https://i.imgur.com/Ahdcb2w.png",
                        "sizes": "192x192",
                        "type": "image/png"
                    }]
                };
                const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
                const manifestURL = URL.createObjectURL(manifestBlob);
                document.querySelector('#manifest').setAttribute('href', manifestURL);
            }, []);

            if (isLoading) return <div className="flex items-center justify-center h-screen bg-gray-100"><Icon name="LoaderCircle" size={48} className="animate-spin text-indigo-600" /></div>;
            if (!user || !userData) return <LoginPage />;
            
            return (
                <div className="h-full flex flex-col">
                    <header className="flex-shrink-0 flex h-16 bg-white shadow-sm border-b border-gray-200 px-4 sm:px-6 lg:px-8">
                        <div className="flex-1 flex justify-between items-center">
                            <h1 className="text-lg sm:text-xl font-bold text-gray-800">JLW - CashFlow Report</h1>
                            <Button onClick={() => window.Firebase.signOut(window.auth)} variant="secondary">Sign Out</Button>
                        </div>
                    </header>
                    <main className="flex-1 overflow-y-auto bg-gray-100">
                        <div className="py-6">
                            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                                <CashFlowReportPage />
                            </div>
                        </div>
                    </main>
                </div>
            );
        }

        ReactDOM.render(
            <NotificationProvider>
                <DataProvider>
                    <App />
                </DataProvider>
            </NotificationProvider>, 
            document.getElementById('root')
        );
        // #endregion
    </script>
</body>
</html>
